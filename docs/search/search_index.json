{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"nim-libp2p documentation","text":"<p>Welcome to the nim-libp2p documentation!</p> <p>Here, you'll find tutorials to help you get started, as well as  the full reference.</p>"},{"location":"circuitrelay/","title":"Circuit Relay","text":"<pre><code>{.used.}\n</code></pre>"},{"location":"circuitrelay/#circuit-relay-example","title":"Circuit Relay example","text":"<p>Circuit Relay can be used when a node cannot reach another node directly, but can reach it through another node (the Relay).</p> <p>That may happen because of NAT, Firewalls, or incompatible transports.</p> <p>More informations here.</p> <pre><code>import chronos, stew/byteutils\nimport libp2p, libp2p/protocols/connectivity/relay/[relay, client]\n\n# Helper to create a circuit relay node\nproc createCircuitRelaySwitch(r: Relay): Switch =\n  SwitchBuilder\n  .new()\n  .withRng(newRng())\n  .withAddresses(@[MultiAddress.init(\"/ip4/0.0.0.0/tcp/0\").tryGet()])\n  .withTcpTransport()\n  .withMplex()\n  .withNoise()\n  .withCircuitRelay(r)\n  .build()\n\nproc main() {.async.} =\n  # Create a custom protocol\n  let customProtoCodec = \"/test\"\n  var proto = new LPProtocol\n  proto.codec = customProtoCodec\n  proto.handler = proc(\n      conn: Connection, proto: string\n  ) {.async: (raises: [CancelledError]).} =\n    try:\n      var msg = string.fromBytes(await conn.readLp(1024))\n      echo \"1 - Dst Received: \", msg\n      assert \"test1\" == msg\n      await conn.writeLp(\"test2\")\n      msg = string.fromBytes(await conn.readLp(1024))\n      echo \"2 - Dst Received: \", msg\n      assert \"test3\" == msg\n      await conn.writeLp(\"test4\")\n    except LPStreamError as exc:\n      echo \"exception in handler\", exc.msg\n\n  let\n    relay = Relay.new()\n    clSrc = RelayClient.new()\n    clDst = RelayClient.new()\n\n    # Create three hosts, enable relay client on two of them.\n    # The third one can relay connections for other peers.\n    # RelayClient can use a relay, Relay is a relay.\n    swRel = createCircuitRelaySwitch(relay)\n    swSrc = createCircuitRelaySwitch(clSrc)\n    swDst = createCircuitRelaySwitch(clDst)\n\n  swDst.mount(proto)\n\n  await swRel.start()\n  await swSrc.start()\n  await swDst.start()\n\n  let\n    # Create a relay address to swDst using swRel as the relay\n    addrs = MultiAddress\n      .init(\n        $swRel.peerInfo.addrs[0] &amp; \"/p2p/\" &amp; $swRel.peerInfo.peerId &amp; \"/p2p-circuit\"\n      )\n      .get()\n\n  # Connect Dst to the relay\n  await swDst.connect(swRel.peerInfo.peerId, swRel.peerInfo.addrs)\n\n  # Dst reserve a slot on the relay.\n  let rsvp = await clDst.reserve(swRel.peerInfo.peerId, swRel.peerInfo.addrs)\n\n  # Src dial Dst using the relay\n  let conn = await swSrc.dial(swDst.peerInfo.peerId, @[addrs], customProtoCodec)\n\n  await conn.writeLp(\"test1\")\n  var msg = string.fromBytes(await conn.readLp(1024))\n  echo \"1 - Src Received: \", msg\n  assert \"test2\" == msg\n  await conn.writeLp(\"test3\")\n  msg = string.fromBytes(await conn.readLp(1024))\n  echo \"2 - Src Received: \", msg\n  assert \"test4\" == msg\n\n  await relay.stop()\n  await allFutures(swSrc.stop(), swDst.stop(), swRel.stop())\n\nwaitFor(main())\n</code></pre>"},{"location":"tutorial_1_connect/","title":"Simple connection","text":"<pre><code>{.used.}\n</code></pre>"},{"location":"tutorial_1_connect/#simple-ping-tutorial","title":"Simple ping tutorial","text":"<p>Hi all, welcome to the first nim-libp2p tutorial!</p> <p>This tutorial is for everyone who is interested in building peer-to-peer applications. No Nim programming experience is needed.</p> <p>To give you a quick overview, Nim is the programming language we are using and nim-libp2p is the Nim implementation of libp2p, a modular library that enables the development of peer-to-peer network applications.</p> <p>Hope you'll find it helpful in your journey of learning. Happy coding! ;)</p>"},{"location":"tutorial_1_connect/#before-you-start","title":"Before you start","text":"<p>The only prerequisite here is Nim, the programming language with a Python-like syntax and a performance similar to C. Detailed information can be found here.</p> <p>Install Nim via their official website. Check Nim's installation via <code>nim --version</code> and its package manager Nimble via <code>nimble --version</code>.</p> <p>You can now install the latest version of <code>nim-libp2p</code>: <pre><code>nimble install libp2p@#master\n</code></pre></p>"},{"location":"tutorial_1_connect/#a-simple-ping-application","title":"A simple ping application","text":"<p>We'll start by creating a simple application, which is starting two libp2p switch, and pinging each other using the Ping protocol.</p> <p>You can find the source of this tutorial (and other tutorials) in the libp2p/examples folder!</p> <p>Let's create a <code>part1.nim</code>, and import our dependencies: <pre><code>import chronos\n\nimport libp2p\nimport libp2p/protocols/ping\n</code></pre> chronos the asynchronous framework used by <code>nim-libp2p</code></p> <p>Next, we'll create a helper procedure to create our switches. A switch needs a bit of configuration, and it will be easier to do this configuration only once: <pre><code>proc createSwitch(ma: MultiAddress, rng: ref HmacDrbgContext): Switch =\n  var switch = SwitchBuilder\n    .new()\n    .withRng(rng)\n    # Give the application RNG\n    .withAddress(ma)\n    # Our local address(es)\n    .withTcpTransport()\n    # Use TCP as transport\n    .withMplex()\n    # Use Mplex as muxer\n    .withNoise()\n    # Use Noise as secure manager\n    .build()\n\n  return switch\n</code></pre> This will create a switch using Mplex as a multiplexer, Noise to secure the communication, and TCP as an underlying transport.</p> <p>You can of course tweak this, to use a different or multiple transport, or tweak the configuration of Mplex and Noise, but this is some sane defaults that we'll use going forward.</p> <p>Let's now start to create our main procedure: <pre><code>proc main() {.async.} =\n  let\n    rng = newRng()\n    localAddress = MultiAddress.init(\"/ip4/0.0.0.0/tcp/0\").tryGet()\n    pingProtocol = Ping.new(rng = rng)\n</code></pre> We created some variables that we'll need for the rest of the application: the global <code>rng</code> instance, our <code>localAddress</code>, and an instance of the <code>Ping</code> protocol. The address is in the MultiAddress format. The port <code>0</code> means \"take any port available\".</p> <p><code>tryGet</code> is procedure which is part of nim-result, that will throw an exception if the supplied MultiAddress is invalid.</p> <p>We can now create our two switches: <pre><code>  let\n    switch1 = createSwitch(localAddress, rng)\n    switch2 = createSwitch(localAddress, rng)\n\n  switch1.mount(pingProtocol)\n\n  await switch1.start()\n  await switch2.start()\n</code></pre> We've mounted the <code>pingProtocol</code> on our first switch. This means that the first switch will actually listen for any ping requests coming in, and handle them accordingly.</p> <p>Now that we've started the nodes, they are listening for incoming peers. We can find out which port was attributed, and the resulting local addresses, by using <code>switch1.peerInfo.addrs</code>.</p> <p>We'll dial the first switch from the second one, by specifying its Peer ID, its MultiAddress and the <code>Ping</code> protocol codec: <pre><code>  let conn =\n    await switch2.dial(switch1.peerInfo.peerId, switch1.peerInfo.addrs, PingCodec)\n</code></pre> We now have a <code>Ping</code> connection setup between the second and the first switch, we can use it to actually ping the node: <pre><code>  # ping the other node and echo the ping duration\n  echo \"ping: \", await pingProtocol.ping(conn)\n\n  # We must close the connection ourselves when we're done with it\n  await conn.close()\n</code></pre> And that's it! Just a little bit of cleanup: shutting down the switches, waiting for them to stop, and we'll call our <code>main</code> procedure: <pre><code>  await allFutures(switch1.stop(), switch2.stop())\n    # close connections and shutdown all transports\n\nwaitFor(main())\n</code></pre> You can now run this program using <code>nim c -r part1.nim</code>, and you should see the dialing sequence, ending with a ping output.</p> <p>In the next tutorial, we'll look at how to create our own custom protocol.</p>"},{"location":"tutorial_2_customproto/","title":"Create a custom protocol","text":"<pre><code>{.used.}\n</code></pre>"},{"location":"tutorial_2_customproto/#custom-protocol-in-libp2p","title":"Custom protocol in libp2p","text":"<p>In the previous tutorial, we've looked at how to create a simple ping program using the <code>nim-libp2p</code>.</p> <p>We'll now look at how to create a custom protocol inside the libp2p</p> <p>Let's create a <code>part2.nim</code>, and import our dependencies: <pre><code>import chronos\nimport stew/byteutils\n\nimport libp2p\n</code></pre> This is similar to the first tutorial, except we don't need to import the <code>Ping</code> protocol.</p> <p>Next, we'll declare our custom protocol <pre><code>const TestCodec = \"/test/proto/1.0.0\"\n\ntype TestProto = ref object of LPProtocol\n</code></pre> We've set a protocol ID, and created a custom <code>LPProtocol</code>. In a more complex protocol, we could use this structure to store interesting variables.</p> <p>A protocol generally has two parts: a handling/server part, and a dialing/client part. These two parts can be identical, but in our trivial protocol, the server will wait for a message from the client, and the client will send a message, so we have to handle the two cases separately.</p> <p>Let's start with the server part: <pre><code>proc new(T: typedesc[TestProto]): T =\n  # every incoming connections will in be handled in this closure\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\n    # Read up to 1024 bytes from this connection, and transform them into\n    # a string\n    try:\n      echo \"Got from remote - \", string.fromBytes(await conn.readLp(1024))\n    except LPStreamError as exc:\n      echo \"exception in handler\", exc.msg\n    finally:\n      await conn.close()\n\n  return T.new(codecs = @[TestCodec], handler = handle)\n</code></pre> This is a constructor for our <code>TestProto</code>, that will specify our <code>codecs</code> and a <code>handler</code>, which will be called for each incoming peer asking for this protocol. In our handle, we simply read a message from the connection and <code>echo</code> it.</p> <p>We can now create our client part: <pre><code>proc hello(p: TestProto, conn: Connection) {.async.} =\n  await conn.writeLp(\"Hello p2p!\")\n</code></pre> Again, pretty straightforward, we just send a message on the connection.</p> <p>We can now create our main procedure: <pre><code>proc main() {.async.} =\n  let\n    rng = newRng()\n    testProto = TestProto.new()\n    switch1 = newStandardSwitch(rng = rng)\n    switch2 = newStandardSwitch(rng = rng)\n\n  switch1.mount(testProto)\n\n  await switch1.start()\n  await switch2.start()\n\n  let conn =\n    await switch2.dial(switch1.peerInfo.peerId, switch1.peerInfo.addrs, TestCodec)\n\n  await testProto.hello(conn)\n\n  # We must close the connection ourselves when we're done with it\n  await conn.close()\n\n  await allFutures(switch1.stop(), switch2.stop())\n    # close connections and shutdown all transports\n</code></pre> This is very similar to the first tutorial's <code>main</code>, the only noteworthy difference is that we use <code>newStandardSwitch</code>, which is similar to the <code>createSwitch</code> of the first tutorial, but is bundled directly in libp2p</p> <p>We can now wrap our program by calling our main proc: <pre><code>waitFor(main())\n</code></pre> And that's it! In the next tutorial, we'll create a more complex protocol using Protobuf.</p>"},{"location":"tutorial_3_protobuf/","title":"Protobuf","text":"<pre><code>{.used.}\n</code></pre>"},{"location":"tutorial_3_protobuf/#protobuf-usage","title":"Protobuf usage","text":"<p>In the previous tutorial, we created a simple \"ping\" protocol. Most real protocol want their messages to be structured and extensible, which is why most real protocols use protobuf to define their message structures.</p> <p>Here, we'll create a slightly more complex protocol, which parses &amp; generate protobuf messages. Let's start by importing our dependencies, as usual: <pre><code>import chronos\nimport results # for Opt[T]\n\nimport libp2p\n</code></pre></p>"},{"location":"tutorial_3_protobuf/#protobuf-encoding-decoding","title":"Protobuf encoding &amp; decoding","text":"<p>This will be the structure of our messages: <pre><code>message MetricList {\n  message Metric {\n    string name = 1;\n    float value = 2;\n  }\n\n  repeated Metric metrics = 2;\n}\n</code></pre> We'll create our protobuf types, encoders &amp; decoders, according to this format. To create the encoders &amp; decoders, we are going to use minprotobuf (included in libp2p).</p> <p>While more modern technics (such as nim-protobuf-serialization) exists, minprotobuf is currently the recommended method to handle protobuf, since it has been used in production extensively, and audited. <pre><code>type\n  Metric = object\n    name: string\n    value: float\n\n  MetricList = object\n    metrics: seq[Metric]\n\n{.push raises: [].}\n\nproc encode(m: Metric): ProtoBuffer =\n  result = initProtoBuffer()\n  result.write(1, m.name)\n  result.write(2, m.value)\n  result.finish()\n\nproc decode(_: type Metric, buf: seq[byte]): Result[Metric, ProtoError] =\n  var res: Metric\n  let pb = initProtoBuffer(buf)\n  # \"getField\" will return a Result[bool, ProtoError].\n  # The Result will hold an error if the protobuf is invalid.\n  # The Result will hold \"false\" if the field is missing\n  #\n  # We are just checking the error, and ignoring whether the value\n  # is present or not (default values are valid).\n  discard ?pb.getField(1, res.name)\n  discard ?pb.getField(2, res.value)\n  ok(res)\n\nproc encode(m: MetricList): ProtoBuffer =\n  result = initProtoBuffer()\n  for metric in m.metrics:\n    result.write(1, metric.encode())\n  result.finish()\n\nproc decode(_: type MetricList, buf: seq[byte]): Result[MetricList, ProtoError] =\n  var\n    res: MetricList\n    metrics: seq[seq[byte]]\n  let pb = initProtoBuffer(buf)\n  discard ?pb.getRepeatedField(1, metrics)\n\n  for metric in metrics:\n    res.metrics &amp;= ?Metric.decode(metric)\n  ok(res)\n</code></pre></p>"},{"location":"tutorial_3_protobuf/#results-instead-of-exceptions","title":"Results instead of exceptions","text":"<p>As you can see, this part of the program also uses Results instead of exceptions for error handling. We start by <code>{.push raises: [].}</code>, which will prevent every non-async function from raising exceptions.</p> <p>Then, we use nim-result to convey errors to function callers. A <code>Result[T, E]</code> will either hold a valid result of type T, or an error of type E.</p> <p>You can check if the call succeeded by using <code>res.isOk</code>, and then get the value using <code>res.value</code> or the error by using <code>res.error</code>.</p> <p>Another useful tool is <code>?</code>, which will unpack a Result if it succeeded, or if it failed, exit the current procedure returning the error.</p> <p>nim-result is packed with other functionalities that you'll find in the nim-result repository.</p> <p>Results and exception are generally interchangeable, but have different semantics that you may or may not prefer.</p>"},{"location":"tutorial_3_protobuf/#creating-the-protocol","title":"Creating the protocol","text":"<p>We'll next create a protocol, like in the last tutorial, to request these metrics from our host <pre><code>type\n  MetricCallback =\n    proc(): Future[MetricList] {.async: (raises: [CancelledError]), gcsafe.}\n  MetricProto = ref object of LPProtocol\n    metricGetter: MetricCallback\n\nproc new(_: typedesc[MetricProto], cb: MetricCallback): MetricProto =\n  var res: MetricProto\n  proc handle(conn: Connection, proto: string) {.async: (raises: [CancelledError]).} =\n    try:\n      let\n        metrics = await res.metricGetter()\n        asProtobuf = metrics.encode()\n      await conn.writeLp(asProtobuf.buffer)\n    except LPStreamError as exc:\n      echo \"exception in handler\", exc.msg\n    finally:\n      await conn.close()\n\n  res = MetricProto.new(@[\"/metric-getter/1.0.0\"], handle)\n  res.metricGetter = cb\n  return res\n\nproc fetch(p: MetricProto, conn: Connection): Future[MetricList] {.async.} =\n  let protobuf = await conn.readLp(2048)\n  # tryGet will raise an exception if the Result contains an error.\n  # It's useful to bridge between exception-world and result-world\n  return MetricList.decode(protobuf).tryGet()\n</code></pre> We can now create our main procedure: <pre><code>proc main() {.async.} =\n  let rng = newRng()\n  proc randomMetricGenerator(): Future[MetricList] {.async: (raises: [CancelledError]).} =\n    let metricCount = rng[].generate(uint32) mod 16\n    for i in 0 ..&lt; metricCount + 1:\n      result.metrics.add(\n        Metric(name: \"metric_\" &amp; $i, value: float(rng[].generate(uint16)) / 1000.0)\n      )\n    return result\n\n  let\n    metricProto1 = MetricProto.new(randomMetricGenerator)\n    metricProto2 = MetricProto.new(randomMetricGenerator)\n    switch1 = newStandardSwitch(rng = rng)\n    switch2 = newStandardSwitch(rng = rng)\n\n  switch1.mount(metricProto1)\n\n  await switch1.start()\n  await switch2.start()\n\n  let\n    conn = await switch2.dial(\n      switch1.peerInfo.peerId, switch1.peerInfo.addrs, metricProto2.codecs\n    )\n    metrics = await metricProto2.fetch(conn)\n  await conn.close()\n\n  for metric in metrics.metrics:\n    echo metric.name, \" = \", metric.value\n\n  await allFutures(switch1.stop(), switch2.stop())\n    # close connections and shutdown all transports\n\nwaitFor(main())\n</code></pre> If you run this program, you should see random metrics being sent from the switch1 to the switch2.</p>"},{"location":"tutorial_4_gossipsub/","title":"GossipSub","text":"<pre><code>{.used.}\n</code></pre>"},{"location":"tutorial_4_gossipsub/#gossipsub","title":"GossipSub","text":"<p>In this tutorial, we'll build a simple GossipSub network to broadcast the metrics we built in the previous tutorial.</p> <p>GossipSub is used to broadcast some messages in a network, and allows to balance between latency, bandwidth usage, privacy and attack resistance.</p> <p>You'll find a good explanation of how GossipSub works here. There are a lot of parameters you can tweak to adjust how GossipSub behaves but here we'll use the sane defaults shipped with libp2p.</p> <p>We'll start by creating our metric structure like previously <pre><code>import chronos\nimport results\n\nimport libp2p\nimport libp2p/protocols/pubsub/rpc/messages\n\ntype\n  Metric = object\n    name: string\n    value: float\n\n  MetricList = object\n    hostname: string\n    metrics: seq[Metric]\n\n{.push raises: [].}\n\nproc encode(m: Metric): ProtoBuffer =\n  result = initProtoBuffer()\n  result.write(1, m.name)\n  result.write(2, m.value)\n  result.finish()\n\nproc decode(_: type Metric, buf: seq[byte]): Result[Metric, ProtoError] =\n  var res: Metric\n  let pb = initProtoBuffer(buf)\n  discard ?pb.getField(1, res.name)\n  discard ?pb.getField(2, res.value)\n  ok(res)\n\nproc encode(m: MetricList): ProtoBuffer =\n  result = initProtoBuffer()\n  for metric in m.metrics:\n    result.write(1, metric.encode())\n  result.write(2, m.hostname)\n  result.finish()\n\nproc decode(_: type MetricList, buf: seq[byte]): Result[MetricList, ProtoError] =\n  var\n    res: MetricList\n    metrics: seq[seq[byte]]\n  let pb = initProtoBuffer(buf)\n  discard ?pb.getRepeatedField(1, metrics)\n\n  for metric in metrics:\n    res.metrics &amp;= ?Metric.decode(metric)\n  ?pb.getRequiredField(2, res.hostname)\n  ok(res)\n</code></pre> This is exactly like the previous structure, except that we added a <code>hostname</code> to distinguish where the metric is coming from.</p> <p>Now we'll create a small GossipSub network to broadcast the metrics, and collect them on one of the node. <pre><code>type Node = tuple[switch: Switch, gossip: GossipSub, hostname: string]\n\nproc oneNode(node: Node, rng: ref HmacDrbgContext) {.async.} =\n  # This procedure will handle one of the node of the network\n  node.gossip.addValidator(\n    [\"metrics\"],\n    proc(topic: string, message: Message): Future[ValidationResult] {.async.} =\n      let decoded = MetricList.decode(message.data)\n      if decoded.isErr:\n        return ValidationResult.Reject\n      return ValidationResult.Accept,\n  )\n  # This \"validator\" will attach to the `metrics` topic and make sure\n  # that every message in this topic is valid. This allows us to stop\n  # propagation of invalid messages quickly in the network, and punish\n  # peers sending them.\n\n  # `John` will be responsible to log the metrics, the rest of the nodes\n  # will just forward them in the network\n  if node.hostname == \"John\":\n    node.gossip.subscribe(\n      \"metrics\",\n      proc(topic: string, data: seq[byte]) {.async.} =\n        let m = MetricList.decode(data).expect(\"metric can be decoded\")\n        echo m\n      ,\n    )\n  else:\n    node.gossip.subscribe(\"metrics\", nil)\n\n  # Create random metrics 10 times and broadcast them\n  for _ in 0 ..&lt; 10:\n    await sleepAsync(500.milliseconds)\n    var metricList = MetricList(hostname: node.hostname)\n    let metricCount = rng[].generate(uint32) mod 4\n    for i in 0 ..&lt; metricCount + 1:\n      metricList.metrics.add(\n        Metric(name: \"metric_\" &amp; $i, value: float(rng[].generate(uint16)) / 1000.0)\n      )\n\n    discard await node.gossip.publish(\"metrics\", encode(metricList).buffer)\n  await node.switch.stop()\n</code></pre> For our main procedure, we'll create a few nodes, and connect them together. Note that they are not all interconnected, but GossipSub will take care of broadcasting to the full network nonetheless. <pre><code>proc main() {.async.} =\n  let rng = newRng()\n  var nodes: seq[Node]\n\n  for hostname in [\"John\", \"Walter\", \"David\", \"Thuy\", \"Amy\"]:\n    let\n      switch = newStandardSwitch(rng = rng)\n      gossip = GossipSub.init(switch = switch, triggerSelf = true)\n    switch.mount(gossip)\n    await switch.start()\n\n    nodes.add((switch, gossip, hostname))\n\n  for index, node in nodes:\n    # Connect to a few neighbors\n    for otherNodeIdx in index - 1 .. index + 2:\n      if otherNodeIdx notin 0 ..&lt; nodes.len or otherNodeIdx == index:\n        continue\n      let otherNode = nodes[otherNodeIdx]\n      await node.switch.connect(\n        otherNode.switch.peerInfo.peerId, otherNode.switch.peerInfo.addrs\n      )\n\n  var allFuts: seq[Future[void]]\n  for node in nodes:\n    allFuts.add(oneNode(node, rng))\n\n  await allFutures(allFuts)\n\nwaitFor(main())\n</code></pre> If you run this program, you should see something like: <pre><code>(hostname: \"John\", metrics: @[(name: \"metric_0\", value: 42.097), (name: \"metric_1\", value: 50.99), (name: \"metric_2\", value: 47.86), (name: \"metric_3\", value: 5.368)])\n(hostname: \"Walter\", metrics: @[(name: \"metric_0\", value: 39.452), (name: \"metric_1\", value: 15.606), (name: \"metric_2\", value: 14.059), (name: \"metric_3\", value: 6.68)])\n(hostname: \"David\", metrics: @[(name: \"metric_0\", value: 9.82), (name: \"metric_1\", value: 2.862), (name: \"metric_2\", value: 15.514)])\n(hostname: \"Thuy\", metrics: @[(name: \"metric_0\", value: 59.038)])\n(hostname: \"Amy\", metrics: @[(name: \"metric_0\", value: 55.616), (name: \"metric_1\", value: 23.52), (name: \"metric_2\", value: 59.081), (name: \"metric_3\", value: 2.516)])\n</code></pre></p> <p>This is John receiving &amp; logging everyone's metrics.</p>"},{"location":"tutorial_4_gossipsub/#going-further","title":"Going further","text":"<p>Building efficient &amp; safe GossipSub networks is a tricky subject. By tweaking the gossip params and topic params, you can achieve very different properties.</p> <p>Also see reports for GossipSub v1.1</p> <p>If you are interested in broadcasting for your application, you may want to use Waku, which builds on top of GossipSub, and adds features such as history, spam protection, and light node friendliness.</p>"}]}