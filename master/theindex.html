<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Index</title>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.2.6">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.2.6"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Index</h1>
      Modules: <a href="libp2p.html">libp2p</a>, <a href="libp2p/autotls/acme/api.html">libp2p/autotls/acme/api</a>, <a href="libp2p/autotls/acme/client.html">libp2p/autotls/acme/client</a>, <a href="libp2p/autotls/acme/utils.html">libp2p/autotls/acme/utils</a>, <a href="libp2p/autotls/service.html">libp2p/autotls/service</a>, <a href="libp2p/autotls/utils.html">libp2p/autotls/utils</a>, <a href="libp2p/builders.html">libp2p/builders</a>, <a href="libp2p/cid.html">libp2p/cid</a>, <a href="libp2p/connmanager.html">libp2p/connmanager</a>, <a href="libp2p/crypto/chacha20poly1305.html">libp2p/crypto/chacha20poly1305</a>, <a href="libp2p/crypto/crypto.html">libp2p/crypto/crypto</a>, <a href="libp2p/crypto/curve25519.html">libp2p/crypto/curve25519</a>, <a href="libp2p/crypto/ecnist.html">libp2p/crypto/ecnist</a>, <a href="libp2p/crypto/ed25519/constants.html">libp2p/crypto/ed25519/constants</a>, <a href="libp2p/crypto/ed25519/ed25519.html">libp2p/crypto/ed25519/ed25519</a>, <a href="libp2p/crypto/hkdf.html">libp2p/crypto/hkdf</a>, <a href="libp2p/crypto/minasn1.html">libp2p/crypto/minasn1</a>, <a href="libp2p/crypto/rsa.html">libp2p/crypto/rsa</a>, <a href="libp2p/crypto/secp.html">libp2p/crypto/secp</a>, <a href="libp2p/dial.html">libp2p/dial</a>, <a href="libp2p/dialer.html">libp2p/dialer</a>, <a href="libp2p/errors.html">libp2p/errors</a>, <a href="libp2p/multiaddress.html">libp2p/multiaddress</a>, <a href="libp2p/multibase.html">libp2p/multibase</a>, <a href="libp2p/multicodec.html">libp2p/multicodec</a>, <a href="libp2p/multihash.html">libp2p/multihash</a>, <a href="libp2p/multistream.html">libp2p/multistream</a>, <a href="libp2p/muxers/mplex/coder.html">libp2p/muxers/mplex/coder</a>, <a href="libp2p/muxers/mplex/lpchannel.html">libp2p/muxers/mplex/lpchannel</a>, <a href="libp2p/muxers/mplex/mplex.html">libp2p/muxers/mplex/mplex</a>, <a href="libp2p/muxers/muxer.html">libp2p/muxers/muxer</a>, <a href="libp2p/muxers/yamux/yamux.html">libp2p/muxers/yamux/yamux</a>, <a href="libp2p/nameresolving/nameresolver.html">libp2p/nameresolving/nameresolver</a>, <a href="libp2p/observedaddrmanager.html">libp2p/observedaddrmanager</a>, <a href="libp2p/peerid.html">libp2p/peerid</a>, <a href="libp2p/peeridauth/client.html">libp2p/peeridauth/client</a>, <a href="libp2p/peerinfo.html">libp2p/peerinfo</a>, <a href="libp2p/peerstore.html">libp2p/peerstore</a>, <a href="libp2p/protobuf/minprotobuf.html">libp2p/protobuf/minprotobuf</a>, <a href="libp2p/protocols/connectivity/autonat/server.html">libp2p/protocols/connectivity/autonat/server</a>, <a href="libp2p/protocols/connectivity/autonat/types.html">libp2p/protocols/connectivity/autonat/types</a>, <a href="libp2p/protocols/connectivity/autonatv2/client.html">libp2p/protocols/connectivity/autonatv2/client</a>, <a href="libp2p/protocols/connectivity/autonatv2/server.html">libp2p/protocols/connectivity/autonatv2/server</a>, <a href="libp2p/protocols/connectivity/autonatv2/service.html">libp2p/protocols/connectivity/autonatv2/service</a>, <a href="libp2p/protocols/connectivity/autonatv2/types.html">libp2p/protocols/connectivity/autonatv2/types</a>, <a href="libp2p/protocols/connectivity/autonatv2/utils.html">libp2p/protocols/connectivity/autonatv2/utils</a>, <a href="libp2p/protocols/connectivity/relay/client.html">libp2p/protocols/connectivity/relay/client</a>, <a href="libp2p/protocols/connectivity/relay/messages.html">libp2p/protocols/connectivity/relay/messages</a>, <a href="libp2p/protocols/connectivity/relay/rconn.html">libp2p/protocols/connectivity/relay/rconn</a>, <a href="libp2p/protocols/connectivity/relay/relay.html">libp2p/protocols/connectivity/relay/relay</a>, <a href="libp2p/protocols/connectivity/relay/rtransport.html">libp2p/protocols/connectivity/relay/rtransport</a>, <a href="libp2p/protocols/connectivity/relay/utils.html">libp2p/protocols/connectivity/relay/utils</a>, <a href="libp2p/protocols/identify.html">libp2p/protocols/identify</a>, <a href="libp2p/protocols/kademlia.html">libp2p/protocols/kademlia</a>, <a href="libp2p/protocols/kademlia/find.html">libp2p/protocols/kademlia/find</a>, <a href="libp2p/protocols/kademlia/get.html">libp2p/protocols/kademlia/get</a>, <a href="libp2p/protocols/kademlia/lookupstate.html">libp2p/protocols/kademlia/lookupstate</a>, <a href="libp2p/protocols/kademlia/ping.html">libp2p/protocols/kademlia/ping</a>, <a href="libp2p/protocols/kademlia/protobuf.html">libp2p/protocols/kademlia/protobuf</a>, <a href="libp2p/protocols/kademlia/provider.html">libp2p/protocols/kademlia/provider</a>, <a href="libp2p/protocols/kademlia/put.html">libp2p/protocols/kademlia/put</a>, <a href="libp2p/protocols/kademlia/routingtable.html">libp2p/protocols/kademlia/routingtable</a>, <a href="libp2p/protocols/kademlia/types.html">libp2p/protocols/kademlia/types</a>, <a href="libp2p/protocols/ping.html">libp2p/protocols/ping</a>, <a href="libp2p/protocols/protocol.html">libp2p/protocols/protocol</a>, <a href="libp2p/protocols/pubsub.html">libp2p/protocols/pubsub</a>, <a href="libp2p/protocols/pubsub/bandwidth.html">libp2p/protocols/pubsub/bandwidth</a>, <a href="libp2p/protocols/pubsub/errors.html">libp2p/protocols/pubsub/errors</a>, <a href="libp2p/protocols/pubsub/floodsub.html">libp2p/protocols/pubsub/floodsub</a>, <a href="libp2p/protocols/pubsub/gossipsub.html">libp2p/protocols/pubsub/gossipsub</a>, <a href="libp2p/protocols/pubsub/gossipsub/behavior.html">libp2p/protocols/pubsub/gossipsub/behavior</a>, <a href="libp2p/protocols/pubsub/gossipsub/preamblestore.html">libp2p/protocols/pubsub/gossipsub/preamblestore</a>, <a href="libp2p/protocols/pubsub/gossipsub/scoring.html">libp2p/protocols/pubsub/gossipsub/scoring</a>, <a href="libp2p/protocols/pubsub/gossipsub/types.html">libp2p/protocols/pubsub/gossipsub/types</a>, <a href="libp2p/protocols/pubsub/mcache.html">libp2p/protocols/pubsub/mcache</a>, <a href="libp2p/protocols/pubsub/peertable.html">libp2p/protocols/pubsub/peertable</a>, <a href="libp2p/protocols/pubsub/pubsub.html">libp2p/protocols/pubsub/pubsub</a>, <a href="libp2p/protocols/pubsub/pubsubpeer.html">libp2p/protocols/pubsub/pubsubpeer</a>, <a href="libp2p/protocols/pubsub/rpc/message.html">libp2p/protocols/pubsub/rpc/message</a>, <a href="libp2p/protocols/pubsub/rpc/messages.html">libp2p/protocols/pubsub/rpc/messages</a>, <a href="libp2p/protocols/pubsub/rpc/protobuf.html">libp2p/protocols/pubsub/rpc/protobuf</a>, <a href="libp2p/protocols/pubsub/timedcache.html">libp2p/protocols/pubsub/timedcache</a>, <a href="libp2p/protocols/rendezvous.html">libp2p/protocols/rendezvous</a>, <a href="libp2p/protocols/rendezvous/protobuf.html">libp2p/protocols/rendezvous/protobuf</a>, <a href="libp2p/protocols/rendezvous/rendezvous.html">libp2p/protocols/rendezvous/rendezvous</a>, <a href="libp2p/protocols/secure/noise.html">libp2p/protocols/secure/noise</a>, <a href="libp2p/protocols/secure/secure.html">libp2p/protocols/secure/secure</a>, <a href="libp2p/routing_record.html">libp2p/routing_record</a>, <a href="libp2p/services/wildcardresolverservice.html">libp2p/services/wildcardresolverservice</a>, <a href="libp2p/signed_envelope.html">libp2p/signed_envelope</a>, <a href="libp2p/stream/bridgestream.html">libp2p/stream/bridgestream</a>, <a href="libp2p/stream/bufferstream.html">libp2p/stream/bufferstream</a>, <a href="libp2p/stream/chronosstream.html">libp2p/stream/chronosstream</a>, <a href="libp2p/stream/connection.html">libp2p/stream/connection</a>, <a href="libp2p/stream/lpstream.html">libp2p/stream/lpstream</a>, <a href="libp2p/switch.html">libp2p/switch</a>, <a href="libp2p/transcoder.html">libp2p/transcoder</a>, <a href="libp2p/transports/memorymanager.html">libp2p/transports/memorymanager</a>, <a href="libp2p/transports/memorytransport.html">libp2p/transports/memorytransport</a>, <a href="libp2p/transports/quictransport.html">libp2p/transports/quictransport</a>, <a href="libp2p/transports/tcptransport.html">libp2p/transports/tcptransport</a>, <a href="libp2p/transports/tls/certificate.html">libp2p/transports/tls/certificate</a>, <a href="libp2p/transports/tls/certificate_ffi.html">libp2p/transports/tls/certificate_ffi</a>, <a href="libp2p/transports/transport.html">libp2p/transports/transport</a>, <a href="libp2p/transports/wstransport.html">libp2p/transports/wstransport</a>, <a href="libp2p/upgrademngrs/muxedupgrade.html">libp2p/upgrademngrs/muxedupgrade</a>, <a href="libp2p/upgrademngrs/upgrade.html">libp2p/upgrademngrs/upgrade</a>, <a href="libp2p/utility.html">libp2p/utility</a>, <a href="libp2p/utils/bytesview.html">libp2p/utils/bytesview</a>, <a href="libp2p/utils/future.html">libp2p/utils/future</a>, <a href="libp2p/utils/heartbeat.html">libp2p/utils/heartbeat</a>, <a href="libp2p/utils/ipaddr.html">libp2p/utils/ipaddr</a>, <a href="libp2p/utils/offsettedseq.html">libp2p/utils/offsettedseq</a>, <a href="libp2p/utils/semaphore.html">libp2p/utils/semaphore</a>, <a href="libp2p/utils/sequninit.html">libp2p/utils/sequninit</a>, <a href="libp2p/utils/zeroqueue.html">libp2p/utils/zeroqueue</a>, <a href="libp2p/varint.html">libp2p/varint</a>, <a href="libp2p/vbuffer.html">libp2p/vbuffer</a>, <a href="libp2p/wire.html">libp2p/wire</a>.<br/><p /><h2>API symbols</h2>
<dl><dt><a name="%60%24%60" href="#%60%24%60"><span>`$`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc `$`(cid: Cid): string" href="libp2p/cid.html#%24%2CCid">cid: proc `$`(cid: Cid): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc `$`(key: PrivateKey | PublicKey): string" href="libp2p/crypto/crypto.html#%24">crypto: proc `$`(key: PrivateKey | PublicKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc `$`(sig: Signature): string" href="libp2p/crypto/crypto.html#%24%2CSignature">crypto: proc `$`(sig: Signature): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc `$`(seckey: EcPrivateKey): string" href="libp2p/crypto/ecnist.html#%24%2CEcPrivateKey">ecnist: proc `$`(seckey: EcPrivateKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc `$`(pubkey: EcPublicKey): string" href="libp2p/crypto/ecnist.html#%24%2CEcPublicKey">ecnist: proc `$`(pubkey: EcPublicKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc `$`(sig: EcSignature): string" href="libp2p/crypto/ecnist.html#%24%2CEcSignature">ecnist: proc `$`(sig: EcSignature): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc `$`(key: EdPrivateKey): string" href="libp2p/crypto/ed25519/ed25519.html#%24%2CEdPrivateKey">ed25519: proc `$`(key: EdPrivateKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc `$`(key: EdPublicKey): string" href="libp2p/crypto/ed25519/ed25519.html#%24%2CEdPublicKey">ed25519: proc `$`(key: EdPublicKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc `$`(sig: EdSignature): string" href="libp2p/crypto/ed25519/ed25519.html#%24%2CEdSignature">ed25519: proc `$`(sig: EdSignature): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc `$`(buffer: Asn1Buffer): string" href="libp2p/crypto/minasn1.html#%24%2CAsn1Buffer">minasn1: proc `$`(buffer: Asn1Buffer): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc `$`(field: Asn1Field): string" href="libp2p/crypto/minasn1.html#%24%2CAsn1Field">minasn1: proc `$`(field: Asn1Field): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc `$`(key: RsaPrivateKey): string" href="libp2p/crypto/rsa.html#%24%2CRsaPrivateKey">rsa: proc `$`(key: RsaPrivateKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc `$`(key: RsaPublicKey): string" href="libp2p/crypto/rsa.html#%24%2CRsaPublicKey">rsa: proc `$`(key: RsaPublicKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc `$`(sig: RsaSignature): string" href="libp2p/crypto/rsa.html#%24%2CRsaSignature">rsa: proc `$`(sig: RsaSignature): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `$`(key: SkKeyPair): string" href="libp2p/crypto/secp.html#%24%2CSkKeyPair">secp: proc `$`(key: SkKeyPair): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `$`(key: SkPrivateKey): string" href="libp2p/crypto/secp.html#%24%2CSkPrivateKey">secp: proc `$`(key: SkPrivateKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `$`(key: SkPublicKey): string" href="libp2p/crypto/secp.html#%24%2CSkPublicKey">secp: proc `$`(key: SkPublicKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `$`(key: SkSignature): string" href="libp2p/crypto/secp.html#%24%2CSkSignature">secp: proc `$`(key: SkSignature): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `$`(pat: MaPattern): string" href="libp2p/multiaddress.html#%24%2CMaPattern">multiaddress: proc `$`(pat: MaPattern): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `$`(value: MultiAddress): string" href="libp2p/multiaddress.html#%24%2CMultiAddress">multiaddress: proc `$`(value: MultiAddress): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc `$`(mc: MultiCodec): string" href="libp2p/multicodec.html#%24%2CMultiCodec">multicodec: proc `$`(mc: MultiCodec): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc `$`(mh: MultiHash): string" href="libp2p/multihash.html#%24%2CMultiHash">multihash: proc `$`(mh: MultiHash): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="observedaddrmanager: proc `$`(self: ObservedAddrManager): string" href="libp2p/observedaddrmanager.html#%24%2CObservedAddrManager">observedaddrmanager: proc `$`(self: ObservedAddrManager): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc `$`(pid: PeerId): string" href="libp2p/peerid.html#%24%2CPeerId">peerid: proc `$`(pid: PeerId): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routingtable: proc `$`(rt: RoutingTable): string" href="libp2p/protocols/kademlia/routingtable.html#%24%2CRoutingTable">routingtable: proc `$`(rt: RoutingTable): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peertable: proc `$`(table: PeerTable): string" href="libp2p/protocols/pubsub/peertable.html#%24%2CPeerTable">peertable: proc `$`(table: PeerTable): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc `$`(p: PubSubPeer): string" href="libp2p/protocols/pubsub/pubsubpeer.html#%24%2CPubSubPeer">pubsubpeer: proc `$`(p: PubSubPeer): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: proc `$`(vb: VBuffer): string" href="libp2p/vbuffer.html#%24%2CVBuffer">vbuffer: proc `$`(vb: VBuffer): string</a></li>
          </ul></dd>
<dt><a name="%60%26amp%3B%3D%60" href="#%60%26amp%3B%3D%60"><span>`&amp;=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `&amp;=`(m1: var MultiAddress; m2: MultiAddress)" href="libp2p/multiaddress.html#%26%3D%2CMultiAddress%2CMultiAddress">multiaddress: proc `&amp;=`(m1: var MultiAddress; m2: MultiAddress)</a></li>
          </ul></dd>
<dt><a name="%60%26amp%3B%60" href="#%60%26amp%3B%60"><span>`&amp;`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `&amp;`(m1, m2: MultiAddress): MultiAddress" href="libp2p/multiaddress.html#%26%2CMultiAddress%2CMultiAddress">multiaddress: proc `&amp;`(m1, m2: MultiAddress): MultiAddress</a></li>
          </ul></dd>
<dt><a name="%60%26lt%3B%3D%60" href="#%60%26lt%3B%3D%60"><span>`&lt;=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: template `&lt;=`(a, b: PeerId): bool" href="libp2p/peerid.html#%3C%3D.t%2CPeerId%2CPeerId">peerid: template `&lt;=`(a, b: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc `&lt;=`(a, b: XorDistance): bool" href="libp2p/protocols/kademlia/types.html#%3C%3D%2CXorDistance%2CXorDistance">types: proc `&lt;=`(a, b: XorDistance): bool</a></li>
          </ul></dd>
<dt><a name="%60%26lt%3B%60" href="#%60%26lt%3B%60"><span>`&lt;`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: template `&lt;`(a, b: PeerId): bool" href="libp2p/peerid.html#%3C.t%2CPeerId%2CPeerId">peerid: template `&lt;`(a, b: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc `&lt;`(a: ProviderRecord; b: chronos.Moment): bool" href="libp2p/protocols/kademlia/provider.html#%3C%2CProviderRecord%2C">provider: proc `&lt;`(a: ProviderRecord; b: chronos.Moment): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc `&lt;`(a, b: ProviderRecord): bool" href="libp2p/protocols/kademlia/provider.html#%3C%2CProviderRecord%2CProviderRecord">provider: proc `&lt;`(a, b: ProviderRecord): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc `&lt;`(a, b: XorDistance): bool" href="libp2p/protocols/kademlia/types.html#%3C%2CXorDistance%2CXorDistance">types: proc `&lt;`(a, b: XorDistance): bool</a></li>
          </ul></dd>
<dt><a name="%60%3D%3D%60" href="#%60%3D%3D%60"><span>`==`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc `==`(a: Cid; b: Cid): bool" href="libp2p/cid.html#%3D%3D%2CCid%2CCid">cid: proc `==`(a: Cid; b: Cid): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc `==`(key1, key2: PrivateKey): bool" href="libp2p/crypto/crypto.html#%3D%3D%2CPrivateKey%2CPrivateKey">crypto: proc `==`(key1, key2: PrivateKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc `==`(key1, key2: PublicKey): bool" href="libp2p/crypto/crypto.html#%3D%3D%2CPublicKey%2CPublicKey">crypto: proc `==`(key1, key2: PublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc `==`(seckey1, seckey2: EcPrivateKey): bool" href="libp2p/crypto/ecnist.html#%3D%3D%2CEcPrivateKey%2CEcPrivateKey">ecnist: proc `==`(seckey1, seckey2: EcPrivateKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc `==`(pubkey1, pubkey2: EcPublicKey): bool" href="libp2p/crypto/ecnist.html#%3D%3D%2CEcPublicKey%2CEcPublicKey">ecnist: proc `==`(pubkey1, pubkey2: EcPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc `==`(a, b: EcSignature): bool" href="libp2p/crypto/ecnist.html#%3D%3D%2CEcSignature%2CEcSignature">ecnist: proc `==`(a, b: EcSignature): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc `==`(eda, edb: EdPrivateKey): bool" href="libp2p/crypto/ed25519/ed25519.html#%3D%3D%2CEdPrivateKey%2CEdPrivateKey">ed25519: proc `==`(eda, edb: EdPrivateKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc `==`(eda, edb: EdPublicKey): bool" href="libp2p/crypto/ed25519/ed25519.html#%3D%3D%2CEdPublicKey%2CEdPublicKey">ed25519: proc `==`(eda, edb: EdPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc `==`(eda, edb: EdSignature): bool" href="libp2p/crypto/ed25519/ed25519.html#%3D%3D%2CEdSignature%2CEdSignature">ed25519: proc `==`(eda, edb: EdSignature): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc `==`(field: Asn1Field; data: openArray[byte]): bool" href="libp2p/crypto/minasn1.html#%3D%3D%2CAsn1Field%2CopenArray%5Bbyte%5D">minasn1: proc `==`(field: Asn1Field; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc `==`(a, b: RsaPrivateKey): bool" href="libp2p/crypto/rsa.html#%3D%3D%2CRsaPrivateKey%2CRsaPrivateKey">rsa: proc `==`(a, b: RsaPrivateKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc `==`(a, b: RsaPublicKey): bool" href="libp2p/crypto/rsa.html#%3D%3D%2CRsaPublicKey%2CRsaPublicKey">rsa: proc `==`(a, b: RsaPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc `==`(a, b: RsaSignature): bool" href="libp2p/crypto/rsa.html#%3D%3D%2CRsaSignature%2CRsaSignature">rsa: proc `==`(a, b: RsaSignature): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `==`(a, b: SkKeyPair): bool" href="libp2p/crypto/secp.html#%3D%3D%2CSkKeyPair%2CSkKeyPair">secp: proc `==`(a, b: SkKeyPair): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `==`(a, b: SkPrivateKey): bool" href="libp2p/crypto/secp.html#%3D%3D%2CSkPrivateKey%2CSkPrivateKey">secp: proc `==`(a, b: SkPrivateKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `==`(a, b: SkPublicKey): bool" href="libp2p/crypto/secp.html#%3D%3D%2CSkPublicKey%2CSkPublicKey">secp: proc `==`(a, b: SkPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc `==`(a, b: SkSignature): bool" href="libp2p/crypto/secp.html#%3D%3D%2CSkSignature%2CSkSignature">secp: proc `==`(a, b: SkSignature): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `==`(m1: var MultiAddress; m2: MultiAddress): bool" href="libp2p/multiaddress.html#%3D%3D%2CMultiAddress%2CMultiAddress">multiaddress: proc `==`(m1: var MultiAddress; m2: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc `==`(mc: MultiCodec; code: int): bool" href="libp2p/multicodec.html#%3D%3D%2CMultiCodec%2Cint">multicodec: proc `==`(mc: MultiCodec; code: int): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc `==`(a, b: MultiCodec): bool" href="libp2p/multicodec.html#%3D%3D%2CMultiCodec%2CMultiCodec">multicodec: proc `==`(a, b: MultiCodec): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc `==`(mc: MultiCodec; name: string): bool" href="libp2p/multicodec.html#%3D%3D%2CMultiCodec%2Cstring">multicodec: proc `==`(mc: MultiCodec; name: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc `==`[T](mdigest: MDigest[T]; mh: MultiHash): bool" href="libp2p/multihash.html#%3D%3D%2CMDigest%5BT%5D%2CMultiHash">multihash: proc `==`[T](mdigest: MDigest[T]; mh: MultiHash): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc `==`[T](mh: MultiHash; mdigest: MDigest[T]): bool" href="libp2p/multihash.html#%3D%3D%2CMultiHash%2CMDigest%5BT%5D">multihash: proc `==`[T](mh: MultiHash; mdigest: MDigest[T]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc `==`(a: MultiHash; b: MultiHash): bool" href="libp2p/multihash.html#%3D%3D%2CMultiHash%2CMultiHash">multihash: proc `==`(a: MultiHash; b: MultiHash): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: template `==`(a, b: PeerId): bool" href="libp2p/peerid.html#%3D%3D.t%2CPeerId%2CPeerId">peerid: template `==`(a, b: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc `==`(a, b: AutonatV2Msg): bool" href="libp2p/protocols/connectivity/autonatv2/types.html#%3D%3D%2CAutonatV2Msg%2CAutonatV2Msg">types: proc `==`(a, b: AutonatV2Msg): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc `==`(a, b: ProviderRecord): bool" href="libp2p/protocols/kademlia/provider.html#%3D%3D%2CProviderRecord%2CProviderRecord">provider: proc `==`(a, b: ProviderRecord): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc `==`(a, b: PubSubPeer): bool" href="libp2p/protocols/pubsub/pubsubpeer.html#%3D%3D%2CPubSubPeer%2CPubSubPeer">pubsubpeer: proc `==`(a, b: PubSubPeer): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="timedcache: proc `==`[E](a, b: TimedEntry[E]): bool" href="libp2p/protocols/pubsub/timedcache.html#%3D%3D%2CTimedEntry%5BE%5D%2CTimedEntry%5BE%5D">timedcache: proc `==`[E](a, b: TimedEntry[E]): bool</a></li>
          </ul></dd>
<dt><a name="%60%26gt%3B%3D%60" href="#%60%26gt%3B%3D%60"><span>`&gt;=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: template `&gt;=`(a, b: PeerId): bool" href="libp2p/peerid.html#%3E%3D.t%2CPeerId%2CPeerId">peerid: template `&gt;=`(a, b: PeerId): bool</a></li>
          </ul></dd>
<dt><a name="%60%26gt%3B%60" href="#%60%26gt%3B%60"><span>`&gt;`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: template `&gt;`(a, b: PeerId): bool" href="libp2p/peerid.html#%3E.t%2CPeerId%2CPeerId">peerid: template `&gt;`(a, b: PeerId): bool</a></li>
          </ul></dd>
<dt><a name="%60%5B%5D%3D%60" href="#%60%5B%5D%3D%60"><span>`[]=`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: proc `[]=`[T](peerBook: PeerBook[T]; peerId: PeerId; entry: T)" href="libp2p/peerstore.html#%5B%5D%3D%2CPeerBook%5BT%5D%2CPeerId%2CT">peerstore: proc `[]=`[T](peerBook: PeerBook[T]; peerId: PeerId; entry: T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc `[]=`(ps: var PreambleStore; msgId: MessageId; entry: PreambleInfo)" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#%5B%5D%3D%2CPreambleStore%2CMessageId%2CPreambleInfo">preamblestore: proc `[]=`(ps: var PreambleStore; msgId: MessageId; entry: PreambleInfo)</a></li>
          </ul></dd>
<dt><a name="%60%5B%5D%60" href="#%60%5B%5D%60"><span>`[]`:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `[]`(ma: MultiAddress; i: int | BackwardsIndex): MaResult[MultiAddress]" href="libp2p/multiaddress.html#%5B%5D%2CMultiAddress%2C">multiaddress: proc `[]`(ma: MultiAddress; i: int | BackwardsIndex): MaResult[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `[]`(ma: MultiAddress; slice: HSlice): MaResult[MultiAddress]" href="libp2p/multiaddress.html#%5B%5D%2CMultiAddress%2CHSlice">multiaddress: proc `[]`(ma: MultiAddress; slice: HSlice): MaResult[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc `[]`(ma: MultiAddress; codec: MultiCodec): MaResult[MultiAddress]" href="libp2p/multiaddress.html#%5B%5D%2CMultiAddress%2CMultiCodec">multiaddress: proc `[]`(ma: MultiAddress; codec: MultiCodec): MaResult[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc `[]`[T](peerBook: PeerBook[T]; peerId: PeerId): T" href="libp2p/peerstore.html#%5B%5D%2CPeerBook%5BT%5D%2CPeerId">peerstore: proc `[]`[T](peerBook: PeerBook[T]; peerId: PeerId): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc `[]`[T](p: PeerStore; typ: type[T]): T" href="libp2p/peerstore.html#%5B%5D%2CPeerStore%2Ctype%5BT%5D">peerstore: proc `[]`[T](p: PeerStore; typ: type[T]): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc `[]`(pr: ProviderRecords; i: int): ProviderRecord" href="libp2p/protocols/kademlia/provider.html#%5B%5D%2CProviderRecords%2Cint">provider: proc `[]`(pr: ProviderRecords; i: int): ProviderRecord</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc `[]`(ps: var PreambleStore; msgId: MessageId): PreambleInfo" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#%5B%5D%2CPreambleStore%2CMessageId">preamblestore: proc `[]`(ps: var PreambleStore; msgId: MessageId): PreambleInfo</a></li>
          <li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc `[]`[T](o: var OffsettedSeq[T]; index: int): var T" href="libp2p/utils/offsettedseq.html#%5B%5D%2COffsettedSeq%5BT%5D%2Cint">offsettedseq: proc `[]`[T](o: var OffsettedSeq[T]; index: int): var T</a></li>
          </ul></dd>
<dt><a name="accept" href="#accept"><span>accept:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rtransport: method accept(self: RelayTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/protocols/connectivity/relay/rtransport.html#accept.e%2CRelayTransport">rtransport: method accept(self: RelayTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorymanager: proc accept(self: memoryConnManager; address: string): MemoryListener" href="libp2p/transports/memorymanager.html#accept%2CmemoryConnManager%2Cstring">memorymanager: proc accept(self: memoryConnManager; address: string): MemoryListener</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorymanager: proc accept(self: MemoryListener): Future[Connection]" href="libp2p/transports/memorymanager.html#accept%2CMemoryListener">memorymanager: proc accept(self: MemoryListener): Future[Connection]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: method accept(self: MemoryTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/memorytransport.html#accept.e%2CMemoryTransport">memorytransport: method accept(self: MemoryTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method accept(self: QuicTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/quictransport.html#accept.e%2CQuicTransport">quictransport: method accept(self: QuicTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="tcptransport: method accept(self: TcpTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/tcptransport.html#accept.e%2CTcpTransport">tcptransport: method accept(self: TcpTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="transport: method accept(self: Transport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/transport.html#accept.e%2CTransport">transport: method accept(self: Transport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method accept(self: WsTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/wstransport.html#accept.e%2CWsTransport">wstransport: method accept(self: WsTransport): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="ACMEApi" href="#ACMEApi"><span>ACMEApi:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: type ACMEApi" href="libp2p/autotls/acme/api.html#ACMEApi">api: type ACMEApi</a></li>
          </ul></dd>
<dt><a name="ACMEAuthorizationsResponse" href="#ACMEAuthorizationsResponse"><span>ACMEAuthorizationsResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMEAuthorizationsResponse" href="libp2p/autotls/acme/api.html#ACMEAuthorizationsResponse">api: object ACMEAuthorizationsResponse</a></li>
          </ul></dd>
<dt><a name="ACMECertificate" href="#ACMECertificate"><span>ACMECertificate:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMECertificate" href="libp2p/autotls/acme/api.html#ACMECertificate">api: object ACMECertificate</a></li>
          </ul></dd>
<dt><a name="ACMECertificateResponse" href="#ACMECertificateResponse"><span>ACMECertificateResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMECertificateResponse" href="libp2p/autotls/acme/api.html#ACMECertificateResponse">api: object ACMECertificateResponse</a></li>
          </ul></dd>
<dt><a name="ACMEChallenge" href="#ACMEChallenge"><span>ACMEChallenge:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMEChallenge" href="libp2p/autotls/acme/api.html#ACMEChallenge">api: object ACMEChallenge</a></li>
          </ul></dd>
<dt><a name="ACMEChallengeCheck" href="#ACMEChallengeCheck"><span>ACMEChallengeCheck:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: ACMECheckKind.ACMEChallengeCheck" href="libp2p/autotls/acme/api.html#ACMEChallengeCheck">api: ACMECheckKind.ACMEChallengeCheck</a></li>
          </ul></dd>
<dt><a name="ACMEChallengeResponse" href="#ACMEChallengeResponse"><span>ACMEChallengeResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMEChallengeResponse" href="libp2p/autotls/acme/api.html#ACMEChallengeResponse">api: object ACMEChallengeResponse</a></li>
          </ul></dd>
<dt><a name="ACMEChallengeResponseWrapper" href="#ACMEChallengeResponseWrapper"><span>ACMEChallengeResponseWrapper:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMEChallengeResponseWrapper" href="libp2p/autotls/acme/api.html#ACMEChallengeResponseWrapper">api: object ACMEChallengeResponseWrapper</a></li>
          </ul></dd>
<dt><a name="ACMEChallengeStatus" href="#ACMEChallengeStatus"><span>ACMEChallengeStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: enum ACMEChallengeStatus" href="libp2p/autotls/acme/api.html#ACMEChallengeStatus">api: enum ACMEChallengeStatus</a></li>
          </ul></dd>
<dt><a name="ACMEChallengeToken" href="#ACMEChallengeToken"><span>ACMEChallengeToken:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: type ACMEChallengeToken" href="libp2p/autotls/acme/api.html#ACMEChallengeToken">api: type ACMEChallengeToken</a></li>
          </ul></dd>
<dt><a name="ACMEChallengeType" href="#ACMEChallengeType"><span>ACMEChallengeType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: enum ACMEChallengeType" href="libp2p/autotls/acme/api.html#ACMEChallengeType">api: enum ACMEChallengeType</a></li>
          </ul></dd>
<dt><a name="ACMECheckKind" href="#ACMECheckKind"><span>ACMECheckKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: enum ACMECheckKind" href="libp2p/autotls/acme/api.html#ACMECheckKind">api: enum ACMECheckKind</a></li>
          </ul></dd>
<dt><a name="ACMECheckResponse" href="#ACMECheckResponse"><span>ACMECheckResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMECheckResponse" href="libp2p/autotls/acme/api.html#ACMECheckResponse">api: object ACMECheckResponse</a></li>
          </ul></dd>
<dt><a name="ACMEClient" href="#ACMEClient"><span>ACMEClient:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type ACMEClient" href="libp2p/autotls/acme/client.html#ACMEClient">client: type ACMEClient</a></li>
          </ul></dd>
<dt><a name="ACMECompletedResponse" href="#ACMECompletedResponse"><span>ACMECompletedResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMECompletedResponse" href="libp2p/autotls/acme/api.html#ACMECompletedResponse">api: object ACMECompletedResponse</a></li>
          </ul></dd>
<dt><a name="ACMEDirectory" href="#ACMEDirectory"><span>ACMEDirectory:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMEDirectory" href="libp2p/autotls/acme/api.html#ACMEDirectory">api: object ACMEDirectory</a></li>
          </ul></dd>
<dt><a name="ACMEError" href="#ACMEError"><span>ACMEError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: object ACMEError" href="libp2p/autotls/acme/utils.html#ACMEError">utils: object ACMEError</a></li>
          </ul></dd>
<dt><a name="ACMEFinalizeResponse" href="#ACMEFinalizeResponse"><span>ACMEFinalizeResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMEFinalizeResponse" href="libp2p/autotls/acme/api.html#ACMEFinalizeResponse">api: object ACMEFinalizeResponse</a></li>
          </ul></dd>
<dt><a name="ACMEOrderCheck" href="#ACMEOrderCheck"><span>ACMEOrderCheck:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: ACMECheckKind.ACMEOrderCheck" href="libp2p/autotls/acme/api.html#ACMEOrderCheck">api: ACMECheckKind.ACMEOrderCheck</a></li>
          </ul></dd>
<dt><a name="ACMEOrderResponse" href="#ACMEOrderResponse"><span>ACMEOrderResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMEOrderResponse" href="libp2p/autotls/acme/api.html#ACMEOrderResponse">api: object ACMEOrderResponse</a></li>
          </ul></dd>
<dt><a name="ACMEOrderStatus" href="#ACMEOrderStatus"><span>ACMEOrderStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: enum ACMEOrderStatus" href="libp2p/autotls/acme/api.html#ACMEOrderStatus">api: enum ACMEOrderStatus</a></li>
          </ul></dd>
<dt><a name="ACMERegisterRequest" href="#ACMERegisterRequest"><span>ACMERegisterRequest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMERegisterRequest" href="libp2p/autotls/acme/api.html#ACMERegisterRequest">api: object ACMERegisterRequest</a></li>
          </ul></dd>
<dt><a name="ACMERegisterResponse" href="#ACMERegisterResponse"><span>ACMERegisterResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object ACMERegisterResponse" href="libp2p/autotls/acme/api.html#ACMERegisterResponse">api: object ACMERegisterResponse</a></li>
          </ul></dd>
<dt><a name="add" href="#add"><span>add:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc add[T](o: var OffsettedSeq[T]; v: T)" href="libp2p/utils/offsettedseq.html#add%2COffsettedSeq%5BT%5D%2CT">offsettedseq: proc add[T](o: var OffsettedSeq[T]; v: T)</a></li>
          </ul></dd>
<dt><a name="addCapped" href="#addCapped"><span>addCapped:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc addCapped[T](stat: var T; diff, cap: T)" href="libp2p/protocols/pubsub/gossipsub/scoring.html#addCapped%2CT%2CT%2CT">scoring: proc addCapped[T](stat: var T; diff, cap: T)</a></li>
          </ul></dd>
<dt><a name="addConnEventHandler" href="#addConnEventHandler"><span>addConnEventHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc addConnEventHandler(c: ConnManager; handler: ConnEventHandler;
                    kind: ConnEventKind)" href="libp2p/connmanager.html#addConnEventHandler%2CConnManager%2CConnEventHandler%2CConnEventKind">connmanager: proc addConnEventHandler(c: ConnManager; handler: ConnEventHandler;
                    kind: ConnEventKind)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc addConnEventHandler(s: Switch; handler: ConnEventHandler; kind: ConnEventKind)" href="libp2p/switch.html#addConnEventHandler%2CSwitch%2CConnEventHandler%2CConnEventKind">switch: proc addConnEventHandler(s: Switch; handler: ConnEventHandler; kind: ConnEventKind)</a></li>
          </ul></dd>
<dt><a name="addDirectPeer" href="#addDirectPeer"><span>addDirectPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: proc addDirectPeer(g: GossipSub; id: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/pubsub/gossipsub.html#addDirectPeer%2CGossipSub%2CPeerId%2Cseq%5BMultiAddress%5D">gossipsub: proc addDirectPeer(g: GossipSub; id: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="addedAt" href="#addedAt"><span>addedAt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="timedcache: proc addedAt[K](t: var TimedCache[K]; k: K): Moment" href="libp2p/protocols/pubsub/timedcache.html#addedAt%2CTimedCache%5BK%5D%2CK">timedcache: proc addedAt[K](t: var TimedCache[K]; k: K): Moment</a></li>
          </ul></dd>
<dt><a name="addHandler" href="#addHandler"><span>addHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: proc addHandler(m: MultistreamSelect; codecs: seq[string]; protocol: LPProtocol;
           matcher: Matcher = nil)" href="libp2p/multistream.html#addHandler%2CMultistreamSelect%2Cseq%5Bstring%5D%2CLPProtocol%2CMatcher">multistream: proc addHandler(m: MultistreamSelect; codecs: seq[string]; protocol: LPProtocol;
           matcher: Matcher = nil)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multistream: proc addHandler[E](m: MultistreamSelect; codec: string; handler: LPProtoHandler |
    proc (conn: Connection; proto: string): InternalRaisesFuture[void, E];
              matcher: Matcher = nil)" href="libp2p/multistream.html#addHandler%2CMultistreamSelect%2Cstring%2C%2CMatcher">multistream: proc addHandler[E](m: MultistreamSelect; codec: string; handler: LPProtoHandler |
    proc (conn: Connection; proto: string): InternalRaisesFuture[void, E];
              matcher: Matcher = nil)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multistream: proc addHandler(m: MultistreamSelect; codec: string; protocol: LPProtocol;
           matcher: Matcher = nil)" href="libp2p/multistream.html#addHandler%2CMultistreamSelect%2Cstring%2CLPProtocol%2CMatcher">multistream: proc addHandler(m: MultistreamSelect; codec: string; protocol: LPProtocol;
           matcher: Matcher = nil)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc addHandler[T](peerBook: PeerBook[T]; handler: PeerBookChangeHandler)" href="libp2p/peerstore.html#addHandler%2CPeerBook%5BT%5D%2CPeerBookChangeHandler">peerstore: proc addHandler[T](peerBook: PeerBook[T]; handler: PeerBookChangeHandler)</a></li>
          </ul></dd>
<dt><a name="addObservation" href="#addObservation"><span>addObservation:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="observedaddrmanager: proc addObservation(self: ObservedAddrManager; observedAddr: MultiAddress): bool" href="libp2p/observedaddrmanager.html#addObservation%2CObservedAddrManager%2CMultiAddress">observedaddrmanager: proc addObservation(self: ObservedAddrManager; observedAddr: MultiAddress): bool</a></li>
          </ul></dd>
<dt><a name="addObserver" href="#addObserver"><span>addObserver:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc addObserver(p: PubSub; observer: PubSubObserver)" href="libp2p/protocols/pubsub/pubsub.html#addObserver%2CPubSub%2CPubSubObserver">pubsub: proc addObserver(p: PubSub; observer: PubSubObserver)</a></li>
          </ul></dd>
<dt><a name="addPeer" href="#addPeer"><span>addPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peertable: proc addPeer(table: var PeerTable; topic: string; peer: PubSubPeer): bool" href="libp2p/protocols/pubsub/peertable.html#addPeer%2CPeerTable%2Cstring%2CPubSubPeer">peertable: proc addPeer(table: var PeerTable; topic: string; peer: PubSubPeer): bool</a></li>
          </ul></dd>
<dt><a name="addPeerEventHandler" href="#addPeerEventHandler"><span>addPeerEventHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc addPeerEventHandler(c: ConnManager; handler: PeerEventHandler;
                    kind: PeerEventKind)" href="libp2p/connmanager.html#addPeerEventHandler%2CConnManager%2CPeerEventHandler%2CPeerEventKind">connmanager: proc addPeerEventHandler(c: ConnManager; handler: PeerEventHandler;
                    kind: PeerEventKind)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc addPeerEventHandler(s: Switch; handler: PeerEventHandler; kind: PeerEventKind)" href="libp2p/switch.html#addPeerEventHandler%2CSwitch%2CPeerEventHandler%2CPeerEventKind">switch: proc addPeerEventHandler(s: Switch; handler: PeerEventHandler; kind: PeerEventKind)</a></li>
          </ul></dd>
<dt><a name="addPossiblePeerToQuery" href="#addPossiblePeerToQuery"><span>addPossiblePeerToQuery:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="preamblestore: proc addPossiblePeerToQuery(ps: var PreambleStore; msgId: MessageId; peer: PubSubPeer)" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#addPossiblePeerToQuery%2CPreambleStore%2CMessageId%2CPubSubPeer">preamblestore: proc addPossiblePeerToQuery(ps: var PreambleStore; msgId: MessageId; peer: PubSubPeer)</a></li>
          </ul></dd>
<dt><a name="addProvider" href="#addProvider"><span>addProvider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: MessageType.addProvider" href="libp2p/protocols/kademlia/protobuf.html#addProvider">protobuf: MessageType.addProvider</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc addProvider(kad: KadDHT; cid: Cid): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/kademlia/provider.html#addProvider%2CKadDHT%2CCid">provider: proc addProvider(kad: KadDHT; cid: Cid): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="AddressBook" href="#AddressBook"><span>AddressBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type AddressBook" href="libp2p/peerstore.html#AddressBook">peerstore: type AddressBook</a></li>
          </ul></dd>
<dt><a name="AddressInfo" href="#AddressInfo"><span>AddressInfo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routing_record: object AddressInfo" href="libp2p/routing_record.html#AddressInfo">routing_record: object AddressInfo</a></li>
          </ul></dd>
<dt><a name="AddressLimit" href="#AddressLimit"><span>AddressLimit:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const AddressLimit" href="libp2p/protocols/connectivity/autonat/types.html#AddressLimit">types: const AddressLimit</a></li>
          </ul></dd>
<dt><a name="AddressMapper" href="#AddressMapper"><span>AddressMapper:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: type AddressMapper" href="libp2p/peerinfo.html#AddressMapper">peerinfo: type AddressMapper</a></li>
          </ul></dd>
<dt><a name="AddrIdx" href="#AddrIdx"><span>AddrIdx:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type AddrIdx" href="libp2p/protocols/connectivity/autonatv2/types.html#AddrIdx">types: type AddrIdx</a></li>
          </ul></dd>
<dt><a name="addrs" href="#addrs"><span>addrs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: proc addrs(p: PeerInfo): seq[MultiAddress]" href="libp2p/peerinfo.html#addrs%2CPeerInfo">peerinfo: proc addrs(p: PeerInfo): seq[MultiAddress]</a></li>
          </ul></dd>
<dt><a name="addSeen" href="#addSeen"><span>addSeen:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: proc addSeen(f: FloodSub; saltedId: SaltedId): bool" href="libp2p/protocols/pubsub/floodsub.html#addSeen%2CFloodSub%2CSaltedId">floodsub: proc addSeen(f: FloodSub; saltedId: SaltedId): bool</a></li>
          </ul></dd>
<dt><a name="addTransport" href="#addTransport"><span>addTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: method addTransport(self: Dial; transport: Transport)" href="libp2p/dial.html#addTransport.e%2CDial%2CTransport">dial: method addTransport(self: Dial; transport: Transport)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method addTransport(self: Dialer; t: Transport)" href="libp2p/dialer.html#addTransport.e%2CDialer%2CTransport">dialer: method addTransport(self: Dialer; t: Transport)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method addTransport(s: Switch; t: Transport)" href="libp2p/switch.html#addTransport.e%2CSwitch%2CTransport">switch: method addTransport(s: Switch; t: Transport)</a></li>
          </ul></dd>
<dt><a name="addValidator" href="#addValidator"><span>addValidator:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: method addValidator(p: PubSub; topic: varargs[string]; hook: ValidatorHandler)" href="libp2p/protocols/pubsub/pubsub.html#addValidator.e%2CPubSub%2Cvarargs%5Bstring%5D%2CValidatorHandler">pubsub: method addValidator(p: PubSub; topic: varargs[string]; hook: ValidatorHandler)</a></li>
          </ul></dd>
<dt><a name="advertise" href="#advertise"><span>advertise:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc advertise[E](rdv: GenericRendezVous[E]; ns: string; ttl: Duration;
             peers: seq[PeerId]; sprBuff: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, AdvertiseError)]" href="libp2p/protocols/rendezvous/rendezvous.html#advertise%2CGenericRendezVous%5BE%5D%2Cstring%2CDuration%2Cseq%5BPeerId%5D%2Cseq%5Bbyte%5D">rendezvous: proc advertise[E](rdv: GenericRendezVous[E]; ns: string; ttl: Duration;
             peers: seq[PeerId]; sprBuff: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, AdvertiseError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: proc advertise[E](rdv: GenericRendezVous[E]; ns: string; customPeerRecord: E;
             ttl: Duration; peers: seq[PeerId]): InternalRaisesFuture[void,
    (CancelledError, AdvertiseError)]" href="libp2p/protocols/rendezvous/rendezvous.html#advertise%2CGenericRendezVous%5BE%5D%2Cstring%2CE%2CDuration%2Cseq%5BPeerId%5D">rendezvous: proc advertise[E](rdv: GenericRendezVous[E]; ns: string; customPeerRecord: E;
             ttl: Duration; peers: seq[PeerId]): InternalRaisesFuture[void,
    (CancelledError, AdvertiseError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: method advertise(rdv: RendezVous; ns: string; ttl: Opt[Duration] = Opt.none(Duration)): InternalRaisesFuture[
    void, (CancelledError, AdvertiseError)]" href="libp2p/protocols/rendezvous/rendezvous.html#advertise.e%2CRendezVous%2Cstring%2COpt%5BDuration%5D">rendezvous: method advertise(rdv: RendezVous; ns: string; ttl: Opt[Duration] = Opt.none(Duration)): InternalRaisesFuture[
    void, (CancelledError, AdvertiseError)]</a></li>
          </ul></dd>
<dt><a name="AdvertiseError" href="#AdvertiseError"><span>AdvertiseError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: object AdvertiseError" href="libp2p/protocols/rendezvous/rendezvous.html#AdvertiseError">rendezvous: object AdvertiseError</a></li>
          </ul></dd>
<dt><a name="AgentBook" href="#AgentBook"><span>AgentBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type AgentBook" href="libp2p/peerstore.html#AgentBook">peerstore: type AgentBook</a></li>
          </ul></dd>
<dt><a name="AgentVersion" href="#AgentVersion"><span>AgentVersion:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: const AgentVersion" href="libp2p/protocols/identify.html#AgentVersion">identify: const AgentVersion</a></li>
          </ul></dd>
<dt><a name="all" href="#all"><span>all:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc all[T](o: OffsettedSeq[T]; pred: proc (x: T): bool): bool" href="libp2p/utils/offsettedseq.html#all%2COffsettedSeq%5BT%5D%2Cproc%28T%29">offsettedseq: proc all[T](o: OffsettedSeq[T]; pred: proc (x: T): bool): bool</a></li>
          </ul></dd>
<dt><a name="AllFuturesFailedError" href="#AllFuturesFailedError"><span>AllFuturesFailedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="future: object AllFuturesFailedError" href="libp2p/utils/future.html#AllFuturesFailedError">future: object AllFuturesFailedError</a></li>
          </ul></dd>
<dt><a name="AlreadyExpectingConnectionError" href="#AlreadyExpectingConnectionError"><span>AlreadyExpectingConnectionError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: object AlreadyExpectingConnectionError" href="libp2p/connmanager.html#AlreadyExpectingConnectionError">connmanager: object AlreadyExpectingConnectionError</a></li>
          </ul></dd>
<dt><a name="And" href="#And"><span>And:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MaPatternOp.And" href="libp2p/multiaddress.html#And">multiaddress: MaPatternOp.And</a></li>
          </ul></dd>
<dt><a name="any" href="#any"><span>any:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc any[T](o: OffsettedSeq[T]; pred: proc (x: T): bool): bool" href="libp2p/utils/offsettedseq.html#any%2COffsettedSeq%5BT%5D%2Cproc%28T%29">offsettedseq: proc any[T](o: OffsettedSeq[T]; pred: proc (x: T): bool): bool</a></li>
          </ul></dd>
<dt><a name="anyCompleted" href="#anyCompleted"><span>anyCompleted:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="future: proc anyCompleted[T](futs: seq[T]): InternalRaisesFuture[T,
    (AllFuturesFailedError, CancelledError)]" href="libp2p/utils/future.html#anyCompleted%2Cseq%5BT%5D">future: proc anyCompleted[T](futs: seq[T]): InternalRaisesFuture[T,
    (AllFuturesFailedError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="append" href="#append"><span>append:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc append(m1: var MultiAddress; m2: MultiAddress): MaResult[void]" href="libp2p/multiaddress.html#append%2CMultiAddress%2CMultiAddress">multiaddress: proc append(m1: var MultiAddress; m2: MultiAddress): MaResult[void]</a></li>
          </ul></dd>
<dt><a name="apply" href="#apply"><span>apply:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc apply[T](o: OffsettedSeq[T]; op: proc (x: T))" href="libp2p/utils/offsettedseq.html#apply%2COffsettedSeq%5BT%5D%2Cproc%28T%29">offsettedseq: proc apply[T](o: OffsettedSeq[T]; op: proc (x: T))</a></li>
          <li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc apply[T](o: OffsettedSeq[T]; op: proc (x: T): T)" href="libp2p/utils/offsettedseq.html#apply%2COffsettedSeq%5BT%5D%2Cproc%28T%29_2">offsettedseq: proc apply[T](o: OffsettedSeq[T]; op: proc (x: T): T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc apply[T](o: OffsettedSeq[T]; op: proc (x: var T))" href="libp2p/utils/offsettedseq.html#apply%2COffsettedSeq%5BT%5D%2Cproc%28T%29_3">offsettedseq: proc apply[T](o: OffsettedSeq[T]; op: proc (x: var T))</a></li>
          </ul></dd>
<dt><a name="areAddrsConsistent" href="#areAddrsConsistent"><span>areAddrsConsistent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc areAddrsConsistent(a, b: MultiAddress): bool" href="libp2p/multiaddress.html#areAddrsConsistent%2CMultiAddress%2CMultiAddress">multiaddress: proc areAddrsConsistent(a, b: MultiAddress): bool</a></li>
          </ul></dd>
<dt><a name="asAutonatV2Response" href="#asAutonatV2Response"><span>asAutonatV2Response:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc asAutonatV2Response(self: DialResponse; testAddrs: seq[MultiAddress]): AutonatV2Response" href="libp2p/protocols/connectivity/autonatv2/utils.html#asAutonatV2Response%2CDialResponse%2Cseq%5BMultiAddress%5D">utils: proc asAutonatV2Response(self: DialResponse; testAddrs: seq[MultiAddress]): AutonatV2Response</a></li>
          </ul></dd>
<dt><a name="Asn1Buffer" href="#Asn1Buffer"><span>Asn1Buffer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: object Asn1Buffer" href="libp2p/crypto/minasn1.html#Asn1Buffer">minasn1: object Asn1Buffer</a></li>
          </ul></dd>
<dt><a name="Asn1Class" href="#Asn1Class"><span>Asn1Class:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: enum Asn1Class" href="libp2p/crypto/minasn1.html#Asn1Class">minasn1: enum Asn1Class</a></li>
          </ul></dd>
<dt><a name="Asn1Composite" href="#Asn1Composite"><span>Asn1Composite:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: object Asn1Composite" href="libp2p/crypto/minasn1.html#Asn1Composite">minasn1: object Asn1Composite</a></li>
          </ul></dd>
<dt><a name="asn1EncodeBitString" href="#asn1EncodeBitString"><span>asn1EncodeBitString:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeBitString(dest: var openArray[byte]; value: openArray[byte]; bits = 0): int" href="libp2p/crypto/minasn1.html#asn1EncodeBitString%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D%2Cint">minasn1: proc asn1EncodeBitString(dest: var openArray[byte]; value: openArray[byte]; bits = 0): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeBoolean" href="#asn1EncodeBoolean"><span>asn1EncodeBoolean:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeBoolean(dest: var openArray[byte]; value: bool): int" href="libp2p/crypto/minasn1.html#asn1EncodeBoolean%2CopenArray%5Bbyte%5D%2Cbool">minasn1: proc asn1EncodeBoolean(dest: var openArray[byte]; value: bool): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeComposite" href="#asn1EncodeComposite"><span>asn1EncodeComposite:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeComposite(dest: var openArray[byte]; value: Asn1Composite): int" href="libp2p/crypto/minasn1.html#asn1EncodeComposite%2CopenArray%5Bbyte%5D%2CAsn1Composite">minasn1: proc asn1EncodeComposite(dest: var openArray[byte]; value: Asn1Composite): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeContextTag" href="#asn1EncodeContextTag"><span>asn1EncodeContextTag:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeContextTag(dest: var openArray[byte]; value: openArray[byte]; tag: int): int" href="libp2p/crypto/minasn1.html#asn1EncodeContextTag%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D%2Cint">minasn1: proc asn1EncodeContextTag(dest: var openArray[byte]; value: openArray[byte]; tag: int): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeInteger" href="#asn1EncodeInteger"><span>asn1EncodeInteger:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeInteger(dest: var openArray[byte]; value: openArray[byte]): int" href="libp2p/crypto/minasn1.html#asn1EncodeInteger%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D">minasn1: proc asn1EncodeInteger(dest: var openArray[byte]; value: openArray[byte]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeInteger[T: SomeUnsignedInt](dest: var openArray[byte]; value: T): int" href="libp2p/crypto/minasn1.html#asn1EncodeInteger%2CopenArray%5Bbyte%5D%2CT">minasn1: proc asn1EncodeInteger[T: SomeUnsignedInt](dest: var openArray[byte]; value: T): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeLength" href="#asn1EncodeLength"><span>asn1EncodeLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeLength(dest: var openArray[byte]; length: uint64): int" href="libp2p/crypto/minasn1.html#asn1EncodeLength%2CopenArray%5Bbyte%5D%2Cuint64">minasn1: proc asn1EncodeLength(dest: var openArray[byte]; length: uint64): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeNull" href="#asn1EncodeNull"><span>asn1EncodeNull:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeNull(dest: var openArray[byte]): int" href="libp2p/crypto/minasn1.html#asn1EncodeNull%2CopenArray%5Bbyte%5D">minasn1: proc asn1EncodeNull(dest: var openArray[byte]): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeOctetString" href="#asn1EncodeOctetString"><span>asn1EncodeOctetString:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeOctetString(dest: var openArray[byte]; value: openArray[byte]): int" href="libp2p/crypto/minasn1.html#asn1EncodeOctetString%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D">minasn1: proc asn1EncodeOctetString(dest: var openArray[byte]; value: openArray[byte]): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeOid" href="#asn1EncodeOid"><span>asn1EncodeOid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeOid(dest: var openArray[byte]; value: openArray[byte]): int" href="libp2p/crypto/minasn1.html#asn1EncodeOid%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D">minasn1: proc asn1EncodeOid(dest: var openArray[byte]; value: openArray[byte]): int</a></li>
          </ul></dd>
<dt><a name="asn1EncodeSequence" href="#asn1EncodeSequence"><span>asn1EncodeSequence:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc asn1EncodeSequence(dest: var openArray[byte]; value: openArray[byte]): int" href="libp2p/crypto/minasn1.html#asn1EncodeSequence%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D">minasn1: proc asn1EncodeSequence(dest: var openArray[byte]; value: openArray[byte]): int</a></li>
          </ul></dd>
<dt><a name="Asn1Error" href="#Asn1Error"><span>Asn1Error:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: enum Asn1Error" href="libp2p/crypto/minasn1.html#Asn1Error">minasn1: enum Asn1Error</a></li>
          </ul></dd>
<dt><a name="Asn1False" href="#Asn1False"><span>Asn1False:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1False" href="libp2p/crypto/minasn1.html#Asn1False">minasn1: const Asn1False</a></li>
          </ul></dd>
<dt><a name="Asn1Field" href="#Asn1Field"><span>Asn1Field:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: object Asn1Field" href="libp2p/crypto/minasn1.html#Asn1Field">minasn1: object Asn1Field</a></li>
          </ul></dd>
<dt><a name="Asn1Null" href="#Asn1Null"><span>Asn1Null:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1Null" href="libp2p/crypto/minasn1.html#Asn1Null">minasn1: const Asn1Null</a></li>
          </ul></dd>
<dt><a name="Asn1OidEcPublicKey" href="#Asn1OidEcPublicKey"><span>Asn1OidEcPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1OidEcPublicKey" href="libp2p/crypto/minasn1.html#Asn1OidEcPublicKey">minasn1: const Asn1OidEcPublicKey</a></li>
          </ul></dd>
<dt><a name="Asn1OidRsaEncryption" href="#Asn1OidRsaEncryption"><span>Asn1OidRsaEncryption:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1OidRsaEncryption" href="libp2p/crypto/minasn1.html#Asn1OidRsaEncryption">minasn1: const Asn1OidRsaEncryption</a></li>
          </ul></dd>
<dt><a name="Asn1OidSecp256k1" href="#Asn1OidSecp256k1"><span>Asn1OidSecp256k1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1OidSecp256k1" href="libp2p/crypto/minasn1.html#Asn1OidSecp256k1">minasn1: const Asn1OidSecp256k1</a></li>
          </ul></dd>
<dt><a name="Asn1OidSecp256r1" href="#Asn1OidSecp256r1"><span>Asn1OidSecp256r1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1OidSecp256r1" href="libp2p/crypto/minasn1.html#Asn1OidSecp256r1">minasn1: const Asn1OidSecp256r1</a></li>
          </ul></dd>
<dt><a name="Asn1OidSecp384r1" href="#Asn1OidSecp384r1"><span>Asn1OidSecp384r1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1OidSecp384r1" href="libp2p/crypto/minasn1.html#Asn1OidSecp384r1">minasn1: const Asn1OidSecp384r1</a></li>
          </ul></dd>
<dt><a name="Asn1OidSecp521r1" href="#Asn1OidSecp521r1"><span>Asn1OidSecp521r1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1OidSecp521r1" href="libp2p/crypto/minasn1.html#Asn1OidSecp521r1">minasn1: const Asn1OidSecp521r1</a></li>
          </ul></dd>
<dt><a name="Asn1Result" href="#Asn1Result"><span>Asn1Result:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: type Asn1Result" href="libp2p/crypto/minasn1.html#Asn1Result">minasn1: type Asn1Result</a></li>
          </ul></dd>
<dt><a name="Asn1Tag" href="#Asn1Tag"><span>Asn1Tag:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: enum Asn1Tag" href="libp2p/crypto/minasn1.html#Asn1Tag">minasn1: enum Asn1Tag</a></li>
          </ul></dd>
<dt><a name="Asn1True" href="#Asn1True"><span>Asn1True:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: const Asn1True" href="libp2p/crypto/minasn1.html#Asn1True">minasn1: const Asn1True</a></li>
          </ul></dd>
<dt><a name="asNetworkReachability" href="#asNetworkReachability"><span>asNetworkReachability:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc asNetworkReachability(self: DialResponse): NetworkReachability" href="libp2p/protocols/connectivity/autonatv2/utils.html#asNetworkReachability%2CDialResponse">utils: proc asNetworkReachability(self: DialResponse): NetworkReachability</a></li>
          </ul></dd>
<dt><a name="atEof" href="#atEof"><span>atEof:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bufferstream: method atEof(s: BufferStream): bool" href="libp2p/stream/bufferstream.html#atEof.e%2CBufferStream">bufferstream: method atEof(s: BufferStream): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method atEof(s: ChronosStream): bool" href="libp2p/stream/chronosstream.html#atEof.e%2CChronosStream">chronosstream: method atEof(s: ChronosStream): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method atEof(s: LPStream): bool" href="libp2p/stream/lpstream.html#atEof.e%2CLPStream">lpstream: method atEof(s: LPStream): bool</a></li>
          </ul></dd>
<dt><a name="Authorization" href="#Authorization"><span>Authorization:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: type Authorization" href="libp2p/autotls/acme/api.html#Authorization">api: type Authorization</a></li>
          </ul></dd>
<dt><a name="Autonat" href="#Autonat"><span>Autonat:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="server: type Autonat" href="libp2p/protocols/connectivity/autonat/server.html#Autonat">server: type Autonat</a></li>
          </ul></dd>
<dt><a name="AutonatCodec" href="#AutonatCodec"><span>AutonatCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const AutonatCodec" href="libp2p/protocols/connectivity/autonat/types.html#AutonatCodec">types: const AutonatCodec</a></li>
          </ul></dd>
<dt><a name="AutonatDial" href="#AutonatDial"><span>AutonatDial:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatDial" href="libp2p/protocols/connectivity/autonat/types.html#AutonatDial">types: object AutonatDial</a></li>
          </ul></dd>
<dt><a name="AutonatDialResponse" href="#AutonatDialResponse"><span>AutonatDialResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatDialResponse" href="libp2p/protocols/connectivity/autonat/types.html#AutonatDialResponse">types: object AutonatDialResponse</a></li>
          </ul></dd>
<dt><a name="AutonatError" href="#AutonatError"><span>AutonatError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatError" href="libp2p/protocols/connectivity/autonat/types.html#AutonatError">types: object AutonatError</a></li>
          </ul></dd>
<dt><a name="AutonatMsg" href="#AutonatMsg"><span>AutonatMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatMsg" href="libp2p/protocols/connectivity/autonat/types.html#AutonatMsg">types: object AutonatMsg</a></li>
          </ul></dd>
<dt><a name="AutonatPeerInfo" href="#AutonatPeerInfo"><span>AutonatPeerInfo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatPeerInfo" href="libp2p/protocols/connectivity/autonat/types.html#AutonatPeerInfo">types: object AutonatPeerInfo</a></li>
          </ul></dd>
<dt><a name="AutonatUnreachableError" href="#AutonatUnreachableError"><span>AutonatUnreachableError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatUnreachableError" href="libp2p/protocols/connectivity/autonat/types.html#AutonatUnreachableError">types: object AutonatUnreachableError</a></li>
          </ul></dd>
<dt><a name="AutonatV2" href="#AutonatV2"><span>AutonatV2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="server: type AutonatV2" href="libp2p/protocols/connectivity/autonatv2/server.html#AutonatV2">server: type AutonatV2</a></li>
          </ul></dd>
<dt><a name="AutonatV2Client" href="#AutonatV2Client"><span>AutonatV2Client:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type AutonatV2Client" href="libp2p/protocols/connectivity/autonatv2/client.html#AutonatV2Client">client: type AutonatV2Client</a></li>
          </ul></dd>
<dt><a name="AutonatV2Codec" href="#AutonatV2Codec"><span>AutonatV2Codec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: enum AutonatV2Codec" href="libp2p/protocols/connectivity/autonatv2/types.html#AutonatV2Codec">types: enum AutonatV2Codec</a></li>
          </ul></dd>
<dt><a name="AutonatV2Config" href="#AutonatV2Config"><span>AutonatV2Config:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="server: object AutonatV2Config" href="libp2p/protocols/connectivity/autonatv2/server.html#AutonatV2Config">server: object AutonatV2Config</a></li>
          </ul></dd>
<dt><a name="AutonatV2Error" href="#AutonatV2Error"><span>AutonatV2Error:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatV2Error" href="libp2p/protocols/connectivity/autonatv2/types.html#AutonatV2Error">types: object AutonatV2Error</a></li>
          </ul></dd>
<dt><a name="AutonatV2Msg" href="#AutonatV2Msg"><span>AutonatV2Msg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatV2Msg" href="libp2p/protocols/connectivity/autonatv2/types.html#AutonatV2Msg">types: object AutonatV2Msg</a></li>
          </ul></dd>
<dt><a name="AutonatV2MsgLpSize" href="#AutonatV2MsgLpSize"><span>AutonatV2MsgLpSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const AutonatV2MsgLpSize" href="libp2p/protocols/connectivity/autonatv2/types.html#AutonatV2MsgLpSize">types: const AutonatV2MsgLpSize</a></li>
          </ul></dd>
<dt><a name="AutonatV2Response" href="#AutonatV2Response"><span>AutonatV2Response:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object AutonatV2Response" href="libp2p/protocols/connectivity/autonatv2/types.html#AutonatV2Response">types: object AutonatV2Response</a></li>
          </ul></dd>
<dt><a name="AutonatV2Service" href="#AutonatV2Service"><span>AutonatV2Service:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: type AutonatV2Service" href="libp2p/protocols/connectivity/autonatv2/service.html#AutonatV2Service">service: type AutonatV2Service</a></li>
          </ul></dd>
<dt><a name="AutonatV2ServiceConfig" href="#AutonatV2ServiceConfig"><span>AutonatV2ServiceConfig:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: object AutonatV2ServiceConfig" href="libp2p/protocols/connectivity/autonatv2/service.html#AutonatV2ServiceConfig">service: object AutonatV2ServiceConfig</a></li>
          </ul></dd>
<dt><a name="AutoTLSBroker" href="#AutoTLSBroker"><span>AutoTLSBroker:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: const AutoTLSBroker" href="libp2p/autotls/service.html#AutoTLSBroker">service: const AutoTLSBroker</a></li>
          </ul></dd>
<dt><a name="AutotlsCert" href="#AutotlsCert"><span>AutotlsCert:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: type AutotlsCert" href="libp2p/autotls/service.html#AutotlsCert">service: type AutotlsCert</a></li>
          </ul></dd>
<dt><a name="AutotlsConfig" href="#AutotlsConfig"><span>AutotlsConfig:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: type AutotlsConfig" href="libp2p/autotls/service.html#AutotlsConfig">service: type AutotlsConfig</a></li>
          </ul></dd>
<dt><a name="AutoTLSDNSServer" href="#AutoTLSDNSServer"><span>AutoTLSDNSServer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: const AutoTLSDNSServer" href="libp2p/autotls/service.html#AutoTLSDNSServer">service: const AutoTLSDNSServer</a></li>
          </ul></dd>
<dt><a name="AutoTLSError" href="#AutoTLSError"><span>AutoTLSError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: object AutoTLSError" href="libp2p/autotls/utils.html#AutoTLSError">utils: object AutoTLSError</a></li>
          </ul></dd>
<dt><a name="AutotlsService" href="#AutotlsService"><span>AutotlsService:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: type AutotlsService" href="libp2p/autotls/service.html#AutotlsService">service: type AutotlsService</a></li>
          </ul></dd>
<dt><a name="BackoffSlackTime" href="#BackoffSlackTime"><span>BackoffSlackTime:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const BackoffSlackTime" href="libp2p/protocols/pubsub/gossipsub/types.html#BackoffSlackTime">types: const BackoffSlackTime</a></li>
          </ul></dd>
<dt><a name="BackoffTable" href="#BackoffTable"><span>BackoffTable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type BackoffTable" href="libp2p/protocols/pubsub/gossipsub/types.html#BackoffTable">types: type BackoffTable</a></li>
          </ul></dd>
<dt><a name="BadRequest" href="#BadRequest"><span>BadRequest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: ResponseStatus.BadRequest" href="libp2p/protocols/connectivity/autonat/types.html#BadRequest">types: ResponseStatus.BadRequest</a></li>
          </ul></dd>
<dt><a name="BandwidthTracking" href="#BandwidthTracking"><span>BandwidthTracking:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bandwidth: type BandwidthTracking" href="libp2p/protocols/pubsub/bandwidth.html#BandwidthTracking">bandwidth: type BandwidthTracking</a></li>
          </ul></dd>
<dt><a name="base58" href="#base58"><span>base58:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc base58(cid: Cid): string" href="libp2p/cid.html#base58%2CCid">cid: proc base58(cid: Cid): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc base58(value: MultiHash): string" href="libp2p/multihash.html#base58%2CMultiHash">multihash: proc base58(value: MultiHash): string</a></li>
          </ul></dd>
<dt><a name="BasePrecomp" href="#BasePrecomp"><span>BasePrecomp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: const BasePrecomp" href="libp2p/crypto/ed25519/constants.html#BasePrecomp">constants: const BasePrecomp</a></li>
          </ul></dd>
<dt><a name="BearerToken" href="#BearerToken"><span>BearerToken:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object BearerToken" href="libp2p/peeridauth/client.html#BearerToken">client: object BearerToken</a></li>
          </ul></dd>
<dt><a name="bioToSeq" href="#bioToSeq"><span>bioToSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc bioToSeq(bio: ptr BIO): Result[seq[byte], CertError]" href="libp2p/transports/tls/certificate_ffi.html#bioToSeq%2Cptr.struct_bio_st">certificate_ffi: proc bioToSeq(bio: ptr BIO): Result[seq[byte], CertError]</a></li>
          </ul></dd>
<dt><a name="BiPrecomp" href="#BiPrecomp"><span>BiPrecomp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: const BiPrecomp" href="libp2p/crypto/ed25519/constants.html#BiPrecomp">constants: const BiPrecomp</a></li>
          </ul></dd>
<dt><a name="bootstrap" href="#bootstrap"><span>bootstrap:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="kademlia: proc bootstrap(kad: KadDHT): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/kademlia.html#bootstrap%2CKadDHT">kademlia: proc bootstrap(kad: KadDHT): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="bootstrapNode" href="#bootstrapNode"><span>bootstrapNode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="kademlia: proc bootstrapNode(kad: KadDHT; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/kademlia.html#bootstrapNode%2CKadDHT%2CPeerId%2Cseq%5BMultiAddress%5D">kademlia: proc bootstrapNode(kad: KadDHT; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="bridge" href="#bridge"><span>bridge:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc bridge(connSrc: Connection; connDst: Connection): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/connectivity/relay/utils.html#bridge%2CConnection%2CConnection">utils: proc bridge(connSrc: Connection; connDst: Connection): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="bridgedConnections" href="#bridgedConnections"><span>bridgedConnections:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bridgestream: proc bridgedConnections(closeTogether: bool = true; dirA = Direction.In;
                   dirB = Direction.In): (BridgeStream, BridgeStream)" href="libp2p/stream/bridgestream.html#bridgedConnections%2Cbool">bridgestream: proc bridgedConnections(closeTogether: bool = true; dirA = Direction.In;
                   dirB = Direction.In): (BridgeStream, BridgeStream)</a></li>
          </ul></dd>
<dt><a name="BridgeStream" href="#BridgeStream"><span>BridgeStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bridgestream: type BridgeStream" href="libp2p/stream/bridgestream.html#BridgeStream">bridgestream: type BridgeStream</a></li>
          </ul></dd>
<dt><a name="broadcast" href="#broadcast"><span>broadcast:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc broadcast(p: PubSub; sendPeers: auto; msg: RPCMsg; isHighPriority: bool;
          useCustomConn: bool = false)" href="libp2p/protocols/pubsub/pubsub.html#broadcast%2CPubSub%2Cauto%2CRPCMsg%2Cbool%2Cbool">pubsub: proc broadcast(p: PubSub; sendPeers: auto; msg: RPCMsg; isHighPriority: bool;
          useCustomConn: bool = false)</a></li>
          </ul></dd>
<dt><a name="Bucket" href="#Bucket"><span>Bucket:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object Bucket" href="libp2p/protocols/kademlia/types.html#Bucket">types: object Bucket</a></li>
          </ul></dd>
<dt><a name="bucketIndex" href="#bucketIndex"><span>bucketIndex:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routingtable: proc bucketIndex(selfId, key: Key; hasher: Opt[XorDHasher]): int" href="libp2p/protocols/kademlia/routingtable.html#bucketIndex%2CKey%2CKey%2COpt%5BXorDHasher%5D">routingtable: proc bucketIndex(selfId, key: Key; hasher: Opt[XorDHasher]): int</a></li>
          </ul></dd>
<dt><a name="BufferStream" href="#BufferStream"><span>BufferStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bufferstream: type BufferStream" href="libp2p/stream/bufferstream.html#BufferStream">bufferstream: type BufferStream</a></li>
          </ul></dd>
<dt><a name="BufferStreamTrackerName" href="#BufferStreamTrackerName"><span>BufferStreamTrackerName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bufferstream: const BufferStreamTrackerName" href="libp2p/stream/bufferstream.html#BufferStreamTrackerName">bufferstream: const BufferStreamTrackerName</a></li>
          </ul></dd>
<dt><a name="build" href="#build"><span>build:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc build(b: SwitchBuilder): Switch" href="libp2p/builders.html#build%2CSwitchBuilder">builders: proc build(b: SwitchBuilder): Switch</a></li>
          </ul></dd>
<dt><a name="byScore" href="#byScore"><span>byScore:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc byScore(x, y: PubSubPeer): int" href="libp2p/protocols/pubsub/gossipsub/scoring.html#byScore%2CPubSubPeer%2CPubSubPeer">scoring: proc byScore(x, y: PubSubPeer): int</a></li>
          </ul></dd>
<dt><a name="bytes" href="#bytes"><span>bytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc bytes(value: MultiAddress): seq[byte]" href="libp2p/multiaddress.html#bytes%2CMultiAddress">multiaddress: proc bytes(value: MultiAddress): seq[byte]</a></li>
          </ul></dd>
<dt><a name="byteSize" href="#byteSize"><span>byteSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: proc byteSize(msg: Message): int" href="libp2p/protocols/pubsub/rpc/messages.html#byteSize%2CMessage">messages: proc byteSize(msg: Message): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc byteSize(rpc: RPCMsg): int" href="libp2p/protocols/pubsub/rpc/messages.html#byteSize%2CRPCMsg">messages: proc byteSize(rpc: RPCMsg): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc byteSize(ihaves: seq[ControlIHave]): int" href="libp2p/protocols/pubsub/rpc/messages.html#byteSize%2Cseq%5BControlIHave%5D">messages: proc byteSize(ihaves: seq[ControlIHave]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc byteSize(imreceivings: seq[ControlIMReceiving]): int" href="libp2p/protocols/pubsub/rpc/messages.html#byteSize%2Cseq%5BControlIMReceiving%5D">messages: proc byteSize(imreceivings: seq[ControlIMReceiving]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc byteSize(iwants: seq[ControlIWant]): int" href="libp2p/protocols/pubsub/rpc/messages.html#byteSize%2Cseq%5BControlIWant%5D">messages: proc byteSize(iwants: seq[ControlIWant]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc byteSize(preambles: seq[ControlPreamble]): int" href="libp2p/protocols/pubsub/rpc/messages.html#byteSize%2Cseq%5BControlPreamble%5D">messages: proc byteSize(preambles: seq[ControlPreamble]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc byteSize(msgs: seq[Message]): int" href="libp2p/protocols/pubsub/rpc/messages.html#byteSize%2Cseq%5BMessage%5D">messages: proc byteSize(msgs: seq[Message]): int</a></li>
          </ul></dd>
<dt><a name="BytesView" href="#BytesView"><span>BytesView:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bytesview: object BytesView" href="libp2p/utils/bytesview.html#BytesView">bytesview: object BytesView</a></li>
          </ul></dd>
<dt><a name="CacheEntry" href="#CacheEntry"><span>CacheEntry:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mcache: object CacheEntry" href="libp2p/protocols/pubsub/mcache.html#CacheEntry">mcache: object CacheEntry</a></li>
          </ul></dd>
<dt><a name="calculateReceiveTimeMs" href="#calculateReceiveTimeMs"><span>calculateReceiveTimeMs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bandwidth: proc calculateReceiveTimeMs(msgLen: int64; dataRate: int64 = InitialRate): int64" href="libp2p/protocols/pubsub/bandwidth.html#calculateReceiveTimeMs%2Cint64%2Cint64">bandwidth: proc calculateReceiveTimeMs(msgLen: int64; dataRate: int64 = InitialRate): int64</a></li>
          </ul></dd>
<dt><a name="canAskIWant" href="#canAskIWant"><span>canAskIWant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc canAskIWant(p: PubSubPeer; msgId: MessageId): bool" href="libp2p/protocols/pubsub/pubsubpeer.html#canAskIWant%2CPubSubPeer%2CMessageId">pubsubpeer: proc canAskIWant(p: PubSubPeer; msgId: MessageId): bool</a></li>
          </ul></dd>
<dt><a name="canConnect" href="#canConnect"><span>canConnect:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ConnectionType.canConnect" href="libp2p/protocols/kademlia/protobuf.html#canConnect">protobuf: ConnectionType.canConnect</a></li>
          </ul></dd>
<dt><a name="CandidatePeers" href="#CandidatePeers"><span>CandidatePeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type CandidatePeers" href="libp2p/protocols/kademlia/types.html#CandidatePeers">types: type CandidatePeers</a></li>
          </ul></dd>
<dt><a name="cannotConnect" href="#cannotConnect"><span>cannotConnect:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ConnectionType.cannotConnect" href="libp2p/protocols/kademlia/protobuf.html#cannotConnect">protobuf: ConnectionType.cannotConnect</a></li>
          </ul></dd>
<dt><a name="capLen" href="#capLen"><span>capLen:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: proc capLen[T](s: var seq[T]; length: Natural)" href="libp2p/utility.html#capLen%2Cseq%5BT%5D%2CNatural">utility: proc capLen[T](s: var seq[T]; length: Natural)</a></li>
          </ul></dd>
<dt><a name="CertError" href="#CertError"><span>CertError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: type CertError" href="libp2p/transports/tls/certificate_ffi.html#CertError">certificate_ffi: type CertError</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_ASN1_ENCODE" href="#CERT_ERROR_ASN1_ENCODE"><span>CERT_ERROR_ASN1_ENCODE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_ASN1_ENCODE" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_ASN1_ENCODE">certificate_ffi: const CERT_ERROR_ASN1_ENCODE</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_ASN1_OCTET" href="#CERT_ERROR_ASN1_OCTET"><span>CERT_ERROR_ASN1_OCTET:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_ASN1_OCTET" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_ASN1_OCTET">certificate_ffi: const CERT_ERROR_ASN1_OCTET</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_ASN1_TIME_GEN" href="#CERT_ERROR_ASN1_TIME_GEN"><span>CERT_ERROR_ASN1_TIME_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_ASN1_TIME_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_ASN1_TIME_GEN">certificate_ffi: const CERT_ERROR_ASN1_TIME_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_BIGNUM_CONV" href="#CERT_ERROR_BIGNUM_CONV"><span>CERT_ERROR_BIGNUM_CONV:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_BIGNUM_CONV" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_BIGNUM_CONV">certificate_ffi: const CERT_ERROR_BIGNUM_CONV</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_BIGNUM_GEN" href="#CERT_ERROR_BIGNUM_GEN"><span>CERT_ERROR_BIGNUM_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_BIGNUM_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_BIGNUM_GEN">certificate_ffi: const CERT_ERROR_BIGNUM_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_BIO_GEN" href="#CERT_ERROR_BIO_GEN"><span>CERT_ERROR_BIO_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_BIO_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_BIO_GEN">certificate_ffi: const CERT_ERROR_BIO_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_BIO_WRITE" href="#CERT_ERROR_BIO_WRITE"><span>CERT_ERROR_BIO_WRITE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_BIO_WRITE" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_BIO_WRITE">certificate_ffi: const CERT_ERROR_BIO_WRITE</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_CERT_GEN" href="#CERT_ERROR_CERT_GEN"><span>CERT_ERROR_CERT_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_CERT_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_CERT_GEN">certificate_ffi: const CERT_ERROR_CERT_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_CN_EMPTY" href="#CERT_ERROR_CN_EMPTY"><span>CERT_ERROR_CN_EMPTY:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_CN_EMPTY" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_CN_EMPTY">certificate_ffi: const CERT_ERROR_CN_EMPTY</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_CN_EMPTY_LABEL" href="#CERT_ERROR_CN_EMPTY_LABEL"><span>CERT_ERROR_CN_EMPTY_LABEL:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_CN_EMPTY_LABEL" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_CN_EMPTY_LABEL">certificate_ffi: const CERT_ERROR_CN_EMPTY_LABEL</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_CN_LABEL_TOO_LONG" href="#CERT_ERROR_CN_LABEL_TOO_LONG"><span>CERT_ERROR_CN_LABEL_TOO_LONG:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_CN_LABEL_TOO_LONG" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_CN_LABEL_TOO_LONG">certificate_ffi: const CERT_ERROR_CN_LABEL_TOO_LONG</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_CN_TOO_LONG" href="#CERT_ERROR_CN_TOO_LONG"><span>CERT_ERROR_CN_TOO_LONG:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_CN_TOO_LONG" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_CN_TOO_LONG">certificate_ffi: const CERT_ERROR_CN_TOO_LONG</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_DECODE_SEQUENCE" href="#CERT_ERROR_DECODE_SEQUENCE"><span>CERT_ERROR_DECODE_SEQUENCE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_DECODE_SEQUENCE" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_DECODE_SEQUENCE">certificate_ffi: const CERT_ERROR_DECODE_SEQUENCE</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_DRBG_CONFIG" href="#CERT_ERROR_DRBG_CONFIG"><span>CERT_ERROR_DRBG_CONFIG:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_DRBG_CONFIG" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_DRBG_CONFIG">certificate_ffi: const CERT_ERROR_DRBG_CONFIG</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_DRBG_INIT" href="#CERT_ERROR_DRBG_INIT"><span>CERT_ERROR_DRBG_INIT:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_DRBG_INIT" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_DRBG_INIT">certificate_ffi: const CERT_ERROR_DRBG_INIT</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_DRBG_SEED" href="#CERT_ERROR_DRBG_SEED"><span>CERT_ERROR_DRBG_SEED:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_DRBG_SEED" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_DRBG_SEED">certificate_ffi: const CERT_ERROR_DRBG_SEED</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_ECKEY_GEN" href="#CERT_ERROR_ECKEY_GEN"><span>CERT_ERROR_ECKEY_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_ECKEY_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_ECKEY_GEN">certificate_ffi: const CERT_ERROR_ECKEY_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_ENCODING" href="#CERT_ERROR_ENCODING"><span>CERT_ERROR_ENCODING:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_ENCODING" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_ENCODING">certificate_ffi: const CERT_ERROR_ENCODING</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_EVP_PKEY_EC_KEY" href="#CERT_ERROR_EVP_PKEY_EC_KEY"><span>CERT_ERROR_EVP_PKEY_EC_KEY:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_EVP_PKEY_EC_KEY" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_EVP_PKEY_EC_KEY">certificate_ffi: const CERT_ERROR_EVP_PKEY_EC_KEY</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_EXTENSION_ADD" href="#CERT_ERROR_EXTENSION_ADD"><span>CERT_ERROR_EXTENSION_ADD:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_EXTENSION_ADD" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_EXTENSION_ADD">certificate_ffi: const CERT_ERROR_EXTENSION_ADD</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_EXTENSION_DATA" href="#CERT_ERROR_EXTENSION_DATA"><span>CERT_ERROR_EXTENSION_DATA:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_EXTENSION_DATA" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_EXTENSION_DATA">certificate_ffi: const CERT_ERROR_EXTENSION_DATA</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_EXTENSION_GEN" href="#CERT_ERROR_EXTENSION_GEN"><span>CERT_ERROR_EXTENSION_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_EXTENSION_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_EXTENSION_GEN">certificate_ffi: const CERT_ERROR_EXTENSION_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_EXTENSION_GET" href="#CERT_ERROR_EXTENSION_GET"><span>CERT_ERROR_EXTENSION_GET:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_EXTENSION_GET" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_EXTENSION_GET">certificate_ffi: const CERT_ERROR_EXTENSION_GET</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_EXTENSION_NOT_FOUND" href="#CERT_ERROR_EXTENSION_NOT_FOUND"><span>CERT_ERROR_EXTENSION_NOT_FOUND:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_EXTENSION_NOT_FOUND" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_EXTENSION_NOT_FOUND">certificate_ffi: const CERT_ERROR_EXTENSION_NOT_FOUND</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_INIT_KEYGEN" href="#CERT_ERROR_INIT_KEYGEN"><span>CERT_ERROR_INIT_KEYGEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_INIT_KEYGEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_INIT_KEYGEN">certificate_ffi: const CERT_ERROR_INIT_KEYGEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_KEY_GEN" href="#CERT_ERROR_KEY_GEN"><span>CERT_ERROR_KEY_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_KEY_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_KEY_GEN">certificate_ffi: const CERT_ERROR_KEY_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_MEMORY" href="#CERT_ERROR_MEMORY"><span>CERT_ERROR_MEMORY:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_MEMORY" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_MEMORY">certificate_ffi: const CERT_ERROR_MEMORY</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_NID" href="#CERT_ERROR_NID"><span>CERT_ERROR_NID:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_NID" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_NID">certificate_ffi: const CERT_ERROR_NID</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_NO_PUBKEY" href="#CERT_ERROR_NO_PUBKEY"><span>CERT_ERROR_NO_PUBKEY:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_NO_PUBKEY" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_NO_PUBKEY">certificate_ffi: const CERT_ERROR_NO_PUBKEY</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_NOT_ENOUGH_SEQ_ELEMS" href="#CERT_ERROR_NOT_ENOUGH_SEQ_ELEMS"><span>CERT_ERROR_NOT_ENOUGH_SEQ_ELEMS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_NOT_ENOUGH_SEQ_ELEMS" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_NOT_ENOUGH_SEQ_ELEMS">certificate_ffi: const CERT_ERROR_NOT_ENOUGH_SEQ_ELEMS</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_NOT_OCTET_STR" href="#CERT_ERROR_NOT_OCTET_STR"><span>CERT_ERROR_NOT_OCTET_STR:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_NOT_OCTET_STR" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_NOT_OCTET_STR">certificate_ffi: const CERT_ERROR_NOT_OCTET_STR</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_NULL_PARAM" href="#CERT_ERROR_NULL_PARAM"><span>CERT_ERROR_NULL_PARAM:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_NULL_PARAM" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_NULL_PARAM">certificate_ffi: const CERT_ERROR_NULL_PARAM</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_PARSE" href="#CERT_ERROR_PARSE"><span>CERT_ERROR_PARSE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_PARSE" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_PARSE">certificate_ffi: const CERT_ERROR_PARSE</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_PUBKEY_DER_CONV" href="#CERT_ERROR_PUBKEY_DER_CONV"><span>CERT_ERROR_PUBKEY_DER_CONV:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_PUBKEY_DER_CONV" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_PUBKEY_DER_CONV">certificate_ffi: const CERT_ERROR_PUBKEY_DER_CONV</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_PUBKEY_DER_LEN" href="#CERT_ERROR_PUBKEY_DER_LEN"><span>CERT_ERROR_PUBKEY_DER_LEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_PUBKEY_DER_LEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_PUBKEY_DER_LEN">certificate_ffi: const CERT_ERROR_PUBKEY_DER_LEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_PUBKEY_GET" href="#CERT_ERROR_PUBKEY_GET"><span>CERT_ERROR_PUBKEY_GET:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_PUBKEY_GET" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_PUBKEY_GET">certificate_ffi: const CERT_ERROR_PUBKEY_GET</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_PUBKEY_SET" href="#CERT_ERROR_PUBKEY_SET"><span>CERT_ERROR_PUBKEY_SET:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_PUBKEY_SET" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_PUBKEY_SET">certificate_ffi: const CERT_ERROR_PUBKEY_SET</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_RAND" href="#CERT_ERROR_RAND"><span>CERT_ERROR_RAND:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_RAND" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_RAND">certificate_ffi: const CERT_ERROR_RAND</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_SERIAL_WRITE" href="#CERT_ERROR_SERIAL_WRITE"><span>CERT_ERROR_SERIAL_WRITE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_SERIAL_WRITE" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_SERIAL_WRITE">certificate_ffi: const CERT_ERROR_SERIAL_WRITE</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_SET_CURVE" href="#CERT_ERROR_SET_CURVE"><span>CERT_ERROR_SET_CURVE:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_SET_CURVE" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_SET_CURVE">certificate_ffi: const CERT_ERROR_SET_CURVE</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_SET_KEY" href="#CERT_ERROR_SET_KEY"><span>CERT_ERROR_SET_KEY:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_SET_KEY" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_SET_KEY">certificate_ffi: const CERT_ERROR_SET_KEY</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_SIGN" href="#CERT_ERROR_SIGN"><span>CERT_ERROR_SIGN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_SIGN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_SIGN">certificate_ffi: const CERT_ERROR_SIGN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_VALIDITY_PERIOD" href="#CERT_ERROR_VALIDITY_PERIOD"><span>CERT_ERROR_VALIDITY_PERIOD:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_VALIDITY_PERIOD" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_VALIDITY_PERIOD">certificate_ffi: const CERT_ERROR_VALIDITY_PERIOD</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_CN" href="#CERT_ERROR_X509_CN"><span>CERT_ERROR_X509_CN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_CN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_CN">certificate_ffi: const CERT_ERROR_X509_CN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_ISSUER" href="#CERT_ERROR_X509_ISSUER"><span>CERT_ERROR_X509_ISSUER:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_ISSUER" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_ISSUER">certificate_ffi: const CERT_ERROR_X509_ISSUER</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_NAME" href="#CERT_ERROR_X509_NAME"><span>CERT_ERROR_X509_NAME:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_NAME" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_NAME">certificate_ffi: const CERT_ERROR_X509_NAME</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_READ" href="#CERT_ERROR_X509_READ"><span>CERT_ERROR_X509_READ:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_READ" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_READ">certificate_ffi: const CERT_ERROR_X509_READ</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_REQ_DER" href="#CERT_ERROR_X509_REQ_DER"><span>CERT_ERROR_X509_REQ_DER:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_REQ_DER" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_REQ_DER">certificate_ffi: const CERT_ERROR_X509_REQ_DER</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_REQ_GEN" href="#CERT_ERROR_X509_REQ_GEN"><span>CERT_ERROR_X509_REQ_GEN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_REQ_GEN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_REQ_GEN">certificate_ffi: const CERT_ERROR_X509_REQ_GEN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_SAN" href="#CERT_ERROR_X509_SAN"><span>CERT_ERROR_X509_SAN:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_SAN" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_SAN">certificate_ffi: const CERT_ERROR_X509_SAN</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_SUBJECT" href="#CERT_ERROR_X509_SUBJECT"><span>CERT_ERROR_X509_SUBJECT:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_SUBJECT" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_SUBJECT">certificate_ffi: const CERT_ERROR_X509_SUBJECT</a></li>
          </ul></dd>
<dt><a name="CERT_ERROR_X509_VER" href="#CERT_ERROR_X509_VER"><span>CERT_ERROR_X509_VER:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const CERT_ERROR_X509_VER" href="libp2p/transports/tls/certificate_ffi.html#CERT_ERROR_X509_VER">certificate_ffi: const CERT_ERROR_X509_VER</a></li>
          </ul></dd>
<dt><a name="CERT_FORMAT_DER" href="#CERT_FORMAT_DER"><span>CERT_FORMAT_DER:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: cert_format_t.CERT_FORMAT_DER" href="libp2p/transports/tls/certificate_ffi.html#CERT_FORMAT_DER">certificate_ffi: cert_format_t.CERT_FORMAT_DER</a></li>
          </ul></dd>
<dt><a name="CERT_FORMAT_PEM" href="#CERT_FORMAT_PEM"><span>CERT_FORMAT_PEM:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: cert_format_t.CERT_FORMAT_PEM" href="libp2p/transports/tls/certificate_ffi.html#CERT_FORMAT_PEM">certificate_ffi: cert_format_t.CERT_FORMAT_PEM</a></li>
          </ul></dd>
<dt><a name="cert_format_t" href="#cert_format_t"><span>cert_format_t:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: enum cert_format_t" href="libp2p/transports/tls/certificate_ffi.html#cert_format_t">certificate_ffi: enum cert_format_t</a></li>
          </ul></dd>
<dt><a name="cert_free_key" href="#cert_free_key"><span>cert_free_key:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_free_key(key: CertificateKey): void" href="libp2p/transports/tls/certificate_ffi.html#cert_free_key%2CCertificateKey">certificate_ffi: proc cert_free_key(key: CertificateKey): void</a></li>
          </ul></dd>
<dt><a name="cert_generate" href="#cert_generate"><span>cert_generate:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_generate(key: CertificateKey; signature: seq[byte]; ident_pubk: seq[byte];
              cn: string; validFrom: cstring; validTo: cstring;
              format: cert_format_t): Result[seq[byte], CertError]" href="libp2p/transports/tls/certificate_ffi.html#cert_generate%2CCertificateKey%2Cseq%5Bbyte%5D%2Cseq%5Bbyte%5D%2Cstring%2Ccstring%2Ccstring%2Ccert_format_t">certificate_ffi: proc cert_generate(key: CertificateKey; signature: seq[byte]; ident_pubk: seq[byte];
              cn: string; validFrom: cstring; validTo: cstring;
              format: cert_format_t): Result[seq[byte], CertError]</a></li>
          </ul></dd>
<dt><a name="cert_generate_key" href="#cert_generate_key"><span>cert_generate_key:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_generate_key(): Result[CertificateKey, CertError]" href="libp2p/transports/tls/certificate_ffi.html#cert_generate_key">certificate_ffi: proc cert_generate_key(): Result[CertificateKey, CertError]</a></li>
          </ul></dd>
<dt><a name="CertificateCreationError" href="#CertificateCreationError"><span>CertificateCreationError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object CertificateCreationError" href="libp2p/transports/tls/certificate.html#CertificateCreationError">certificate: object CertificateCreationError</a></li>
          </ul></dd>
<dt><a name="CertificateKey" href="#CertificateKey"><span>CertificateKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: object CertificateKey" href="libp2p/transports/tls/certificate_ffi.html#CertificateKey">certificate_ffi: object CertificateKey</a></li>
          </ul></dd>
<dt><a name="CertificateParsingError" href="#CertificateParsingError"><span>CertificateParsingError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object CertificateParsingError" href="libp2p/transports/tls/certificate.html#CertificateParsingError">certificate: object CertificateParsingError</a></li>
          </ul></dd>
<dt><a name="CertificatePubKeySerializationError" href="#CertificatePubKeySerializationError"><span>CertificatePubKeySerializationError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object CertificatePubKeySerializationError" href="libp2p/transports/tls/certificate.html#CertificatePubKeySerializationError">certificate: object CertificatePubKeySerializationError</a></li>
          </ul></dd>
<dt><a name="CertificateX509" href="#CertificateX509"><span>CertificateX509:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object CertificateX509" href="libp2p/transports/tls/certificate.html#CertificateX509">certificate: object CertificateX509</a></li>
          </ul></dd>
<dt><a name="cert_new_key_t" href="#cert_new_key_t"><span>cert_new_key_t:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_new_key_t(seckey: seq[byte]): Result[CertificateKey, CertError]" href="libp2p/transports/tls/certificate_ffi.html#cert_new_key_t%2Cseq%5Bbyte%5D">certificate_ffi: proc cert_new_key_t(seckey: seq[byte]): Result[CertificateKey, CertError]</a></li>
          </ul></dd>
<dt><a name="cert_parse" href="#cert_parse"><span>cert_parse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_parse(cert: seq[byte]; format: cert_format_t): Result[ParsedCertificate,
    CertError]" href="libp2p/transports/tls/certificate_ffi.html#cert_parse%2Cseq%5Bbyte%5D%2Ccert_format_t">certificate_ffi: proc cert_parse(cert: seq[byte]; format: cert_format_t): Result[ParsedCertificate,
    CertError]</a></li>
          </ul></dd>
<dt><a name="cert_serialize_privk" href="#cert_serialize_privk"><span>cert_serialize_privk:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_serialize_privk(key: CertificateKey; format: cert_format_t): Result[
    seq[byte], CertError]" href="libp2p/transports/tls/certificate_ffi.html#cert_serialize_privk%2CCertificateKey%2Ccert_format_t">certificate_ffi: proc cert_serialize_privk(key: CertificateKey; format: cert_format_t): Result[
    seq[byte], CertError]</a></li>
          </ul></dd>
<dt><a name="cert_serialize_pubk" href="#cert_serialize_pubk"><span>cert_serialize_pubk:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_serialize_pubk(key: CertificateKey; format: cert_format_t): Result[
    seq[byte], CertError]" href="libp2p/transports/tls/certificate_ffi.html#cert_serialize_pubk%2CCertificateKey%2Ccert_format_t">certificate_ffi: proc cert_serialize_pubk(key: CertificateKey; format: cert_format_t): Result[
    seq[byte], CertError]</a></li>
          </ul></dd>
<dt><a name="cert_signing_req" href="#cert_signing_req"><span>cert_signing_req:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: proc cert_signing_req(cn: string; key: CertificateKey): Result[seq[byte], CertError]" href="libp2p/transports/tls/certificate_ffi.html#cert_signing_req%2Cstring%2CCertificateKey">certificate_ffi: proc cert_signing_req(cn: string; key: CertificateKey): Result[seq[byte], CertError]</a></li>
          </ul></dd>
<dt><a name="ChaChaPoly" href="#ChaChaPoly"><span>ChaChaPoly:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: object ChaChaPoly" href="libp2p/crypto/chacha20poly1305.html#ChaChaPoly">chacha20poly1305: object ChaChaPoly</a></li>
          </ul></dd>
<dt><a name="ChaChaPolyKey" href="#ChaChaPolyKey"><span>ChaChaPolyKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: type ChaChaPolyKey" href="libp2p/crypto/chacha20poly1305.html#ChaChaPolyKey">chacha20poly1305: type ChaChaPolyKey</a></li>
          </ul></dd>
<dt><a name="ChaChaPolyNonce" href="#ChaChaPolyNonce"><span>ChaChaPolyNonce:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: type ChaChaPolyNonce" href="libp2p/crypto/chacha20poly1305.html#ChaChaPolyNonce">chacha20poly1305: type ChaChaPolyNonce</a></li>
          </ul></dd>
<dt><a name="ChaChaPolyTag" href="#ChaChaPolyTag"><span>ChaChaPolyTag:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: type ChaChaPolyTag" href="libp2p/crypto/chacha20poly1305.html#ChaChaPolyTag">chacha20poly1305: type ChaChaPolyTag</a></li>
          </ul></dd>
<dt><a name="checkFieldNumber" href="#checkFieldNumber"><span>checkFieldNumber:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: template checkFieldNumber(i: int)" href="libp2p/protobuf/minprotobuf.html#checkFieldNumber.t%2Cint">minprotobuf: template checkFieldNumber(i: int)</a></li>
          </ul></dd>
<dt><a name="checkFutures" href="#checkFutures"><span>checkFutures:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="errors: macro checkFutures[F](futs: seq[F]; exclude: untyped = []): untyped" href="libp2p/errors.html#checkFutures.m%2Cseq%5BF%5D%2Cuntyped">errors: macro checkFutures[F](futs: seq[F]; exclude: untyped = []): untyped</a></li>
          </ul></dd>
<dt><a name="checkPeerRecord" href="#checkPeerRecord"><span>checkPeerRecord:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc checkPeerRecord(_: PeerRecord; spr: seq[byte]; peerId: PeerId): Result[void,
    string]" href="libp2p/protocols/rendezvous/rendezvous.html#checkPeerRecord%2CPeerRecord%2Cseq%5Bbyte%5D%2CPeerId">rendezvous: proc checkPeerRecord(_: PeerRecord; spr: seq[byte]; peerId: PeerId): Result[void,
    string]</a></li>
          </ul></dd>
<dt><a name="checkScalar" href="#checkScalar"><span>checkScalar:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: proc checkScalar(scalar: openArray[byte]): uint32" href="libp2p/crypto/ed25519/ed25519.html#checkScalar%2CopenArray%5Bbyte%5D">ed25519: proc checkScalar(scalar: openArray[byte]): uint32</a></li>
          </ul></dd>
<dt><a name="checkSignature" href="#checkSignature"><span>checkSignature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc checkSignature(serverSig: PeerIDAuthSignature; serverPublicKey: PublicKey;
               challengeServer: PeerIDAuthChallenge; clientPublicKey: PublicKey;
               hostname: string): bool" href="libp2p/peeridauth/client.html#checkSignature%2CPeerIDAuthSignature%2CPublicKey%2CPeerIDAuthChallenge%2CPublicKey%2Cstring">client: proc checkSignature(serverSig: PeerIDAuthSignature; serverPublicKey: PublicKey;
               challengeServer: PeerIDAuthChallenge; clientPublicKey: PublicKey;
               hostname: string): bool</a></li>
          </ul></dd>
<dt><a name="checkValid" href="#checkValid"><span>checkValid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: proc checkValid(spr: SignedVoucher): Result[void, EnvelopeError]" href="libp2p/protocols/connectivity/relay/messages.html#checkValid%2CSignedVoucher">messages: proc checkValid(spr: SignedVoucher): Result[void, EnvelopeError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routing_record: proc checkValid(spr: SignedPeerRecord): Result[void, EnvelopeError]" href="libp2p/routing_record.html#checkValid%2CSignedPeerRecord">routing_record: proc checkValid(spr: SignedPeerRecord): Result[void, EnvelopeError]</a></li>
          </ul></dd>
<dt><a name="ChronosStream" href="#ChronosStream"><span>ChronosStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chronosstream: type ChronosStream" href="libp2p/stream/chronosstream.html#ChronosStream">chronosstream: type ChronosStream</a></li>
          </ul></dd>
<dt><a name="ChronosStreamTrackerName" href="#ChronosStreamTrackerName"><span>ChronosStreamTrackerName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chronosstream: const ChronosStreamTrackerName" href="libp2p/stream/chronosstream.html#ChronosStreamTrackerName">chronosstream: const ChronosStreamTrackerName</a></li>
          </ul></dd>
<dt><a name="Cid" href="#Cid"><span>Cid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: object Cid" href="libp2p/cid.html#Cid">cid: object Cid</a></li>
          </ul></dd>
<dt><a name="CidError" href="#CidError"><span>CidError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: enum CidError" href="libp2p/cid.html#CidError">cid: enum CidError</a></li>
          </ul></dd>
<dt><a name="CIDv0" href="#CIDv0"><span>CIDv0:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: CidVersion.CIDv0" href="libp2p/cid.html#CIDv0">cid: CidVersion.CIDv0</a></li>
          </ul></dd>
<dt><a name="CIDv1" href="#CIDv1"><span>CIDv1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: CidVersion.CIDv1" href="libp2p/cid.html#CIDv1">cid: CidVersion.CIDv1</a></li>
          </ul></dd>
<dt><a name="CidVersion" href="#CidVersion"><span>CidVersion:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: enum CidVersion" href="libp2p/cid.html#CidVersion">cid: enum CidVersion</a></li>
          </ul></dd>
<dt><a name="CIDvIncorrect" href="#CIDvIncorrect"><span>CIDvIncorrect:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: CidVersion.CIDvIncorrect" href="libp2p/cid.html#CIDvIncorrect">cid: CidVersion.CIDvIncorrect</a></li>
          </ul></dd>
<dt><a name="CIDvReserved" href="#CIDvReserved"><span>CIDvReserved:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: CidVersion.CIDvReserved" href="libp2p/cid.html#CIDvReserved">cid: CidVersion.CIDvReserved</a></li>
          </ul></dd>
<dt><a name="CircuitRelay" href="#CircuitRelay"><span>CircuitRelay:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const CircuitRelay" href="libp2p/multiaddress.html#CircuitRelay">multiaddress: const CircuitRelay</a></li>
          </ul></dd>
<dt><a name="cleanup" href="#cleanup"><span>cleanup:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: proc cleanup(peerStore: PeerStore; peerId: PeerId)" href="libp2p/peerstore.html#cleanup%2CPeerStore%2CPeerId">peerstore: proc cleanup(peerStore: PeerStore; peerId: PeerId)</a></li>
          </ul></dd>
<dt><a name="clear" href="#clear"><span>clear:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: proc clear[T: EcPKI | EcKeyPair](pki: var T)" href="libp2p/crypto/ecnist.html#clear%2CT">ecnist: proc clear[T: EcPKI | EcKeyPair](pki: var T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc clear(pair: var EdKeyPair)" href="libp2p/crypto/ed25519/ed25519.html#clear%2CEdKeyPair">ed25519: proc clear(pair: var EdKeyPair)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc clear(key: var EdPrivateKey)" href="libp2p/crypto/ed25519/ed25519.html#clear%2CEdPrivateKey">ed25519: proc clear(key: var EdPrivateKey)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc clear(key: var EdPublicKey)" href="libp2p/crypto/ed25519/ed25519.html#clear%2CEdPublicKey">ed25519: proc clear(key: var EdPublicKey)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc clear(sig: var EdSignature)" href="libp2p/crypto/ed25519/ed25519.html#clear%2CEdSignature">ed25519: proc clear(sig: var EdSignature)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc clear[T: RsaPKI | RsaKeyPair](pki: var T)" href="libp2p/crypto/rsa.html#clear%2CT">rsa: proc clear[T: RsaPKI | RsaKeyPair](pki: var T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc clear(key: var SkPrivateKey)" href="libp2p/crypto/secp.html#clear%2CSkPrivateKey">secp: proc clear(key: var SkPrivateKey)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="zeroqueue: proc clear(q: var ZeroQueue)" href="libp2p/utils/zeroqueue.html#clear%2CZeroQueue">zeroqueue: proc clear(q: var ZeroQueue)</a></li>
          </ul></dd>
<dt><a name="close" href="#close"><span>close:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc close(c: ConnManager): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/connmanager.html#close%2CConnManager">connmanager: proc close(c: ConnManager): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpchannel: method close(s: LPChannel): InternalRaisesFuture[void, void]" href="libp2p/muxers/mplex/lpchannel.html#close.e%2CLPChannel">lpchannel: method close(s: LPChannel): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mplex: method close(m: Mplex): InternalRaisesFuture[void, void]" href="libp2p/muxers/mplex/mplex.html#close.e%2CMplex">mplex: method close(m: Mplex): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxer: method close(m: Muxer): InternalRaisesFuture[void, void]" href="libp2p/muxers/muxer.html#close.e%2CMuxer">muxer: method close(m: Muxer): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method close(m: Yamux): InternalRaisesFuture[void, void]" href="libp2p/muxers/yamux/yamux.html#close.e%2CYamux">yamux: method close(m: Yamux): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="client: proc close(self: PeerIDAuthClient): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/peeridauth/client.html#close%2CPeerIDAuthClient">client: proc close(self: PeerIDAuthClient): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method close(s: LPStream): InternalRaisesFuture[void, void]" href="libp2p/stream/lpstream.html#close.e%2CLPStream">lpstream: method close(s: LPStream): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorymanager: proc close(self: MemoryListener)" href="libp2p/transports/memorymanager.html#close%2CMemoryListener">memorymanager: proc close(self: MemoryListener)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method close(m: QuicMuxer): InternalRaisesFuture[void, void]" href="libp2p/transports/quictransport.html#close.e%2CQuicMuxer">quictransport: method close(m: QuicMuxer): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method close(session: QuicSession): InternalRaisesFuture[void, void]" href="libp2p/transports/quictransport.html#close.e%2CQuicSession">quictransport: method close(session: QuicSession): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="closed" href="#closed"><span>closed:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: method closed(s: LPChannel): bool" href="libp2p/muxers/mplex/lpchannel.html#closed.e%2CLPChannel">lpchannel: method closed(s: LPChannel): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method closed(s: ChronosStream): bool" href="libp2p/stream/chronosstream.html#closed.e%2CChronosStream">chronosstream: method closed(s: ChronosStream): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method closed(s: LPStream): bool" href="libp2p/stream/lpstream.html#closed.e%2CLPStream">lpstream: method closed(s: LPStream): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method closed(session: QuicSession): bool" href="libp2p/transports/quictransport.html#closed.e%2CQuicSession">quictransport: method closed(session: QuicSession): bool</a></li>
          </ul></dd>
<dt><a name="closeImpl" href="#closeImpl"><span>closeImpl:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: method closeImpl(channel: YamuxChannel): InternalRaisesFuture[void, void]" href="libp2p/muxers/yamux/yamux.html#closeImpl.e%2CYamuxChannel">yamux: method closeImpl(channel: YamuxChannel): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rconn: method closeImpl(self: RelayConnection): InternalRaisesFuture[void, void]" href="libp2p/protocols/connectivity/relay/rconn.html#closeImpl.e%2CRelayConnection">rconn: method closeImpl(self: RelayConnection): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="noise: method closeImpl(s: NoiseConnection): InternalRaisesFuture[void, void]" href="libp2p/protocols/secure/noise.html#closeImpl.e%2CNoiseConnection">noise: method closeImpl(s: NoiseConnection): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: method closeImpl(s: SecureConn): InternalRaisesFuture[void, void]" href="libp2p/protocols/secure/secure.html#closeImpl.e%2CSecureConn">secure: method closeImpl(s: SecureConn): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bridgestream: method closeImpl(s: BridgeStream): InternalRaisesFuture[void, void]" href="libp2p/stream/bridgestream.html#closeImpl.e%2CBridgeStream">bridgestream: method closeImpl(s: BridgeStream): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bufferstream: method closeImpl(s: BufferStream): InternalRaisesFuture[void, void]" href="libp2p/stream/bufferstream.html#closeImpl.e%2CBufferStream">bufferstream: method closeImpl(s: BufferStream): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method closeImpl(s: ChronosStream): InternalRaisesFuture[void, void]" href="libp2p/stream/chronosstream.html#closeImpl.e%2CChronosStream">chronosstream: method closeImpl(s: ChronosStream): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: method closeImpl(s: Connection): InternalRaisesFuture[void, void]" href="libp2p/stream/connection.html#closeImpl.e%2CConnection">connection: method closeImpl(s: Connection): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method closeImpl(s: LPStream): InternalRaisesFuture[void, void]" href="libp2p/stream/lpstream.html#closeImpl.e%2CLPStream">lpstream: method closeImpl(s: LPStream): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method closeImpl(stream: QuicStream): InternalRaisesFuture[void, void]" href="libp2p/transports/quictransport.html#closeImpl.e%2CQuicStream">quictransport: method closeImpl(stream: QuicStream): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method closeImpl(s: WsStream): InternalRaisesFuture[void, void]" href="libp2p/transports/wstransport.html#closeImpl.e%2CWsStream">wstransport: method closeImpl(s: WsStream): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="closeWithEOF" href="#closeWithEOF"><span>closeWithEOF:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc closeWithEOF(s: LPStream): InternalRaisesFuture[void, void]" href="libp2p/stream/lpstream.html#closeWithEOF%2CLPStream">lpstream: proc closeWithEOF(s: LPStream): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="closeWrite" href="#closeWrite"><span>closeWrite:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: method closeWrite(s: LPChannel): InternalRaisesFuture[void, void]" href="libp2p/muxers/mplex/lpchannel.html#closeWrite.e%2CLPChannel">lpchannel: method closeWrite(s: LPChannel): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method closeWrite(channel: YamuxChannel): InternalRaisesFuture[void, void]" href="libp2p/muxers/yamux/yamux.html#closeWrite.e%2CYamuxChannel">yamux: method closeWrite(channel: YamuxChannel): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method closeWrite(s: ChronosStream): InternalRaisesFuture[void, void]" href="libp2p/stream/chronosstream.html#closeWrite.e%2CChronosStream">chronosstream: method closeWrite(s: ChronosStream): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: method closeWrite(s: Connection): InternalRaisesFuture[void, void]" href="libp2p/stream/connection.html#closeWrite.e%2CConnection">connection: method closeWrite(s: Connection): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method closeWrite(stream: QuicStream): InternalRaisesFuture[void, void]" href="libp2p/transports/quictransport.html#closeWrite.e%2CQuicStream">quictransport: method closeWrite(stream: QuicStream): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="cmp" href="#cmp"><span>cmp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: proc cmp(a, b: PeerId): int" href="libp2p/peerid.html#cmp%2CPeerId%2CPeerId">peerid: proc cmp(a, b: PeerId): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc cmp(a, b: XorDistance): int" href="libp2p/protocols/kademlia/types.html#cmp%2CXorDistance%2CXorDistance">types: proc cmp(a, b: XorDistance): int</a></li>
          </ul></dd>
<dt><a name="code" href="#code"><span>code:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc code(tag: Asn1Tag): byte" href="libp2p/crypto/minasn1.html#code%2CAsn1Tag">minasn1: proc code(tag: Asn1Tag): byte</a></li>
          </ul></dd>
<dt><a name="codec" href="#codec"><span>codec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multicodec: proc codec(mt: typedesc[MultiCodec]; code: int): MultiCodec" href="libp2p/multicodec.html#codec%2Ctypedesc%5BMultiCodec%5D%2Cint">multicodec: proc codec(mt: typedesc[MultiCodec]; code: int): MultiCodec</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc codec(mt: typedesc[MultiCodec]; name: string): MultiCodec" href="libp2p/multicodec.html#codec%2Ctypedesc%5BMultiCodec%5D%2Cstring">multicodec: proc codec(mt: typedesc[MultiCodec]; name: string): MultiCodec</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protocol: proc codec(p: LPProtocol): string" href="libp2p/protocols/protocol.html#codec%2CLPProtocol">protocol: proc codec(p: LPProtocol): string</a></li>
          </ul></dd>
<dt><a name="codec%3D" href="#codec%3D"><span>codec=:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: proc codec=(p: LPProtocol; codec: string)" href="libp2p/protocols/protocol.html#codec%3D%2CLPProtocol%2Cstring">protocol: proc codec=(p: LPProtocol; codec: string)</a></li>
          </ul></dd>
<dt><a name="collectCompleted" href="#collectCompleted"><span>collectCompleted:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: proc collectCompleted[T, E](futs: seq[InternalRaisesFuture[T, E]];
                       timeout: chronos.Duration): InternalRaisesFuture[seq[T],
    (CancelledError,)]" href="libp2p/utility.html#collectCompleted%2Cseq%5BInternalRaisesFuture%5BT%2CE%5D%5D%2C">utility: proc collectCompleted[T, E](futs: seq[InternalRaisesFuture[T, E]];
                       timeout: chronos.Duration): InternalRaisesFuture[seq[T],
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="compilesOr" href="#compilesOr"><span>compilesOr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: template compilesOr(a, b: untyped): untyped" href="libp2p/utility.html#compilesOr.t%2Cuntyped%2Cuntyped">utility: template compilesOr(a, b: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="concat" href="#concat"><span>concat:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc concat(m1, m2: MultiAddress): MaResult[MultiAddress]" href="libp2p/multiaddress.html#concat%2CMultiAddress%2CMultiAddress">multiaddress: proc concat(m1, m2: MultiAddress): MaResult[MultiAddress]</a></li>
          </ul></dd>
<dt><a name="ConcurrentUpgrades" href="#ConcurrentUpgrades"><span>ConcurrentUpgrades:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: const ConcurrentUpgrades" href="libp2p/switch.html#ConcurrentUpgrades">switch: const ConcurrentUpgrades</a></li>
          </ul></dd>
<dt><a name="connCount" href="#connCount"><span>connCount:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc connCount(c: ConnManager; peerId: PeerId): int" href="libp2p/connmanager.html#connCount%2CConnManager%2CPeerId">connmanager: proc connCount(c: ConnManager; peerId: PeerId): int</a></li>
          </ul></dd>
<dt><a name="connect" href="#connect"><span>connect:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: method connect(self: Dial; address: MultiAddress; allowUnknownPeerId = false): InternalRaisesFuture[
    PeerId, (DialFailedError, CancelledError)]" href="libp2p/dial.html#connect.e%2CDial%2CMultiAddress">dial: method connect(self: Dial; address: MultiAddress; allowUnknownPeerId = false): InternalRaisesFuture[
    PeerId, (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dial: method connect(self: Dial; peerId: PeerId; addrs: seq[MultiAddress]; forceDial = false;
        reuseConnection = true; dir = Direction.Out): InternalRaisesFuture[void,
    (DialFailedError, CancelledError)]" href="libp2p/dial.html#connect.e%2CDial%2CPeerId%2Cseq%5BMultiAddress%5D">dial: method connect(self: Dial; peerId: PeerId; addrs: seq[MultiAddress]; forceDial = false;
        reuseConnection = true; dir = Direction.Out): InternalRaisesFuture[void,
    (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method connect(self: Dialer; address: MultiAddress; allowUnknownPeerId = false): InternalRaisesFuture[
    PeerId, (DialFailedError, CancelledError)]" href="libp2p/dialer.html#connect.e%2CDialer%2CMultiAddress">dialer: method connect(self: Dialer; address: MultiAddress; allowUnknownPeerId = false): InternalRaisesFuture[
    PeerId, (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method connect(self: Dialer; peerId: PeerId; addrs: seq[MultiAddress];
        forceDial = false; reuseConnection = true; dir = Direction.Out): InternalRaisesFuture[
    void, (DialFailedError, CancelledError)]" href="libp2p/dialer.html#connect.e%2CDialer%2CPeerId%2Cseq%5BMultiAddress%5D">dialer: method connect(self: Dialer; peerId: PeerId; addrs: seq[MultiAddress];
        forceDial = false; reuseConnection = true; dir = Direction.Out): InternalRaisesFuture[
    void, (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc connect(p: PubSubPeer)" href="libp2p/protocols/pubsub/pubsubpeer.html#connect%2CPubSubPeer">pubsubpeer: proc connect(p: PubSubPeer)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method connect(s: Switch; address: MultiAddress; allowUnknownPeerId = false): InternalRaisesFuture[
    PeerId, (DialFailedError, CancelledError)]" href="libp2p/switch.html#connect.e%2CSwitch%2CMultiAddress">switch: method connect(s: Switch; address: MultiAddress; allowUnknownPeerId = false): InternalRaisesFuture[
    PeerId, (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method connect(s: Switch; peerId: PeerId; addrs: seq[MultiAddress]; forceDial = false;
        reuseConnection = true; dir = Direction.Out): InternalRaisesFuture[void,
    (DialFailedError, CancelledError)]" href="libp2p/switch.html#connect.e%2CSwitch%2CPeerId%2Cseq%5BMultiAddress%5D">switch: method connect(s: Switch; peerId: PeerId; addrs: seq[MultiAddress]; forceDial = false;
        reuseConnection = true; dir = Direction.Out): InternalRaisesFuture[void,
    (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wire: proc connect(ma: MultiAddress; bufferSize = DefaultStreamBufferSize;
        child: StreamTransport = nil; flags = default(set[SocketFlags]);
        localAddress: Opt[MultiAddress] = Opt.none(MultiAddress)): InternalRaisesFuture[
    StreamTransport,
    (MaInvalidAddress, TransportError, CancelledError, LPError)]" href="libp2p/wire.html#connect%2CMultiAddress%2CStreamTransport%2COpt%5BMultiAddress%5D">wire: proc connect(ma: MultiAddress; bufferSize = DefaultStreamBufferSize;
        child: StreamTransport = nil; flags = default(set[SocketFlags]);
        localAddress: Opt[MultiAddress] = Opt.none(MultiAddress)): InternalRaisesFuture[
    StreamTransport,
    (MaInvalidAddress, TransportError, CancelledError, LPError)]</a></li>
          </ul></dd>
<dt><a name="connected" href="#connected"><span>connected:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ConnectionType.connected" href="libp2p/protocols/kademlia/protobuf.html#connected">protobuf: ConnectionType.connected</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc connected(p: PubSubPeer): bool" href="libp2p/protocols/pubsub/pubsubpeer.html#connected%2CPubSubPeer">pubsubpeer: proc connected(p: PubSubPeer): bool</a></li>
          </ul></dd>
<dt><a name="connectedPeers" href="#connectedPeers"><span>connectedPeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc connectedPeers(c: ConnManager; dir: Direction): seq[PeerId]" href="libp2p/connmanager.html#connectedPeers%2CConnManager%2CDirection">connmanager: proc connectedPeers(c: ConnManager; dir: Direction): seq[PeerId]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc connectedPeers(s: Switch; dir: Direction): seq[PeerId]" href="libp2p/switch.html#connectedPeers%2CSwitch%2CDirection">switch: proc connectedPeers(s: Switch; dir: Direction): seq[PeerId]</a></li>
          </ul></dd>
<dt><a name="Connection" href="#Connection"><span>Connection:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connection: type Connection" href="libp2p/stream/connection.html#Connection">connection: type Connection</a></li>
          </ul></dd>
<dt><a name="ConnectionFailed" href="#ConnectionFailed"><span>ConnectionFailed:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.ConnectionFailed" href="libp2p/protocols/connectivity/relay/messages.html#ConnectionFailed">messages: StatusV2.ConnectionFailed</a></li>
          </ul></dd>
<dt><a name="ConnectionSlot" href="#ConnectionSlot"><span>ConnectionSlot:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: object ConnectionSlot" href="libp2p/connmanager.html#ConnectionSlot">connmanager: object ConnectionSlot</a></li>
          </ul></dd>
<dt><a name="ConnectionTrackerName" href="#ConnectionTrackerName"><span>ConnectionTrackerName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connection: const ConnectionTrackerName" href="libp2p/stream/connection.html#ConnectionTrackerName">connection: const ConnectionTrackerName</a></li>
          </ul></dd>
<dt><a name="ConnectionType" href="#ConnectionType"><span>ConnectionType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: enum ConnectionType" href="libp2p/protocols/kademlia/protobuf.html#ConnectionType">protobuf: enum ConnectionType</a></li>
          </ul></dd>
<dt><a name="ConnEvent" href="#ConnEvent"><span>ConnEvent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: object ConnEvent" href="libp2p/connmanager.html#ConnEvent">connmanager: object ConnEvent</a></li>
          </ul></dd>
<dt><a name="ConnEventHandler" href="#ConnEventHandler"><span>ConnEventHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: type ConnEventHandler" href="libp2p/connmanager.html#ConnEventHandler">connmanager: type ConnEventHandler</a></li>
          </ul></dd>
<dt><a name="ConnEventKind" href="#ConnEventKind"><span>ConnEventKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: enum ConnEventKind" href="libp2p/connmanager.html#ConnEventKind">connmanager: enum ConnEventKind</a></li>
          </ul></dd>
<dt><a name="connHandler" href="#connHandler"><span>connHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="tcptransport: proc connHandler(self: TcpTransport; client: StreamTransport;
            observedAddr: Opt[MultiAddress]; localAddr: Opt[MultiAddress];
            dir: Direction): Connection" href="libp2p/transports/tcptransport.html#connHandler%2CTcpTransport%2CStreamTransport%2COpt%5BMultiAddress%5D%2COpt%5BMultiAddress%5D%2CDirection">tcptransport: proc connHandler(self: TcpTransport; client: StreamTransport;
            observedAddr: Opt[MultiAddress]; localAddr: Opt[MultiAddress];
            dir: Direction): Connection</a></li>
          </ul></dd>
<dt><a name="ConnManager" href="#ConnManager"><span>ConnManager:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: type ConnManager" href="libp2p/connmanager.html#ConnManager">connmanager: type ConnManager</a></li>
          </ul></dd>
<dt><a name="consume" href="#consume"><span>consume:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bytesview: proc consume(v: var BytesView; n: int)" href="libp2p/utils/bytesview.html#consume%2CBytesView%2Cint">bytesview: proc consume(v: var BytesView; n: int)</a></li>
          </ul></dd>
<dt><a name="consumeTo" href="#consumeTo"><span>consumeTo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="zeroqueue: proc consumeTo(q: var ZeroQueue; pbytes: pointer; nbytes: int): int" href="libp2p/utils/zeroqueue.html#consumeTo%2CZeroQueue%2Cpointer%2Cint">zeroqueue: proc consumeTo(q: var ZeroQueue; pbytes: pointer; nbytes: int): int</a></li>
          </ul></dd>
<dt><a name="contains" href="#contains"><span>contains:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc contains(c: ConnManager; muxer: Muxer): bool" href="libp2p/connmanager.html#contains%2CConnManager%2CMuxer">connmanager: proc contains(c: ConnManager; muxer: Muxer): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connmanager: proc contains(c: ConnManager; peerId: PeerId): bool" href="libp2p/connmanager.html#contains%2CConnManager%2CPeerId">connmanager: proc contains(c: ConnManager; peerId: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc contains(ma: MultiAddress; codec: MultiCodec): MaResult[bool]" href="libp2p/multiaddress.html#contains%2CMultiAddress%2CMultiCodec">multiaddress: proc contains(ma: MultiAddress; codec: MultiCodec): MaResult[bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc contains[T](peerBook: PeerBook[T]; peerId: PeerId): bool" href="libp2p/peerstore.html#contains%2CPeerBook%5BT%5D%2CPeerId">peerstore: proc contains[T](peerBook: PeerBook[T]; peerId: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mcache: proc contains(c: MCache; msgId: MessageId): bool" href="libp2p/protocols/pubsub/mcache.html#contains%2CMCache%2CMessageId">mcache: proc contains(c: MCache; msgId: MessageId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="timedcache: proc contains[K](t: TimedCache[K]; k: K): bool" href="libp2p/protocols/pubsub/timedcache.html#contains%2CTimedCache%5BK%5D%2CK">timedcache: proc contains[K](t: TimedCache[K]; k: K): bool</a></li>
          </ul></dd>
<dt><a name="contentType" href="#contentType"><span>contentType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc contentType(cid: Cid): Result[MultiCodec, CidError]" href="libp2p/cid.html#contentType%2CCid">cid: proc contentType(cid: Cid): Result[MultiCodec, CidError]</a></li>
          </ul></dd>
<dt><a name="ControlGraft" href="#ControlGraft"><span>ControlGraft:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object ControlGraft" href="libp2p/protocols/pubsub/rpc/messages.html#ControlGraft">messages: object ControlGraft</a></li>
          </ul></dd>
<dt><a name="ControlIHave" href="#ControlIHave"><span>ControlIHave:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object ControlIHave" href="libp2p/protocols/pubsub/rpc/messages.html#ControlIHave">messages: object ControlIHave</a></li>
          </ul></dd>
<dt><a name="ControlIMReceiving" href="#ControlIMReceiving"><span>ControlIMReceiving:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object ControlIMReceiving" href="libp2p/protocols/pubsub/rpc/messages.html#ControlIMReceiving">messages: object ControlIMReceiving</a></li>
          </ul></dd>
<dt><a name="ControlIWant" href="#ControlIWant"><span>ControlIWant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object ControlIWant" href="libp2p/protocols/pubsub/rpc/messages.html#ControlIWant">messages: object ControlIWant</a></li>
          </ul></dd>
<dt><a name="ControlMessage" href="#ControlMessage"><span>ControlMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object ControlMessage" href="libp2p/protocols/pubsub/rpc/messages.html#ControlMessage">messages: object ControlMessage</a></li>
          </ul></dd>
<dt><a name="ControlPreamble" href="#ControlPreamble"><span>ControlPreamble:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object ControlPreamble" href="libp2p/protocols/pubsub/rpc/messages.html#ControlPreamble">messages: object ControlPreamble</a></li>
          </ul></dd>
<dt><a name="ControlPrune" href="#ControlPrune"><span>ControlPrune:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object ControlPrune" href="libp2p/protocols/pubsub/rpc/messages.html#ControlPrune">messages: object ControlPrune</a></li>
          </ul></dd>
<dt><a name="Cookie" href="#Cookie"><span>Cookie:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object Cookie" href="libp2p/protocols/rendezvous/protobuf.html#Cookie">protobuf: object Cookie</a></li>
          </ul></dd>
<dt><a name="copy" href="#copy"><span>copy:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: proc copy[T: EcPKI](src: T): T" href="libp2p/crypto/ecnist.html#copy%2CT">ecnist: proc copy[T: EcPKI](src: T): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc copy[T: EcPKI](dst: var T; src: T): bool" href="libp2p/crypto/ecnist.html#copy%2CT%2CT">ecnist: proc copy[T: EcPKI](dst: var T; src: T): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc copy[T: RsaPKI](key: T): T" href="libp2p/crypto/rsa.html#copy%2CT">rsa: proc copy[T: RsaPKI](key: T): T</a></li>
          </ul></dd>
<dt><a name="count" href="#count"><span>count:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc count[T](o: OffsettedSeq[T]; x: T): int" href="libp2p/utils/offsettedseq.html#count%2COffsettedSeq%5BT%5D%2CT">offsettedseq: proc count[T](o: OffsettedSeq[T]; x: T): int</a></li>
          </ul></dd>
<dt><a name="countLeadingZeroBits" href="#countLeadingZeroBits"><span>countLeadingZeroBits:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc countLeadingZeroBits(b: byte): int" href="libp2p/protocols/kademlia/types.html#countLeadingZeroBits%2Cbyte">types: proc countLeadingZeroBits(b: byte): int</a></li>
          </ul></dd>
<dt><a name="countRegister" href="#countRegister"><span>countRegister:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc countRegister[E](rdv: GenericRendezVous[E]; peerId: PeerId): int" href="libp2p/protocols/rendezvous/rendezvous.html#countRegister%2CGenericRendezVous%5BE%5D%2CPeerId">rendezvous: proc countRegister[E](rdv: GenericRendezVous[E]; peerId: PeerId): int</a></li>
          </ul></dd>
<dt><a name="createStreamServer" href="#createStreamServer"><span>createStreamServer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wire: proc createStreamServer[T](ma: MultiAddress; flags: set[ServerFlags] = {};
                      udata: ref T; sock: AsyncFD = asyncInvalidSocket;
                      backlog: int = 100;
                      bufferSize: int = DefaultStreamBufferSize;
                      child: StreamServer = nil;
                      init: TransportInitCallback = nil): StreamServer" href="libp2p/wire.html#createStreamServer%2CMultiAddress%2Cset%5BServerFlags%5D%2Cref.T%2CAsyncFD%2Cint%2Cint%2CStreamServer%2CTransportInitCallback">wire: proc createStreamServer[T](ma: MultiAddress; flags: set[ServerFlags] = {};
                      udata: ref T; sock: AsyncFD = asyncInvalidSocket;
                      backlog: int = 100;
                      bufferSize: int = DefaultStreamBufferSize;
                      child: StreamServer = nil;
                      init: TransportInitCallback = nil): StreamServer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wire: proc createStreamServer[T](ma: MultiAddress; cbproc: StreamCallback;
                      flags: set[ServerFlags] = {}; udata: ref T;
                      sock: AsyncFD = asyncInvalidSocket; backlog: int = 100;
                      bufferSize: int = DefaultStreamBufferSize;
                      child: StreamServer = nil;
                      init: TransportInitCallback = nil): StreamServer" href="libp2p/wire.html#createStreamServer%2CMultiAddress%2CStreamCallback%2Cset%5BServerFlags%5D%2Cref.T%2CAsyncFD%2Cint%2Cint%2CStreamServer%2CTransportInitCallback">wire: proc createStreamServer[T](ma: MultiAddress; cbproc: StreamCallback;
                      flags: set[ServerFlags] = {}; udata: ref T;
                      sock: AsyncFD = asyncInvalidSocket; backlog: int = 100;
                      bufferSize: int = DefaultStreamBufferSize;
                      child: StreamServer = nil;
                      init: TransportInitCallback = nil): StreamServer</a></li>
          </ul></dd>
<dt><a name="CryptoError" href="#CryptoError"><span>CryptoError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: enum CryptoError" href="libp2p/crypto/crypto.html#CryptoError">crypto: enum CryptoError</a></li>
          </ul></dd>
<dt><a name="CryptoResult" href="#CryptoResult"><span>CryptoResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: type CryptoResult" href="libp2p/crypto/crypto.html#CryptoResult">crypto: type CryptoResult</a></li>
          </ul></dd>
<dt><a name="Curve25519" href="#Curve25519"><span>Curve25519:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: object Curve25519" href="libp2p/crypto/curve25519.html#Curve25519">curve25519: object Curve25519</a></li>
          </ul></dd>
<dt><a name="Curve25519Error" href="#Curve25519Error"><span>Curve25519Error:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: enum Curve25519Error" href="libp2p/crypto/curve25519.html#Curve25519Error">curve25519: enum Curve25519Error</a></li>
          </ul></dd>
<dt><a name="Curve25519Key" href="#Curve25519Key"><span>Curve25519Key:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: type Curve25519Key" href="libp2p/crypto/curve25519.html#Curve25519Key">curve25519: type Curve25519Key</a></li>
          </ul></dd>
<dt><a name="Curve25519KeySize" href="#Curve25519KeySize"><span>Curve25519KeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: const Curve25519KeySize" href="libp2p/crypto/curve25519.html#Curve25519KeySize">curve25519: const Curve25519KeySize</a></li>
          </ul></dd>
<dt><a name="CurveOrder" href="#CurveOrder"><span>CurveOrder:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: const CurveOrder" href="libp2p/crypto/ed25519/constants.html#CurveOrder">constants: const CurveOrder</a></li>
          </ul></dd>
<dt><a name="Curver25519GenError" href="#Curver25519GenError"><span>Curver25519GenError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: Curve25519Error.Curver25519GenError" href="libp2p/crypto/curve25519.html#Curver25519GenError">curve25519: Curve25519Error.Curver25519GenError</a></li>
          </ul></dd>
<dt><a name="CustomConnCreationProc" href="#CustomConnCreationProc"><span>CustomConnCreationProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type CustomConnCreationProc" href="libp2p/protocols/pubsub/pubsubpeer.html#CustomConnCreationProc">pubsubpeer: type CustomConnCreationProc</a></li>
          </ul></dd>
<dt><a name="CustomConnectionCallbacks" href="#CustomConnectionCallbacks"><span>CustomConnectionCallbacks:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: object CustomConnectionCallbacks" href="libp2p/protocols/pubsub/pubsubpeer.html#CustomConnectionCallbacks">pubsubpeer: object CustomConnectionCallbacks</a></li>
          </ul></dd>
<dt><a name="CustomPeerSelectionProc" href="#CustomPeerSelectionProc"><span>CustomPeerSelectionProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type CustomPeerSelectionProc" href="libp2p/protocols/pubsub/pubsubpeer.html#CustomPeerSelectionProc">pubsubpeer: type CustomPeerSelectionProc</a></li>
          </ul></dd>
<dt><a name="D2Const" href="#D2Const"><span>D2Const:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: const D2Const" href="libp2p/crypto/ed25519/constants.html#D2Const">constants: const D2Const</a></li>
          </ul></dd>
<dt><a name="data" href="#data"><span>data:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc data(ma: MultiAddress): VBuffer" href="libp2p/multiaddress.html#data%2CMultiAddress">multiaddress: proc data(ma: MultiAddress): VBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bytesview: template data(v: BytesView): openArray[byte]" href="libp2p/utils/bytesview.html#data.t%2CBytesView">bytesview: template data(v: BytesView): openArray[byte]</a></li>
          </ul></dd>
<dt><a name="DConst" href="#DConst"><span>DConst:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: const DConst" href="libp2p/crypto/ed25519/constants.html#DConst">constants: const DConst</a></li>
          </ul></dd>
<dt><a name="decode" href="#decode"><span>decode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multibase: proc decode(mbtype: typedesc[MultiBase]; inbytes: openArray[char]): Result[seq[byte],
    string]" href="libp2p/multibase.html#decode%2Ctypedesc%5BMultiBase%5D%2CopenArray%5Bchar%5D">multibase: proc decode(mbtype: typedesc[MultiBase]; inbytes: openArray[char]): Result[seq[byte],
    string]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multibase: proc decode(mbtype: typedesc[MultiBase]; inbytes: openArray[char];
       outbytes: var openArray[byte]; outlen: var int): MultiBaseStatus" href="libp2p/multibase.html#decode%2Ctypedesc%5BMultiBase%5D%2CopenArray%5Bchar%5D%2CopenArray%5Bbyte%5D%2Cint">multibase: proc decode(mbtype: typedesc[MultiBase]; inbytes: openArray[char];
       outbytes: var openArray[byte]; outlen: var int): MultiBaseStatus</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc decode(mhtype: typedesc[MultiHash]; data: openArray[byte]; mhash: var MultiHash): MhResult[
    int]" href="libp2p/multihash.html#decode%2Ctypedesc%5BMultiHash%5D%2CopenArray%5Bbyte%5D%2CMultiHash">multihash: proc decode(mhtype: typedesc[MultiHash]; data: openArray[byte]; mhash: var MultiHash): MhResult[
    int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(_: typedesc[AutonatMsg]; buf: seq[byte]): Opt[AutonatMsg]" href="libp2p/protocols/connectivity/autonat/types.html#decode%2Ctypedesc%5BAutonatMsg%5D%2Cseq%5Bbyte%5D">types: proc decode(_: typedesc[AutonatMsg]; buf: seq[byte]): Opt[AutonatMsg]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(T: typedesc[AutonatV2Msg]; pb: ProtoBuffer): Opt[T]" href="libp2p/protocols/connectivity/autonatv2/types.html#decode%2Ctypedesc%5BAutonatV2Msg%5D%2CProtoBuffer">types: proc decode(T: typedesc[AutonatV2Msg]; pb: ProtoBuffer): Opt[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(T: typedesc[DialBack]; pb: ProtoBuffer): Opt[T]" href="libp2p/protocols/connectivity/autonatv2/types.html#decode%2Ctypedesc%5BDialBack%5D%2CProtoBuffer">types: proc decode(T: typedesc[DialBack]; pb: ProtoBuffer): Opt[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(T: typedesc[DialBackResponse]; pb: ProtoBuffer): Opt[T]" href="libp2p/protocols/connectivity/autonatv2/types.html#decode%2Ctypedesc%5BDialBackResponse%5D%2CProtoBuffer">types: proc decode(T: typedesc[DialBackResponse]; pb: ProtoBuffer): Opt[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(T: typedesc[DialDataRequest]; pb: ProtoBuffer): Opt[T]" href="libp2p/protocols/connectivity/autonatv2/types.html#decode%2Ctypedesc%5BDialDataRequest%5D%2CProtoBuffer">types: proc decode(T: typedesc[DialDataRequest]; pb: ProtoBuffer): Opt[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(T: typedesc[DialDataResponse]; pb: ProtoBuffer): Opt[T]" href="libp2p/protocols/connectivity/autonatv2/types.html#decode%2Ctypedesc%5BDialDataResponse%5D%2CProtoBuffer">types: proc decode(T: typedesc[DialDataResponse]; pb: ProtoBuffer): Opt[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(T: typedesc[DialRequest]; pb: ProtoBuffer): Opt[T]" href="libp2p/protocols/connectivity/autonatv2/types.html#decode%2Ctypedesc%5BDialRequest%5D%2CProtoBuffer">types: proc decode(T: typedesc[DialRequest]; pb: ProtoBuffer): Opt[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc decode(T: typedesc[DialResponse]; pb: ProtoBuffer): Opt[T]" href="libp2p/protocols/connectivity/autonatv2/types.html#decode%2Ctypedesc%5BDialResponse%5D%2CProtoBuffer">types: proc decode(T: typedesc[DialResponse]; pb: ProtoBuffer): Opt[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc decode(_: typedesc[HopMessage]; buf: seq[byte]): Opt[HopMessage]" href="libp2p/protocols/connectivity/relay/messages.html#decode%2Ctypedesc%5BHopMessage%5D%2Cseq%5Bbyte%5D">messages: proc decode(_: typedesc[HopMessage]; buf: seq[byte]): Opt[HopMessage]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc decode(_: typedesc[RelayMessage]; buf: seq[byte]): Opt[RelayMessage]" href="libp2p/protocols/connectivity/relay/messages.html#decode%2Ctypedesc%5BRelayMessage%5D%2Cseq%5Bbyte%5D">messages: proc decode(_: typedesc[RelayMessage]; buf: seq[byte]): Opt[RelayMessage]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc decode(_: typedesc[StopMessage]; buf: seq[byte]): Opt[StopMessage]" href="libp2p/protocols/connectivity/relay/messages.html#decode%2Ctypedesc%5BStopMessage%5D%2Cseq%5Bbyte%5D">messages: proc decode(_: typedesc[StopMessage]; buf: seq[byte]): Opt[StopMessage]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc decode(_: typedesc[Voucher]; buf: seq[byte]): Result[Voucher, ProtoError]" href="libp2p/protocols/connectivity/relay/messages.html#decode%2Ctypedesc%5BVoucher%5D%2Cseq%5Bbyte%5D">messages: proc decode(_: typedesc[Voucher]; buf: seq[byte]): Result[Voucher, ProtoError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(T: type Message; pb: ProtoBuffer): ProtoResult[T]" href="libp2p/protocols/kademlia/protobuf.html#decode%2CtypeMessage%2CProtoBuffer">protobuf: proc decode(T: type Message; pb: ProtoBuffer): ProtoResult[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(T: type Message; buf: seq[byte]): ProtoResult[T]" href="libp2p/protocols/kademlia/protobuf.html#decode%2CtypeMessage%2Cseq%5Bbyte%5D">protobuf: proc decode(T: type Message; buf: seq[byte]): ProtoResult[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(T: type Peer; pb: ProtoBuffer): ProtoResult[T]" href="libp2p/protocols/kademlia/protobuf.html#decode%2CtypePeer%2CProtoBuffer">protobuf: proc decode(T: type Peer; pb: ProtoBuffer): ProtoResult[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(T: type Record; pb: ProtoBuffer): ProtoResult[T]" href="libp2p/protocols/kademlia/protobuf.html#decode%2CtypeRecord%2CProtoBuffer">protobuf: proc decode(T: type Record; pb: ProtoBuffer): ProtoResult[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(_: typedesc[Cookie]; buf: seq[byte]): Opt[Cookie]" href="libp2p/protocols/rendezvous/protobuf.html#decode%2Ctypedesc%5BCookie%5D%2Cseq%5Bbyte%5D">protobuf: proc decode(_: typedesc[Cookie]; buf: seq[byte]): Opt[Cookie]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(_: typedesc[Discover]; buf: seq[byte]): Opt[Discover]" href="libp2p/protocols/rendezvous/protobuf.html#decode%2Ctypedesc%5BDiscover%5D%2Cseq%5Bbyte%5D">protobuf: proc decode(_: typedesc[Discover]; buf: seq[byte]): Opt[Discover]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(_: typedesc[DiscoverResponse]; buf: seq[byte]): Opt[DiscoverResponse]" href="libp2p/protocols/rendezvous/protobuf.html#decode%2Ctypedesc%5BDiscoverResponse%5D%2Cseq%5Bbyte%5D">protobuf: proc decode(_: typedesc[DiscoverResponse]; buf: seq[byte]): Opt[DiscoverResponse]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(_: typedesc[Message]; buf: seq[byte]): Opt[Message]" href="libp2p/protocols/rendezvous/protobuf.html#decode%2Ctypedesc%5BMessage%5D%2Cseq%5Bbyte%5D">protobuf: proc decode(_: typedesc[Message]; buf: seq[byte]): Opt[Message]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(_: typedesc[Register]; buf: seq[byte]): Opt[Register]" href="libp2p/protocols/rendezvous/protobuf.html#decode%2Ctypedesc%5BRegister%5D%2Cseq%5Bbyte%5D">protobuf: proc decode(_: typedesc[Register]; buf: seq[byte]): Opt[Register]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(_: typedesc[RegisterResponse]; buf: seq[byte]): Opt[RegisterResponse]" href="libp2p/protocols/rendezvous/protobuf.html#decode%2Ctypedesc%5BRegisterResponse%5D%2Cseq%5Bbyte%5D">protobuf: proc decode(_: typedesc[RegisterResponse]; buf: seq[byte]): Opt[RegisterResponse]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc decode(_: typedesc[Unregister]; buf: seq[byte]): Opt[Unregister]" href="libp2p/protocols/rendezvous/protobuf.html#decode%2Ctypedesc%5BUnregister%5D%2Cseq%5Bbyte%5D">protobuf: proc decode(_: typedesc[Unregister]; buf: seq[byte]): Opt[Unregister]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routing_record: proc decode(T: typedesc[PeerRecord]; buffer: seq[byte]): Result[PeerRecord,
    ProtoError]" href="libp2p/routing_record.html#decode%2Ctypedesc%5BPeerRecord%5D%2Cseq%5Bbyte%5D">routing_record: proc decode(T: typedesc[PeerRecord]; buffer: seq[byte]): Result[PeerRecord,
    ProtoError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc decode(T: typedesc[Envelope]; buf: seq[byte]; domain: string): Result[Envelope,
    EnvelopeError]" href="libp2p/signed_envelope.html#decode%2Ctypedesc%5BEnvelope%5D%2Cseq%5Bbyte%5D%2Cstring">signed_envelope: proc decode(T: typedesc[Envelope]; buf: seq[byte]; domain: string): Result[Envelope,
    EnvelopeError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc decode[T](_: typedesc[SignedPayload[T]]; buffer: seq[byte]): Result[
    SignedPayload[T], EnvelopeError]" href="libp2p/signed_envelope.html#decode%2Ctypedesc%5BSignedPayload%5BT%5D%5D%2Cseq%5Bbyte%5D">signed_envelope: proc decode[T](_: typedesc[SignedPayload[T]]; buffer: seq[byte]): Result[
    SignedPayload[T], EnvelopeError]</a></li>
          </ul></dd>
<dt><a name="decodeControl" href="#decodeControl"><span>decodeControl:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeControl(pb: ProtoBuffer): ProtoResult[Option[ControlMessage]]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeControl%2CProtoBuffer">protobuf: proc decodeControl(pb: ProtoBuffer): ProtoResult[Option[ControlMessage]]</a></li>
          </ul></dd>
<dt><a name="decodedLength" href="#decodedLength"><span>decodedLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multibase: proc decodedLength(mbtype: typedesc[MultiBase]; encoding: char; length: int): int" href="libp2p/multibase.html#decodedLength%2Ctypedesc%5BMultiBase%5D%2Cchar%2Cint">multibase: proc decodedLength(mbtype: typedesc[MultiBase]; encoding: char; length: int): int</a></li>
          </ul></dd>
<dt><a name="decodeGraft" href="#decodeGraft"><span>decodeGraft:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeGraft(pb: ProtoBuffer): ProtoResult[ControlGraft]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeGraft%2CProtoBuffer">protobuf: proc decodeGraft(pb: ProtoBuffer): ProtoResult[ControlGraft]</a></li>
          </ul></dd>
<dt><a name="decodeIHave" href="#decodeIHave"><span>decodeIHave:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeIHave(pb: ProtoBuffer): ProtoResult[ControlIHave]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeIHave%2CProtoBuffer">protobuf: proc decodeIHave(pb: ProtoBuffer): ProtoResult[ControlIHave]</a></li>
          </ul></dd>
<dt><a name="decodeIMReceiving" href="#decodeIMReceiving"><span>decodeIMReceiving:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeIMReceiving(pb: ProtoBuffer): ProtoResult[ControlIMReceiving]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeIMReceiving%2CProtoBuffer">protobuf: proc decodeIMReceiving(pb: ProtoBuffer): ProtoResult[ControlIMReceiving]</a></li>
          </ul></dd>
<dt><a name="decodeIWant" href="#decodeIWant"><span>decodeIWant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeIWant(pb: ProtoBuffer): ProtoResult[ControlIWant]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeIWant%2CProtoBuffer">protobuf: proc decodeIWant(pb: ProtoBuffer): ProtoResult[ControlIWant]</a></li>
          </ul></dd>
<dt><a name="decodeMessage" href="#decodeMessage"><span>decodeMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeMessage(pb: ProtoBuffer): ProtoResult[Message]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeMessage%2CProtoBuffer">protobuf: proc decodeMessage(pb: ProtoBuffer): ProtoResult[Message]</a></li>
          </ul></dd>
<dt><a name="decodeMessages" href="#decodeMessages"><span>decodeMessages:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeMessages(pb: ProtoBuffer): ProtoResult[seq[Message]]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeMessages%2CProtoBuffer">protobuf: proc decodeMessages(pb: ProtoBuffer): ProtoResult[seq[Message]]</a></li>
          </ul></dd>
<dt><a name="decodeMsg" href="#decodeMsg"><span>decodeMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: proc decodeMsg(buf: seq[byte]): Opt[IdentifyInfo]" href="libp2p/protocols/identify.html#decodeMsg%2Cseq%5Bbyte%5D">identify: proc decodeMsg(buf: seq[byte]): Opt[IdentifyInfo]</a></li>
          </ul></dd>
<dt><a name="decodePeerInfoMsg" href="#decodePeerInfoMsg"><span>decodePeerInfoMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodePeerInfoMsg(pb: ProtoBuffer): ProtoResult[PeerInfoMsg]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodePeerInfoMsg%2CProtoBuffer">protobuf: proc decodePeerInfoMsg(pb: ProtoBuffer): ProtoResult[PeerInfoMsg]</a></li>
          </ul></dd>
<dt><a name="decodePreamble" href="#decodePreamble"><span>decodePreamble:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodePreamble(pb: ProtoBuffer): ProtoResult[ControlPreamble]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodePreamble%2CProtoBuffer">protobuf: proc decodePreamble(pb: ProtoBuffer): ProtoResult[ControlPreamble]</a></li>
          </ul></dd>
<dt><a name="decodePrune" href="#decodePrune"><span>decodePrune:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodePrune(pb: ProtoBuffer): ProtoResult[ControlPrune]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodePrune%2CProtoBuffer">protobuf: proc decodePrune(pb: ProtoBuffer): ProtoResult[ControlPrune]</a></li>
          </ul></dd>
<dt><a name="decodeRpcMsg" href="#decodeRpcMsg"><span>decodeRpcMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeRpcMsg(msg: seq[byte]): ProtoResult[RPCMsg]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeRpcMsg%2Cseq%5Bbyte%5D">protobuf: proc decodeRpcMsg(msg: seq[byte]): ProtoResult[RPCMsg]</a></li>
          </ul></dd>
<dt><a name="decodeSubscription" href="#decodeSubscription"><span>decodeSubscription:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeSubscription(pb: ProtoBuffer): ProtoResult[SubOpts]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeSubscription%2CProtoBuffer">protobuf: proc decodeSubscription(pb: ProtoBuffer): ProtoResult[SubOpts]</a></li>
          </ul></dd>
<dt><a name="decodeSubscriptions" href="#decodeSubscriptions"><span>decodeSubscriptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc decodeSubscriptions(pb: ProtoBuffer): ProtoResult[seq[SubOpts]]" href="libp2p/protocols/pubsub/rpc/protobuf.html#decodeSubscriptions%2CProtoBuffer">protobuf: proc decodeSubscriptions(pb: ProtoBuffer): ProtoResult[seq[SubOpts]]</a></li>
          </ul></dd>
<dt><a name="decrypt" href="#decrypt"><span>decrypt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: proc decrypt(_: type[ChaChaPoly]; key: ChaChaPolyKey; nonce: ChaChaPolyNonce;
        tag: var ChaChaPolyTag; data: var openArray[byte]; aad: openArray[byte])" href="libp2p/crypto/chacha20poly1305.html#decrypt%2Ctype%5BChaChaPoly%5D%2CChaChaPolyKey%2CChaChaPolyNonce%2CChaChaPolyTag%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D">chacha20poly1305: proc decrypt(_: type[ChaChaPoly]; key: ChaChaPolyKey; nonce: ChaChaPolyNonce;
        tag: var ChaChaPolyTag; data: var openArray[byte]; aad: openArray[byte])</a></li>
          </ul></dd>
<dt><a name="DefaultAlpha" href="#DefaultAlpha"><span>DefaultAlpha:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultAlpha" href="libp2p/protocols/kademlia/types.html#DefaultAlpha">types: const DefaultAlpha</a></li>
          </ul></dd>
<dt><a name="DefaultAmplificationAttackDialTimeout" href="#DefaultAmplificationAttackDialTimeout"><span>DefaultAmplificationAttackDialTimeout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultAmplificationAttackDialTimeout" href="libp2p/protocols/connectivity/autonatv2/types.html#DefaultAmplificationAttackDialTimeout">types: const DefaultAmplificationAttackDialTimeout</a></li>
          </ul></dd>
<dt><a name="DefaultBucketRefreshTime" href="#DefaultBucketRefreshTime"><span>DefaultBucketRefreshTime:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultBucketRefreshTime" href="libp2p/protocols/kademlia/types.html#DefaultBucketRefreshTime">types: const DefaultBucketRefreshTime</a></li>
          </ul></dd>
<dt><a name="DefaultChanTimeout" href="#DefaultChanTimeout"><span>DefaultChanTimeout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: const DefaultChanTimeout" href="libp2p/muxers/muxer.html#DefaultChanTimeout">muxer: const DefaultChanTimeout</a></li>
          </ul></dd>
<dt><a name="DefaultCleanupProvidersInterval" href="#DefaultCleanupProvidersInterval"><span>DefaultCleanupProvidersInterval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultCleanupProvidersInterval" href="libp2p/protocols/kademlia/types.html#DefaultCleanupProvidersInterval">types: const DefaultCleanupProvidersInterval</a></li>
          </ul></dd>
<dt><a name="DefaultConnectionTimeout" href="#DefaultConnectionTimeout"><span>DefaultConnectionTimeout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connection: const DefaultConnectionTimeout" href="libp2p/stream/connection.html#DefaultConnectionTimeout">connection: const DefaultConnectionTimeout</a></li>
          </ul></dd>
<dt><a name="DefaultDialBackTimeout" href="#DefaultDialBackTimeout"><span>DefaultDialBackTimeout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: const DefaultDialBackTimeout" href="libp2p/protocols/connectivity/autonatv2/client.html#DefaultDialBackTimeout">client: const DefaultDialBackTimeout</a></li>
          </ul></dd>
<dt><a name="DefaultDialDataSize" href="#DefaultDialDataSize"><span>DefaultDialDataSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultDialDataSize" href="libp2p/protocols/connectivity/autonatv2/types.html#DefaultDialDataSize">types: const DefaultDialDataSize</a></li>
          </ul></dd>
<dt><a name="DefaultDialTimeout" href="#DefaultDialTimeout"><span>DefaultDialTimeout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultDialTimeout" href="libp2p/protocols/connectivity/autonatv2/types.html#DefaultDialTimeout">types: const DefaultDialTimeout</a></li>
          </ul></dd>
<dt><a name="DefaultDnsServers" href="#DefaultDnsServers"><span>DefaultDnsServers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: const DefaultDnsServers" href="libp2p/autotls/service.html#DefaultDnsServers">service: const DefaultDnsServers</a></li>
          </ul></dd>
<dt><a name="DefaultEntrySelector" href="#DefaultEntrySelector"><span>DefaultEntrySelector:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type DefaultEntrySelector" href="libp2p/protocols/kademlia/types.html#DefaultEntrySelector">types: type DefaultEntrySelector</a></li>
          </ul></dd>
<dt><a name="DefaultEntryValidator" href="#DefaultEntryValidator"><span>DefaultEntryValidator:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type DefaultEntryValidator" href="libp2p/protocols/kademlia/types.html#DefaultEntryValidator">types: type DefaultEntryValidator</a></li>
          </ul></dd>
<dt><a name="DefaultHeartbeatSleepTime" href="#DefaultHeartbeatSleepTime"><span>DefaultHeartbeatSleepTime:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: const DefaultHeartbeatSleepTime" href="libp2p/protocols/connectivity/relay/relay.html#DefaultHeartbeatSleepTime">relay: const DefaultHeartbeatSleepTime</a></li>
          </ul></dd>
<dt><a name="DefaultKeySize" href="#DefaultKeySize"><span>DefaultKeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const DefaultKeySize" href="libp2p/crypto/rsa.html#DefaultKeySize">rsa: const DefaultKeySize</a></li>
          </ul></dd>
<dt><a name="DefaultLimitData" href="#DefaultLimitData"><span>DefaultLimitData:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: const DefaultLimitData" href="libp2p/protocols/connectivity/relay/relay.html#DefaultLimitData">relay: const DefaultLimitData</a></li>
          </ul></dd>
<dt><a name="DefaultLimitDuration" href="#DefaultLimitDuration"><span>DefaultLimitDuration:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: const DefaultLimitDuration" href="libp2p/protocols/connectivity/relay/relay.html#DefaultLimitDuration">relay: const DefaultLimitDuration</a></li>
          </ul></dd>
<dt><a name="DefaultMaxBuckets" href="#DefaultMaxBuckets"><span>DefaultMaxBuckets:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultMaxBuckets" href="libp2p/protocols/kademlia/types.html#DefaultMaxBuckets">types: const DefaultMaxBuckets</a></li>
          </ul></dd>
<dt><a name="DefaultMaxIncomingStreams" href="#DefaultMaxIncomingStreams"><span>DefaultMaxIncomingStreams:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: const DefaultMaxIncomingStreams" href="libp2p/protocols/protocol.html#DefaultMaxIncomingStreams">protocol: const DefaultMaxIncomingStreams</a></li>
          </ul></dd>
<dt><a name="DefaultMaxNumElementsInNonPriorityQueue" href="#DefaultMaxNumElementsInNonPriorityQueue"><span>DefaultMaxNumElementsInNonPriorityQueue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: const DefaultMaxNumElementsInNonPriorityQueue" href="libp2p/protocols/pubsub/pubsubpeer.html#DefaultMaxNumElementsInNonPriorityQueue">pubsubpeer: const DefaultMaxNumElementsInNonPriorityQueue</a></li>
          </ul></dd>
<dt><a name="defaultMsgIdProvider" href="#defaultMsgIdProvider"><span>defaultMsgIdProvider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="message: proc defaultMsgIdProvider(m: Message): Result[MessageId, ValidationResult]" href="libp2p/protocols/pubsub/rpc/message.html#defaultMsgIdProvider%2CMessage">message: proc defaultMsgIdProvider(m: Message): Result[MessageId, ValidationResult]</a></li>
          </ul></dd>
<dt><a name="DefaultProvidedKeyCapacity" href="#DefaultProvidedKeyCapacity"><span>DefaultProvidedKeyCapacity:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultProvidedKeyCapacity" href="libp2p/protocols/kademlia/types.html#DefaultProvidedKeyCapacity">types: const DefaultProvidedKeyCapacity</a></li>
          </ul></dd>
<dt><a name="DefaultProviderExpirationInterval" href="#DefaultProviderExpirationInterval"><span>DefaultProviderExpirationInterval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultProviderExpirationInterval" href="libp2p/protocols/kademlia/types.html#DefaultProviderExpirationInterval">types: const DefaultProviderExpirationInterval</a></li>
          </ul></dd>
<dt><a name="DefaultProviderRecordCapacity" href="#DefaultProviderRecordCapacity"><span>DefaultProviderRecordCapacity:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultProviderRecordCapacity" href="libp2p/protocols/kademlia/types.html#DefaultProviderRecordCapacity">types: const DefaultProviderRecordCapacity</a></li>
          </ul></dd>
<dt><a name="DefaultPublicExponent" href="#DefaultPublicExponent"><span>DefaultPublicExponent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const DefaultPublicExponent" href="libp2p/crypto/rsa.html#DefaultPublicExponent">rsa: const DefaultPublicExponent</a></li>
          </ul></dd>
<dt><a name="DefaultQuorum" href="#DefaultQuorum"><span>DefaultQuorum:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultQuorum" href="libp2p/protocols/kademlia/types.html#DefaultQuorum">types: const DefaultQuorum</a></li>
          </ul></dd>
<dt><a name="DefaultRenewBufferTime" href="#DefaultRenewBufferTime"><span>DefaultRenewBufferTime:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: const DefaultRenewBufferTime" href="libp2p/autotls/service.html#DefaultRenewBufferTime">service: const DefaultRenewBufferTime</a></li>
          </ul></dd>
<dt><a name="DefaultRenewCheckTime" href="#DefaultRenewCheckTime"><span>DefaultRenewCheckTime:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: const DefaultRenewCheckTime" href="libp2p/autotls/service.html#DefaultRenewCheckTime">service: const DefaultRenewCheckTime</a></li>
          </ul></dd>
<dt><a name="DefaultReplication" href="#DefaultReplication"><span>DefaultReplication:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultReplication" href="libp2p/protocols/kademlia/types.html#DefaultReplication">types: const DefaultReplication</a></li>
          </ul></dd>
<dt><a name="DefaultRepublishInterval" href="#DefaultRepublishInterval"><span>DefaultRepublishInterval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultRepublishInterval" href="libp2p/protocols/kademlia/types.html#DefaultRepublishInterval">types: const DefaultRepublishInterval</a></li>
          </ul></dd>
<dt><a name="DefaultReservationTTL" href="#DefaultReservationTTL"><span>DefaultReservationTTL:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: const DefaultReservationTTL" href="libp2p/protocols/connectivity/relay/relay.html#DefaultReservationTTL">relay: const DefaultReservationTTL</a></li>
          </ul></dd>
<dt><a name="DefaultRetries" href="#DefaultRetries"><span>DefaultRetries:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultRetries" href="libp2p/protocols/kademlia/types.html#DefaultRetries">types: const DefaultRetries</a></li>
          </ul></dd>
<dt><a name="DefaultTimeout" href="#DefaultTimeout"><span>DefaultTimeout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DefaultTimeout" href="libp2p/protocols/kademlia/types.html#DefaultTimeout">types: const DefaultTimeout</a></li>
          </ul></dd>
<dt><a name="del" href="#del"><span>del:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: proc del[T](peerBook: PeerBook[T]; peerId: PeerId): bool" href="libp2p/peerstore.html#del%2CPeerBook%5BT%5D%2CPeerId">peerstore: proc del[T](peerBook: PeerBook[T]; peerId: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc del(peerStore: PeerStore; peerId: PeerId)" href="libp2p/peerstore.html#del%2CPeerStore%2CPeerId">peerstore: proc del(peerStore: PeerStore; peerId: PeerId)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc del(pk: ProvidedKeys; c: Cid)" href="libp2p/protocols/kademlia/provider.html#del%2CProvidedKeys%2CCid">provider: proc del(pk: ProvidedKeys; c: Cid)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc del(pr: ProviderRecords; index: Natural)" href="libp2p/protocols/kademlia/provider.html#del%2CProviderRecords%2CNatural">provider: proc del(pr: ProviderRecords; index: Natural)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc del(ps: var PreambleStore; msgId: MessageId)" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#del%2CPreambleStore%2CMessageId">preamblestore: proc del(ps: var PreambleStore; msgId: MessageId)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="timedcache: proc del[K](t: var TimedCache[K]; key: K): Opt[TimedEntry[K]]" href="libp2p/protocols/pubsub/timedcache.html#del%2CTimedCache%5BK%5D%2CK">timedcache: proc del[K](t: var TimedCache[K]; key: K): Opt[TimedEntry[K]]</a></li>
          </ul></dd>
<dt><a name="deletesRegister" href="#deletesRegister"><span>deletesRegister:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc deletesRegister[E](rdv: GenericRendezVous[E]; interval = 1.minutes): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/rendezvous/rendezvous.html#deletesRegister%2CGenericRendezVous%5BE%5D">rendezvous: proc deletesRegister[E](rdv: GenericRendezVous[E]; interval = 1.minutes): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="DER" href="#DER"><span>DER:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: EncodingFormat.DER" href="libp2p/transports/tls/certificate.html#DER">certificate: EncodingFormat.DER</a></li>
          </ul></dd>
<dt><a name="Dial" href="#Dial"><span>Dial:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: type Dial" href="libp2p/dial.html#Dial">dial: type Dial</a></li>
          </ul></dd>
<dt><a name="dial" href="#dial"><span>dial:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: method dial(self: Dial; peerId: PeerId; addrs: seq[MultiAddress]; protos: seq[string];
     forceDial = false): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]" href="libp2p/dial.html#dial.e%2CDial%2CPeerId%2Cseq%5BMultiAddress%5D%2Cseq%5Bstring%5D">dial: method dial(self: Dial; peerId: PeerId; addrs: seq[MultiAddress]; protos: seq[string];
     forceDial = false): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dial: method dial(self: Dial; peerId: PeerId; protos: seq[string]): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]" href="libp2p/dial.html#dial.e%2CDial%2CPeerId%2Cseq%5Bstring%5D">dial: method dial(self: Dial; peerId: PeerId; protos: seq[string]): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method dial(self: Dialer; peerId: PeerId; addrs: seq[MultiAddress];
     protos: seq[string]; forceDial = false): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]" href="libp2p/dialer.html#dial.e%2CDialer%2CPeerId%2Cseq%5BMultiAddress%5D%2Cseq%5Bstring%5D">dialer: method dial(self: Dialer; peerId: PeerId; addrs: seq[MultiAddress];
     protos: seq[string]; forceDial = false): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method dial(self: Dialer; peerId: PeerId; protos: seq[string]): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]" href="libp2p/dialer.html#dial.e%2CDialer%2CPeerId%2Cseq%5Bstring%5D">dialer: method dial(self: Dialer; peerId: PeerId; protos: seq[string]): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="Dial" href="#Dial"><span>Dial:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: MsgType.Dial" href="libp2p/protocols/connectivity/autonat/types.html#Dial">types: MsgType.Dial</a></li>
          </ul></dd>
<dt><a name="dial" href="#dial"><span>dial:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rtransport: proc dial(self: RelayTransport; ma: MultiAddress): InternalRaisesFuture[Connection,
    (RelayDialError, CancelledError)]" href="libp2p/protocols/connectivity/relay/rtransport.html#dial%2CRelayTransport%2CMultiAddress">rtransport: proc dial(self: RelayTransport; ma: MultiAddress): InternalRaisesFuture[Connection,
    (RelayDialError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rtransport: method dial(self: RelayTransport; hostname: string; ma: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/protocols/connectivity/relay/rtransport.html#dial.e%2CRelayTransport%2Cstring%2CMultiAddress%2COpt%5BPeerId%5D">rtransport: method dial(self: RelayTransport; hostname: string; ma: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc dial(s: Switch; peerId: PeerId; addrs: seq[MultiAddress]; proto: string): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]" href="libp2p/switch.html#dial%2CSwitch%2CPeerId%2Cseq%5BMultiAddress%5D%2Cstring">switch: proc dial(s: Switch; peerId: PeerId; addrs: seq[MultiAddress]; proto: string): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc dial(s: Switch; peerId: PeerId; proto: string): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]" href="libp2p/switch.html#dial%2CSwitch%2CPeerId%2Cstring">switch: proc dial(s: Switch; peerId: PeerId; proto: string): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method dial(s: Switch; peerId: PeerId; addrs: seq[MultiAddress]; protos: seq[string];
     forceDial = false): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]" href="libp2p/switch.html#dial.e%2CSwitch%2CPeerId%2Cseq%5BMultiAddress%5D%2Cseq%5Bstring%5D">switch: method dial(s: Switch; peerId: PeerId; addrs: seq[MultiAddress]; protos: seq[string];
     forceDial = false): InternalRaisesFuture[Connection,
    (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method dial(s: Switch; peerId: PeerId; protos: seq[string]): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]" href="libp2p/switch.html#dial.e%2CSwitch%2CPeerId%2Cseq%5Bstring%5D">switch: method dial(s: Switch; peerId: PeerId; protos: seq[string]): InternalRaisesFuture[
    Connection, (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorymanager: proc dial(self: memoryConnManager; address: string): MemoryListener" href="libp2p/transports/memorymanager.html#dial%2CmemoryConnManager%2Cstring">memorymanager: proc dial(self: memoryConnManager; address: string): MemoryListener</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorymanager: proc dial(self: MemoryListener): Future[Connection]" href="libp2p/transports/memorymanager.html#dial%2CMemoryListener">memorymanager: proc dial(self: MemoryListener): Future[Connection]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: proc dial(self: MemoryTransport; ma: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): Future[Connection]" href="libp2p/transports/memorytransport.html#dial%2CMemoryTransport%2CMultiAddress%2COpt%5BPeerId%5D">memorytransport: proc dial(self: MemoryTransport; ma: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): Future[Connection]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: method dial(self: MemoryTransport; hostname: string; ma: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/memorytransport.html#dial.e%2CMemoryTransport%2Cstring%2CMultiAddress%2COpt%5BPeerId%5D">memorytransport: method dial(self: MemoryTransport; hostname: string; ma: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method dial(self: QuicTransport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/quictransport.html#dial.e%2CQuicTransport%2Cstring%2CMultiAddress%2COpt%5BPeerId%5D">quictransport: method dial(self: QuicTransport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="tcptransport: method dial(self: TcpTransport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/tcptransport.html#dial.e%2CTcpTransport%2Cstring%2CMultiAddress%2COpt%5BPeerId%5D">tcptransport: method dial(self: TcpTransport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="transport: proc dial(self: Transport; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): Future[Connection]" href="libp2p/transports/transport.html#dial%2CTransport%2CMultiAddress%2COpt%5BPeerId%5D">transport: proc dial(self: Transport; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): Future[Connection]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="transport: method dial(self: Transport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/transport.html#dial.e%2CTransport%2Cstring%2CMultiAddress%2COpt%5BPeerId%5D">transport: method dial(self: Transport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method dial(self: WsTransport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]" href="libp2p/transports/wstransport.html#dial.e%2CWsTransport%2Cstring%2CMultiAddress%2COpt%5BPeerId%5D">wstransport: method dial(self: WsTransport; hostname: string; address: MultiAddress;
     peerId: Opt[PeerId] = Opt.none(PeerId)): InternalRaisesFuture[Connection,
    (TransportError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="dialAndUpgrade" href="#dialAndUpgrade"><span>dialAndUpgrade:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: method dialAndUpgrade(self: Dial; peerId: Opt[PeerId]; addrs: seq[MultiAddress];
               dir = Direction.Out): InternalRaisesFuture[Muxer,
    (CancelledError, MaError, TransportAddressError, LPError)]" href="libp2p/dial.html#dialAndUpgrade.e%2CDial%2COpt%5BPeerId%5D%2Cseq%5BMultiAddress%5D">dial: method dialAndUpgrade(self: Dial; peerId: Opt[PeerId]; addrs: seq[MultiAddress];
               dir = Direction.Out): InternalRaisesFuture[Muxer,
    (CancelledError, MaError, TransportAddressError, LPError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dial: method dialAndUpgrade(self: Dial; peerId: Opt[PeerId]; hostname: string;
               addrs: MultiAddress; dir = Direction.Out): InternalRaisesFuture[
    Muxer, (CancelledError,)]" href="libp2p/dial.html#dialAndUpgrade.e%2CDial%2COpt%5BPeerId%5D%2Cstring%2CMultiAddress">dial: method dialAndUpgrade(self: Dial; peerId: Opt[PeerId]; hostname: string;
               addrs: MultiAddress; dir = Direction.Out): InternalRaisesFuture[
    Muxer, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method dialAndUpgrade(self: Dialer; peerId: Opt[PeerId]; addrs: seq[MultiAddress];
               dir = Direction.Out): InternalRaisesFuture[Muxer,
    (CancelledError, MaError, TransportAddressError, LPError)]" href="libp2p/dialer.html#dialAndUpgrade.e%2CDialer%2COpt%5BPeerId%5D%2Cseq%5BMultiAddress%5D">dialer: method dialAndUpgrade(self: Dialer; peerId: Opt[PeerId]; addrs: seq[MultiAddress];
               dir = Direction.Out): InternalRaisesFuture[Muxer,
    (CancelledError, MaError, TransportAddressError, LPError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method dialAndUpgrade(self: Dialer; peerId: Opt[PeerId]; hostname: string;
               addrs: MultiAddress; dir = Direction.Out): InternalRaisesFuture[
    Muxer, (CancelledError,)]" href="libp2p/dialer.html#dialAndUpgrade.e%2CDialer%2COpt%5BPeerId%5D%2Cstring%2CMultiAddress">dialer: method dialAndUpgrade(self: Dialer; peerId: Opt[PeerId]; hostname: string;
               addrs: MultiAddress; dir = Direction.Out): InternalRaisesFuture[
    Muxer, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="DialBack" href="#DialBack"><span>DialBack:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object DialBack" href="libp2p/protocols/connectivity/autonatv2/types.html#DialBack">types: object DialBack</a></li>
          </ul></dd>
<dt><a name="DialBackLpSize" href="#DialBackLpSize"><span>DialBackLpSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DialBackLpSize" href="libp2p/protocols/connectivity/autonatv2/types.html#DialBackLpSize">types: const DialBackLpSize</a></li>
          </ul></dd>
<dt><a name="DialBackResponse" href="#DialBackResponse"><span>DialBackResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object DialBackResponse" href="libp2p/protocols/connectivity/autonatv2/types.html#DialBackResponse">types: object DialBackResponse</a></li>
          </ul></dd>
<dt><a name="DialBackStatus" href="#DialBackStatus"><span>DialBackStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: enum DialBackStatus" href="libp2p/protocols/connectivity/autonatv2/types.html#DialBackStatus">types: enum DialBackStatus</a></li>
          </ul></dd>
<dt><a name="DialDataRequest" href="#DialDataRequest"><span>DialDataRequest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object DialDataRequest" href="libp2p/protocols/connectivity/autonatv2/types.html#DialDataRequest">types: object DialDataRequest</a></li>
          </ul></dd>
<dt><a name="DialDataResponse" href="#DialDataResponse"><span>DialDataResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object DialDataResponse" href="libp2p/protocols/connectivity/autonatv2/types.html#DialDataResponse">types: object DialDataResponse</a></li>
          </ul></dd>
<dt><a name="DialDataResponseLpSize" href="#DialDataResponseLpSize"><span>DialDataResponseLpSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const DialDataResponseLpSize" href="libp2p/protocols/connectivity/autonatv2/types.html#DialDataResponseLpSize">types: const DialDataResponseLpSize</a></li>
          </ul></dd>
<dt><a name="Dialer" href="#Dialer"><span>Dialer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dialer: type Dialer" href="libp2p/dialer.html#Dialer">dialer: type Dialer</a></li>
          </ul></dd>
<dt><a name="DialError" href="#DialError"><span>DialError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: ResponseStatus.DialError" href="libp2p/protocols/connectivity/autonat/types.html#DialError">types: ResponseStatus.DialError</a></li>
          </ul></dd>
<dt><a name="DialFailedError" href="#DialFailedError"><span>DialFailedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: object DialFailedError" href="libp2p/dial.html#DialFailedError">dial: object DialFailedError</a></li>
          </ul></dd>
<dt><a name="dialPeerV1" href="#dialPeerV1"><span>dialPeerV1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc dialPeerV1(cl: RelayClient; conn: Connection; dstPeerId: PeerId;
           dstAddrs: seq[MultiAddress]): InternalRaisesFuture[Connection,
    (CancelledError, RelayV1DialError)]" href="libp2p/protocols/connectivity/relay/client.html#dialPeerV1%2CRelayClient%2CConnection%2CPeerId%2Cseq%5BMultiAddress%5D">client: proc dialPeerV1(cl: RelayClient; conn: Connection; dstPeerId: PeerId;
           dstAddrs: seq[MultiAddress]): InternalRaisesFuture[Connection,
    (CancelledError, RelayV1DialError)]</a></li>
          </ul></dd>
<dt><a name="dialPeerV2" href="#dialPeerV2"><span>dialPeerV2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc dialPeerV2(cl: RelayClient; conn: RelayConnection; dstPeerId: PeerId;
           dstAddrs: seq[MultiAddress]): InternalRaisesFuture[Connection,
    (RelayV2DialError, CancelledError)]" href="libp2p/protocols/connectivity/relay/client.html#dialPeerV2%2CRelayClient%2CRelayConnection%2CPeerId%2Cseq%5BMultiAddress%5D">client: proc dialPeerV2(cl: RelayClient; conn: RelayConnection; dstPeerId: PeerId;
           dstAddrs: seq[MultiAddress]): InternalRaisesFuture[Connection,
    (RelayV2DialError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="DialRefused" href="#DialRefused"><span>DialRefused:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: ResponseStatus.DialRefused" href="libp2p/protocols/connectivity/autonat/types.html#DialRefused">types: ResponseStatus.DialRefused</a></li>
          </ul></dd>
<dt><a name="DialRequest" href="#DialRequest"><span>DialRequest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object DialRequest" href="libp2p/protocols/connectivity/autonatv2/types.html#DialRequest">types: object DialRequest</a></li>
          </ul></dd>
<dt><a name="DialResponse" href="#DialResponse"><span>DialResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: MsgType.DialResponse" href="libp2p/protocols/connectivity/autonat/types.html#DialResponse">types: MsgType.DialResponse</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: object DialResponse" href="libp2p/protocols/connectivity/autonatv2/types.html#DialResponse">types: object DialResponse</a></li>
          </ul></dd>
<dt><a name="DialStatus" href="#DialStatus"><span>DialStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: enum DialStatus" href="libp2p/protocols/connectivity/autonatv2/types.html#DialStatus">types: enum DialStatus</a></li>
          </ul></dd>
<dt><a name="digest" href="#digest"><span>digest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: proc digest(mhtype: typedesc[MultiHash]; mcodec: MultiCodec; data: openArray[byte]): MhResult[
    MultiHash]" href="libp2p/multihash.html#digest%2Ctypedesc%5BMultiHash%5D%2CMultiCodec%2CopenArray%5Bbyte%5D">multihash: proc digest(mhtype: typedesc[MultiHash]; mcodec: MultiCodec; data: openArray[byte]): MhResult[
    MultiHash]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc digest(mhtype: typedesc[MultiHash]; hashname: string; data: openArray[byte]): MhResult[
    MultiHash]" href="libp2p/multihash.html#digest%2Ctypedesc%5BMultiHash%5D%2Cstring%2CopenArray%5Bbyte%5D">multihash: proc digest(mhtype: typedesc[MultiHash]; hashname: string; data: openArray[byte]): MhResult[
    MultiHash]</a></li>
          </ul></dd>
<dt><a name="DigestSheme" href="#DigestSheme"><span>DigestSheme:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: enum DigestSheme" href="libp2p/crypto/crypto.html#DigestSheme">crypto: enum DigestSheme</a></li>
          </ul></dd>
<dt><a name="digestSize" href="#digestSize"><span>digestSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: proc digestSize(codec: MultiCodec): MhResult[int]" href="libp2p/multihash.html#digestSize%2CMultiCodec">multihash: proc digestSize(codec: MultiCodec): MhResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc digestSize(hashname: string): MhResult[int]" href="libp2p/multihash.html#digestSize%2Cstring">multihash: proc digestSize(hashname: string): MhResult[int]</a></li>
          </ul></dd>
<dt><a name="Direction" href="#Direction"><span>Direction:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: enum Direction" href="libp2p/stream/lpstream.html#Direction">lpstream: enum Direction</a></li>
          </ul></dd>
<dt><a name="disconnect" href="#disconnect"><span>disconnect:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: proc disconnect(s: Switch; peerId: PeerId): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/switch.html#disconnect%2CSwitch%2CPeerId">switch: proc disconnect(s: Switch; peerId: PeerId): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="disconnectIfBadScorePeer" href="#disconnectIfBadScorePeer"><span>disconnectIfBadScorePeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc disconnectIfBadScorePeer(g: GossipSub; peer: PubSubPeer; score: float64)" href="libp2p/protocols/pubsub/gossipsub/scoring.html#disconnectIfBadScorePeer%2CGossipSub%2CPubSubPeer%2Cfloat64">scoring: proc disconnectIfBadScorePeer(g: GossipSub; peer: PubSubPeer; score: float64)</a></li>
          </ul></dd>
<dt><a name="disconnectPeer" href="#disconnectPeer"><span>disconnectPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc disconnectPeer(g: GossipSub; peer: PubSubPeer): InternalRaisesFuture[void, void]" href="libp2p/protocols/pubsub/gossipsub/scoring.html#disconnectPeer%2CGossipSub%2CPubSubPeer">scoring: proc disconnectPeer(g: GossipSub; peer: PubSubPeer): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="Discover" href="#Discover"><span>Discover:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object Discover" href="libp2p/protocols/rendezvous/protobuf.html#Discover">protobuf: object Discover</a></li>
          </ul></dd>
<dt><a name="discover" href="#discover"><span>discover:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc discover[E](rdv: GenericRendezVous[E]; conn: Connection; d: Discover): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]" href="libp2p/protocols/rendezvous/rendezvous.html#discover%2CGenericRendezVous%5BE%5D%2CConnection%2CDiscover">rendezvous: proc discover[E](rdv: GenericRendezVous[E]; conn: Connection; d: Discover): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="DiscoverResponse" href="#DiscoverResponse"><span>DiscoverResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object DiscoverResponse" href="libp2p/protocols/rendezvous/protobuf.html#DiscoverResponse">protobuf: object DiscoverResponse</a></li>
          </ul></dd>
<dt><a name="dispatchPutVal" href="#dispatchPutVal"><span>dispatchPutVal:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="put: proc dispatchPutVal(switch: Switch; peer: PeerId; key: Key; value: seq[byte]): InternalRaisesFuture[
    void, (CancelledError, DialFailedError, LPStreamError)]" href="libp2p/protocols/kademlia/put.html#dispatchPutVal%2CSwitch%2CPeerId%2CKey%2Cseq%5Bbyte%5D">put: proc dispatchPutVal(switch: Switch; peer: PeerId; key: Key; value: seq[byte]): InternalRaisesFuture[
    void, (CancelledError, DialFailedError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="DNS" href="#DNS"><span>DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const DNS" href="libp2p/multiaddress.html#DNS">multiaddress: const DNS</a></li>
          </ul></dd>
<dt><a name="DNS4" href="#DNS4"><span>DNS4:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const DNS4" href="libp2p/multiaddress.html#DNS4">multiaddress: const DNS4</a></li>
          </ul></dd>
<dt><a name="DNS6" href="#DNS6"><span>DNS6:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const DNS6" href="libp2p/multiaddress.html#DNS6">multiaddress: const DNS6</a></li>
          </ul></dd>
<dt><a name="DNSADDR" href="#DNSADDR"><span>DNSADDR:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const DNSADDR" href="libp2p/multiaddress.html#DNSADDR">multiaddress: const DNSADDR</a></li>
          </ul></dd>
<dt><a name="DNSANY" href="#DNSANY"><span>DNSANY:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const DNSANY" href="libp2p/multiaddress.html#DNSANY">multiaddress: const DNSANY</a></li>
          </ul></dd>
<dt><a name="DNS_OR_IP" href="#DNS_OR_IP"><span>DNS_OR_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const DNS_OR_IP" href="libp2p/multiaddress.html#DNS_OR_IP">multiaddress: const DNS_OR_IP</a></li>
          </ul></dd>
<dt><a name="Domain" href="#Domain"><span>Domain:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: type Domain" href="libp2p/autotls/acme/api.html#Domain">api: type Domain</a></li>
          </ul></dd>
<dt><a name="DropConn" href="#DropConn"><span>DropConn:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type DropConn" href="libp2p/protocols/pubsub/pubsubpeer.html#DropConn">pubsubpeer: type DropConn</a></li>
          </ul></dd>
<dt><a name="dropFanoutPeers" href="#dropFanoutPeers"><span>dropFanoutPeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc dropFanoutPeers(g: GossipSub)" href="libp2p/protocols/pubsub/gossipsub/behavior.html#dropFanoutPeers%2CGossipSub">behavior: proc dropFanoutPeers(g: GossipSub)</a></li>
          </ul></dd>
<dt><a name="dropPeer" href="#dropPeer"><span>dropPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc dropPeer(c: ConnManager; peerId: PeerId): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/connmanager.html#dropPeer%2CConnManager%2CPeerId">connmanager: proc dropPeer(c: ConnManager; peerId: PeerId): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="dummyPrivateProc" href="#dummyPrivateProc"><span>dummyPrivateProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="libp2p: proc dummyPrivateProc()" href="libp2p.html#dummyPrivateProc">libp2p: proc dummyPrivateProc()</a></li>
          </ul></dd>
<dt><a name="EcCurveKind" href="#EcCurveKind"><span>EcCurveKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: enum EcCurveKind" href="libp2p/crypto/ecnist.html#EcCurveKind">ecnist: enum EcCurveKind</a></li>
          </ul></dd>
<dt><a name="ECDHEScheme" href="#ECDHEScheme"><span>ECDHEScheme:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: type ECDHEScheme" href="libp2p/crypto/ecnist.html#ECDHEScheme">ecnist: type ECDHEScheme</a></li>
          </ul></dd>
<dt><a name="ECDSA" href="#ECDSA"><span>ECDSA:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: PKScheme.ECDSA" href="libp2p/crypto/crypto.html#ECDSA">crypto: PKScheme.ECDSA</a></li>
          </ul></dd>
<dt><a name="EcError" href="#EcError"><span>EcError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: enum EcError" href="libp2p/crypto/ecnist.html#EcError">ecnist: enum EcError</a></li>
          </ul></dd>
<dt><a name="EcKeyGenError" href="#EcKeyGenError"><span>EcKeyGenError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcError.EcKeyGenError" href="libp2p/crypto/ecnist.html#EcKeyGenError">ecnist: EcError.EcKeyGenError</a></li>
          </ul></dd>
<dt><a name="EcKeyIncorrectError" href="#EcKeyIncorrectError"><span>EcKeyIncorrectError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcError.EcKeyIncorrectError" href="libp2p/crypto/ecnist.html#EcKeyIncorrectError">ecnist: EcError.EcKeyIncorrectError</a></li>
          </ul></dd>
<dt><a name="EcKeyPair" href="#EcKeyPair"><span>EcKeyPair:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: object EcKeyPair" href="libp2p/crypto/ecnist.html#EcKeyPair">ecnist: object EcKeyPair</a></li>
          </ul></dd>
<dt><a name="EcPKI" href="#EcPKI"><span>EcPKI:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: type EcPKI" href="libp2p/crypto/ecnist.html#EcPKI">ecnist: type EcPKI</a></li>
          </ul></dd>
<dt><a name="EcPrivateKey" href="#EcPrivateKey"><span>EcPrivateKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: type EcPrivateKey" href="libp2p/crypto/ecnist.html#EcPrivateKey">ecnist: type EcPrivateKey</a></li>
          </ul></dd>
<dt><a name="EcPublicKey" href="#EcPublicKey"><span>EcPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: type EcPublicKey" href="libp2p/crypto/ecnist.html#EcPublicKey">ecnist: type EcPublicKey</a></li>
          </ul></dd>
<dt><a name="EcPublicKeyError" href="#EcPublicKeyError"><span>EcPublicKeyError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcError.EcPublicKeyError" href="libp2p/crypto/ecnist.html#EcPublicKeyError">ecnist: EcError.EcPublicKeyError</a></li>
          </ul></dd>
<dt><a name="EcResult" href="#EcResult"><span>EcResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: type EcResult" href="libp2p/crypto/ecnist.html#EcResult">ecnist: type EcResult</a></li>
          </ul></dd>
<dt><a name="EcRngError" href="#EcRngError"><span>EcRngError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcError.EcRngError" href="libp2p/crypto/ecnist.html#EcRngError">ecnist: EcError.EcRngError</a></li>
          </ul></dd>
<dt><a name="EcSignature" href="#EcSignature"><span>EcSignature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: type EcSignature" href="libp2p/crypto/ecnist.html#EcSignature">ecnist: type EcSignature</a></li>
          </ul></dd>
<dt><a name="EcSignatureError" href="#EcSignatureError"><span>EcSignatureError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcError.EcSignatureError" href="libp2p/crypto/ecnist.html#EcSignatureError">ecnist: EcError.EcSignatureError</a></li>
          </ul></dd>
<dt><a name="EcSupportedCurvesCint" href="#EcSupportedCurvesCint"><span>EcSupportedCurvesCint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const EcSupportedCurvesCint" href="libp2p/crypto/ecnist.html#EcSupportedCurvesCint">ecnist: const EcSupportedCurvesCint</a></li>
          </ul></dd>
<dt><a name="Ed25519" href="#Ed25519"><span>Ed25519:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: PKScheme.Ed25519" href="libp2p/crypto/crypto.html#Ed25519">crypto: PKScheme.Ed25519</a></li>
          </ul></dd>
<dt><a name="EdError" href="#EdError"><span>EdError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: enum EdError" href="libp2p/crypto/ed25519/ed25519.html#EdError">ed25519: enum EdError</a></li>
          </ul></dd>
<dt><a name="EdIncorrectError" href="#EdIncorrectError"><span>EdIncorrectError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: EdError.EdIncorrectError" href="libp2p/crypto/ed25519/ed25519.html#EdIncorrectError">ed25519: EdError.EdIncorrectError</a></li>
          </ul></dd>
<dt><a name="EdKeyPair" href="#EdKeyPair"><span>EdKeyPair:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: object EdKeyPair" href="libp2p/crypto/ed25519/ed25519.html#EdKeyPair">ed25519: object EdKeyPair</a></li>
          </ul></dd>
<dt><a name="EdPrivateKey" href="#EdPrivateKey"><span>EdPrivateKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: object EdPrivateKey" href="libp2p/crypto/ed25519/ed25519.html#EdPrivateKey">ed25519: object EdPrivateKey</a></li>
          </ul></dd>
<dt><a name="EdPrivateKeySize" href="#EdPrivateKeySize"><span>EdPrivateKeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: const EdPrivateKeySize" href="libp2p/crypto/ed25519/ed25519.html#EdPrivateKeySize">ed25519: const EdPrivateKeySize</a></li>
          </ul></dd>
<dt><a name="EdPublicKey" href="#EdPublicKey"><span>EdPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: object EdPublicKey" href="libp2p/crypto/ed25519/ed25519.html#EdPublicKey">ed25519: object EdPublicKey</a></li>
          </ul></dd>
<dt><a name="EdPublicKeySize" href="#EdPublicKeySize"><span>EdPublicKeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: const EdPublicKeySize" href="libp2p/crypto/ed25519/ed25519.html#EdPublicKeySize">ed25519: const EdPublicKeySize</a></li>
          </ul></dd>
<dt><a name="EdSignature" href="#EdSignature"><span>EdSignature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: object EdSignature" href="libp2p/crypto/ed25519/ed25519.html#EdSignature">ed25519: object EdSignature</a></li>
          </ul></dd>
<dt><a name="EdSignatureSize" href="#EdSignatureSize"><span>EdSignatureSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ed25519: const EdSignatureSize" href="libp2p/crypto/ed25519/ed25519.html#EdSignatureSize">ed25519: const EdSignatureSize</a></li>
          </ul></dd>
<dt><a name="encode" href="#encode"><span>encode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc encode(mbtype: typedesc[MultiBase]; encoding: string; ma: MultiAddress): string" href="libp2p/multiaddress.html#encode%2Ctypedesc%5BMultiBase%5D%2Cstring%2CMultiAddress">multiaddress: proc encode(mbtype: typedesc[MultiBase]; encoding: string; ma: MultiAddress): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multibase: proc encode(mbtype: typedesc[MultiBase]; encoding: string; inbytes: openArray[byte]): Result[
    string, string]" href="libp2p/multibase.html#encode%2Ctypedesc%5BMultiBase%5D%2Cstring%2CopenArray%5Bbyte%5D">multibase: proc encode(mbtype: typedesc[MultiBase]; encoding: string; inbytes: openArray[byte]): Result[
    string, string]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multibase: proc encode(mbtype: typedesc[MultiBase]; encoding: string; inbytes: openArray[byte];
       outbytes: var openArray[char]; outlen: var int): MultiBaseStatus" href="libp2p/multibase.html#encode%2Ctypedesc%5BMultiBase%5D%2Cstring%2CopenArray%5Bbyte%5D%2CopenArray%5Bchar%5D%2Cint">multibase: proc encode(mbtype: typedesc[MultiBase]; encoding: string; inbytes: openArray[byte];
       outbytes: var openArray[char]; outlen: var int): MultiBaseStatus</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc encode(mbtype: typedesc[MultiBase]; encoding: string; mh: MultiHash): string" href="libp2p/multihash.html#encode%2Ctypedesc%5BMultiBase%5D%2Cstring%2CMultiHash">multihash: proc encode(mbtype: typedesc[MultiBase]; encoding: string; mh: MultiHash): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(d: AutonatDial): ProtoBuffer" href="libp2p/protocols/connectivity/autonat/types.html#encode%2CAutonatDial">types: proc encode(d: AutonatDial): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(r: AutonatDialResponse): ProtoBuffer" href="libp2p/protocols/connectivity/autonat/types.html#encode%2CAutonatDialResponse">types: proc encode(r: AutonatDialResponse): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(msg: AutonatMsg): ProtoBuffer" href="libp2p/protocols/connectivity/autonat/types.html#encode%2CAutonatMsg">types: proc encode(msg: AutonatMsg): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(msg: AutonatV2Msg): ProtoBuffer" href="libp2p/protocols/connectivity/autonatv2/types.html#encode%2CAutonatV2Msg">types: proc encode(msg: AutonatV2Msg): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(dialBack: DialBack): ProtoBuffer" href="libp2p/protocols/connectivity/autonatv2/types.html#encode%2CDialBack">types: proc encode(dialBack: DialBack): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(dialBackResp: DialBackResponse): ProtoBuffer" href="libp2p/protocols/connectivity/autonatv2/types.html#encode%2CDialBackResponse">types: proc encode(dialBackResp: DialBackResponse): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(dialDataReq: DialDataRequest): ProtoBuffer" href="libp2p/protocols/connectivity/autonatv2/types.html#encode%2CDialDataRequest">types: proc encode(dialDataReq: DialDataRequest): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(dialDataResp: DialDataResponse): ProtoBuffer" href="libp2p/protocols/connectivity/autonatv2/types.html#encode%2CDialDataResponse">types: proc encode(dialDataResp: DialDataResponse): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(dialReq: DialRequest): ProtoBuffer" href="libp2p/protocols/connectivity/autonatv2/types.html#encode%2CDialRequest">types: proc encode(dialReq: DialRequest): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc encode(dialResp: DialResponse): ProtoBuffer" href="libp2p/protocols/connectivity/autonatv2/types.html#encode%2CDialResponse">types: proc encode(dialResp: DialResponse): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc encode(msg: HopMessage): ProtoBuffer" href="libp2p/protocols/connectivity/relay/messages.html#encode%2CHopMessage">messages: proc encode(msg: HopMessage): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc encode(msg: RelayMessage): ProtoBuffer" href="libp2p/protocols/connectivity/relay/messages.html#encode%2CRelayMessage">messages: proc encode(msg: RelayMessage): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc encode(msg: StopMessage): ProtoBuffer" href="libp2p/protocols/connectivity/relay/messages.html#encode%2CStopMessage">messages: proc encode(msg: StopMessage): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc encode(v: Voucher): seq[byte]" href="libp2p/protocols/connectivity/relay/messages.html#encode%2CVoucher">messages: proc encode(v: Voucher): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(msg: Message): ProtoBuffer" href="libp2p/protocols/kademlia/protobuf.html#encode%2CMessage">protobuf: proc encode(msg: Message): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(peer: Peer): ProtoBuffer" href="libp2p/protocols/kademlia/protobuf.html#encode%2CPeer">protobuf: proc encode(peer: Peer): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(record: Record): ProtoBuffer" href="libp2p/protocols/kademlia/protobuf.html#encode%2CRecord">protobuf: proc encode(record: Record): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(c: Cookie): ProtoBuffer" href="libp2p/protocols/rendezvous/protobuf.html#encode%2CCookie">protobuf: proc encode(c: Cookie): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(d: Discover): ProtoBuffer" href="libp2p/protocols/rendezvous/protobuf.html#encode%2CDiscover">protobuf: proc encode(d: Discover): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(dr: DiscoverResponse): ProtoBuffer" href="libp2p/protocols/rendezvous/protobuf.html#encode%2CDiscoverResponse">protobuf: proc encode(dr: DiscoverResponse): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(msg: Message): ProtoBuffer" href="libp2p/protocols/rendezvous/protobuf.html#encode%2CMessage">protobuf: proc encode(msg: Message): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(r: Register): ProtoBuffer" href="libp2p/protocols/rendezvous/protobuf.html#encode%2CRegister">protobuf: proc encode(r: Register): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(rr: RegisterResponse): ProtoBuffer" href="libp2p/protocols/rendezvous/protobuf.html#encode%2CRegisterResponse">protobuf: proc encode(rr: RegisterResponse): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc encode(u: Unregister): ProtoBuffer" href="libp2p/protocols/rendezvous/protobuf.html#encode%2CUnregister">protobuf: proc encode(u: Unregister): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routing_record: proc encode(record: PeerRecord): seq[byte]" href="libp2p/routing_record.html#encode%2CPeerRecord">routing_record: proc encode(record: PeerRecord): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc encode(env: Envelope): Result[seq[byte], CryptoError]" href="libp2p/signed_envelope.html#encode%2CEnvelope">signed_envelope: proc encode(env: Envelope): Result[seq[byte], CryptoError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc encode[T](msg: SignedPayload[T]): Result[seq[byte], CryptoError]" href="libp2p/signed_envelope.html#encode%2CSignedPayload%5BT%5D">signed_envelope: proc encode[T](msg: SignedPayload[T]): Result[seq[byte], CryptoError]</a></li>
          </ul></dd>
<dt><a name="encodedLength" href="#encodedLength"><span>encodedLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multibase: proc encodedLength(mbtype: typedesc[MultiBase]; encoding: string; length: int): int" href="libp2p/multibase.html#encodedLength%2Ctypedesc%5BMultiBase%5D%2Cstring%2Cint">multibase: proc encodedLength(mbtype: typedesc[MultiBase]; encoding: string; length: int): int</a></li>
          </ul></dd>
<dt><a name="encodeMessage" href="#encodeMessage"><span>encodeMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc encodeMessage(msg: Message; anonymize: bool): seq[byte]" href="libp2p/protocols/pubsub/rpc/protobuf.html#encodeMessage%2CMessage%2Cbool">protobuf: proc encodeMessage(msg: Message; anonymize: bool): seq[byte]</a></li>
          </ul></dd>
<dt><a name="encodeRpcMsg" href="#encodeRpcMsg"><span>encodeRpcMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc encodeRpcMsg(msg: RPCMsg; anonymize: bool): seq[byte]" href="libp2p/protocols/pubsub/rpc/protobuf.html#encodeRpcMsg%2CRPCMsg%2Cbool">protobuf: proc encodeRpcMsg(msg: RPCMsg; anonymize: bool): seq[byte]</a></li>
          </ul></dd>
<dt><a name="encodeVarint" href="#encodeVarint"><span>encodeVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: proc encodeVarint(vtype: typedesc[LP]; value: LPSomeVarint): VarintResult[seq[byte]]" href="libp2p/varint.html#encodeVarint%2Ctypedesc%5BLP%5D%2CLPSomeVarint">varint: proc encodeVarint(vtype: typedesc[LP]; value: LPSomeVarint): VarintResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="varint: proc encodeVarint(vtype: typedesc[PB]; value: PBSomeVarint): VarintResult[seq[byte]]" href="libp2p/varint.html#encodeVarint%2Ctypedesc%5BPB%5D%2CPBSomeVarint">varint: proc encodeVarint(vtype: typedesc[PB]; value: PBSomeVarint): VarintResult[seq[byte]]</a></li>
          </ul></dd>
<dt><a name="EncodingFormat" href="#EncodingFormat"><span>EncodingFormat:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: enum EncodingFormat" href="libp2p/transports/tls/certificate.html#EncodingFormat">certificate: enum EncodingFormat</a></li>
          </ul></dd>
<dt><a name="encrypt" href="#encrypt"><span>encrypt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: proc encrypt(_: type[ChaChaPoly]; key: ChaChaPolyKey; nonce: ChaChaPolyNonce;
        tag: var ChaChaPolyTag; data: var openArray[byte]; aad: openArray[byte])" href="libp2p/crypto/chacha20poly1305.html#encrypt%2Ctype%5BChaChaPoly%5D%2CChaChaPolyKey%2CChaChaPolyNonce%2CChaChaPolyTag%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D">chacha20poly1305: proc encrypt(_: type[ChaChaPoly]; key: ChaChaPolyKey; nonce: ChaChaPolyNonce;
        tag: var ChaChaPolyTag; data: var openArray[byte]; aad: openArray[byte])</a></li>
          </ul></dd>
<dt><a name="EndGroup" href="#EndGroup"><span>EndGroup:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFieldKind.EndGroup" href="libp2p/protobuf/minprotobuf.html#EndGroup">minprotobuf: ProtoFieldKind.EndGroup</a></li>
          </ul></dd>
<dt><a name="EntryRecord" href="#EntryRecord"><span>EntryRecord:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object EntryRecord" href="libp2p/protocols/kademlia/types.html#EntryRecord">types: object EntryRecord</a></li>
          </ul></dd>
<dt><a name="EntrySelector" href="#EntrySelector"><span>EntrySelector:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type EntrySelector" href="libp2p/protocols/kademlia/types.html#EntrySelector">types: type EntrySelector</a></li>
          </ul></dd>
<dt><a name="EntryValidator" href="#EntryValidator"><span>EntryValidator:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type EntryValidator" href="libp2p/protocols/kademlia/types.html#EntryValidator">types: type EntryValidator</a></li>
          </ul></dd>
<dt><a name="Envelope" href="#Envelope"><span>Envelope:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: object Envelope" href="libp2p/signed_envelope.html#Envelope">signed_envelope: object Envelope</a></li>
          </ul></dd>
<dt><a name="EnvelopeError" href="#EnvelopeError"><span>EnvelopeError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: enum EnvelopeError" href="libp2p/signed_envelope.html#EnvelopeError">signed_envelope: enum EnvelopeError</a></li>
          </ul></dd>
<dt><a name="EnvelopeFieldMissing" href="#EnvelopeFieldMissing"><span>EnvelopeFieldMissing:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: EnvelopeError.EnvelopeFieldMissing" href="libp2p/signed_envelope.html#EnvelopeFieldMissing">signed_envelope: EnvelopeError.EnvelopeFieldMissing</a></li>
          </ul></dd>
<dt><a name="EnvelopeInvalidProtobuf" href="#EnvelopeInvalidProtobuf"><span>EnvelopeInvalidProtobuf:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: EnvelopeError.EnvelopeInvalidProtobuf" href="libp2p/signed_envelope.html#EnvelopeInvalidProtobuf">signed_envelope: EnvelopeError.EnvelopeInvalidProtobuf</a></li>
          </ul></dd>
<dt><a name="EnvelopeInvalidSignature" href="#EnvelopeInvalidSignature"><span>EnvelopeInvalidSignature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: EnvelopeError.EnvelopeInvalidSignature" href="libp2p/signed_envelope.html#EnvelopeInvalidSignature">signed_envelope: EnvelopeError.EnvelopeInvalidSignature</a></li>
          </ul></dd>
<dt><a name="EnvelopeWrongType" href="#EnvelopeWrongType"><span>EnvelopeWrongType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: EnvelopeError.EnvelopeWrongType" href="libp2p/signed_envelope.html#EnvelopeWrongType">signed_envelope: EnvelopeError.EnvelopeWrongType</a></li>
          </ul></dd>
<dt><a name="Eof" href="#Eof"><span>Eof:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: const Eof" href="libp2p/stream/lpstream.html#Eof">lpstream: const Eof</a></li>
          </ul></dd>
<dt><a name="ephemeral" href="#ephemeral"><span>ephemeral:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: proc ephemeral(scheme: ECDHEScheme; rng: var HmacDrbgContext): EcResult[EcKeyPair]" href="libp2p/crypto/ecnist.html#ephemeral%2CEcCurveKind%2CHmacDrbgContext">ecnist: proc ephemeral(scheme: ECDHEScheme; rng: var HmacDrbgContext): EcResult[EcKeyPair]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc ephemeral(scheme: string; rng: var HmacDrbgContext): EcResult[EcKeyPair]" href="libp2p/crypto/ecnist.html#ephemeral%2Cstring%2CHmacDrbgContext">ecnist: proc ephemeral(scheme: string; rng: var HmacDrbgContext): EcResult[EcKeyPair]</a></li>
          </ul></dd>
<dt><a name="Eq" href="#Eq"><span>Eq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MaPatternOp.Eq" href="libp2p/multiaddress.html#Eq">multiaddress: MaPatternOp.Eq</a></li>
          </ul></dd>
<dt><a name="exclIfIt" href="#exclIfIt"><span>exclIfIt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: template exclIfIt[T](set: var HashSet[T]; condition: untyped)" href="libp2p/utility.html#exclIfIt.t%2CHashSet%5BT%5D%2Cuntyped">utility: template exclIfIt[T](set: var HashSet[T]; condition: untyped)</a></li>
          </ul></dd>
<dt><a name="expandAddrs" href="#expandAddrs"><span>expandAddrs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: proc expandAddrs(p: PeerInfo): InternalRaisesFuture[seq[MultiAddress],
    (CancelledError,)]" href="libp2p/peerinfo.html#expandAddrs%2CPeerInfo">peerinfo: proc expandAddrs(p: PeerInfo): InternalRaisesFuture[seq[MultiAddress],
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="expandItIMPL" href="#expandItIMPL"><span>expandItIMPL:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: template expandItIMPL(record: auto; it_name: static string; it: IdentifyInfo)" href="libp2p/protocols/identify.html#expandItIMPL.t%2Cauto%2Cstaticstring%2CIdentifyInfo">identify: template expandItIMPL(record: auto; it_name: static string; it: IdentifyInfo)</a></li>
          </ul></dd>
<dt><a name="expectConnection" href="#expectConnection"><span>expectConnection:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc expectConnection(c: ConnManager; p: PeerId; dir: Direction): InternalRaisesFuture[
    Muxer, (AlreadyExpectingConnectionError, CancelledError)]" href="libp2p/connmanager.html#expectConnection%2CConnManager%2CPeerId%2CDirection">connmanager: proc expectConnection(c: ConnManager; p: PeerId; dir: Direction): InternalRaisesFuture[
    Muxer, (AlreadyExpectingConnectionError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="expire" href="#expire"><span>expire:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="timedcache: proc expire(t: var TimedCache; now: Moment = Moment.now())" href="libp2p/protocols/pubsub/timedcache.html#expire%2CTimedCache%2CMoment">timedcache: proc expire(t: var TimedCache; now: Moment = Moment.now())</a></li>
          </ul></dd>
<dt><a name="ExponentialMovingAverage" href="#ExponentialMovingAverage"><span>ExponentialMovingAverage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bandwidth: type ExponentialMovingAverage" href="libp2p/protocols/pubsub/bandwidth.html#ExponentialMovingAverage">bandwidth: type ExponentialMovingAverage</a></li>
          </ul></dd>
<dt><a name="extend" href="#extend"><span>extend:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc extend[T: Asn1Buffer | Asn1Composite](abc: var T; length: int)" href="libp2p/crypto/minasn1.html#extend%2CT%2Cint">minasn1: proc extend[T: Asn1Buffer | Asn1Composite](abc: var T; length: int)</a></li>
          </ul></dd>
<dt><a name="extractPublicKey" href="#extractPublicKey"><span>extractPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: proc extractPublicKey(pid: PeerId; pubkey: var PublicKey): bool" href="libp2p/peerid.html#extractPublicKey%2CPeerId%2CPublicKey">peerid: proc extractPublicKey(pid: PeerId; pubkey: var PublicKey): bool</a></li>
          </ul></dd>
<dt><a name="Fe" href="#Fe"><span>Fe:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: type Fe" href="libp2p/crypto/ed25519/constants.html#Fe">constants: type Fe</a></li>
          </ul></dd>
<dt><a name="filterIt" href="#filterIt"><span>filterIt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: template filterIt[T](set: HashSet[T]; condition: untyped): HashSet[T]" href="libp2p/utility.html#filterIt.t%2CHashSet%5BT%5D%2Cuntyped">utility: template filterIt[T](set: HashSet[T]; condition: untyped): HashSet[T]</a></li>
          </ul></dd>
<dt><a name="find" href="#find"><span>find:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc find(pr: ProviderRecords; record: ProviderRecord): int" href="libp2p/protocols/kademlia/provider.html#find%2CProviderRecords%2CProviderRecord">provider: proc find(pr: ProviderRecords; record: ProviderRecord): int</a></li>
          </ul></dd>
<dt><a name="findClosest" href="#findClosest"><span>findClosest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routingtable: proc findClosest(rtable: RoutingTable; targetId: Key; count: int): seq[Key]" href="libp2p/protocols/kademlia/routingtable.html#findClosest%2CRoutingTable%2CKey%2Cint">routingtable: proc findClosest(rtable: RoutingTable; targetId: Key; count: int): seq[Key]</a></li>
          </ul></dd>
<dt><a name="findClosestPeerIds" href="#findClosestPeerIds"><span>findClosestPeerIds:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routingtable: proc findClosestPeerIds(rtable: RoutingTable; targetId: Key; count: int): seq[PeerId]" href="libp2p/protocols/kademlia/routingtable.html#findClosestPeerIds%2CRoutingTable%2CKey%2Cint">routingtable: proc findClosestPeerIds(rtable: RoutingTable; targetId: Key; count: int): seq[PeerId]</a></li>
          </ul></dd>
<dt><a name="findClosestPeers" href="#findClosestPeers"><span>findClosestPeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="find: proc findClosestPeers(kad: KadDHT; target: Key): seq[Peer]" href="libp2p/protocols/kademlia/find.html#findClosestPeers%2CKadDHT%2CKey">find: proc findClosestPeers(kad: KadDHT; target: Key): seq[Peer]</a></li>
          </ul></dd>
<dt><a name="findNode" href="#findNode"><span>findNode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="find: proc findNode(kad: KadDHT; targetId: Key): InternalRaisesFuture[seq[PeerId],
    (CancelledError,)]" href="libp2p/protocols/kademlia/find.html#findNode%2CKadDHT%2CKey">find: proc findNode(kad: KadDHT; targetId: Key): InternalRaisesFuture[seq[PeerId],
    (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: MessageType.findNode" href="libp2p/protocols/kademlia/protobuf.html#findNode">protobuf: MessageType.findNode</a></li>
          </ul></dd>
<dt><a name="findObservedIPAddr" href="#findObservedIPAddr"><span>findObservedIPAddr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="server: proc findObservedIPAddr(conn: Connection; req: DialRequest): InternalRaisesFuture[
    Opt[MultiAddress], (CancelledError, LPStreamError)]" href="libp2p/protocols/connectivity/autonatv2/server.html#findObservedIPAddr%2CConnection%2CDialRequest">server: proc findObservedIPAddr(conn: Connection; req: DialRequest): InternalRaisesFuture[
    Opt[MultiAddress], (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="findPeer" href="#findPeer"><span>findPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="find: proc findPeer(kad: KadDHT; peer: PeerId): InternalRaisesFuture[
    Result[PeerInfo, string], (CancelledError,)]" href="libp2p/protocols/kademlia/find.html#findPeer%2CKadDHT%2CPeerId">find: proc findPeer(kad: KadDHT; peer: PeerId): InternalRaisesFuture[
    Result[PeerInfo, string], (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="finish" href="#finish"><span>finish:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc finish[T: Asn1Buffer | Asn1Composite](abc: var T)" href="libp2p/crypto/minasn1.html#finish%2CT">minasn1: proc finish[T: Asn1Buffer | Asn1Composite](abc: var T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc finish(pb: var ProtoBuffer)" href="libp2p/protobuf/minprotobuf.html#finish%2CProtoBuffer">minprotobuf: proc finish(pb: var ProtoBuffer)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: proc finish(vb: var VBuffer)" href="libp2p/vbuffer.html#finish%2CVBuffer">vbuffer: proc finish(vb: var VBuffer)</a></li>
          </ul></dd>
<dt><a name="firstSeen" href="#firstSeen"><span>firstSeen:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: proc firstSeen(f: FloodSub; saltedId: SaltedId): Moment" href="libp2p/protocols/pubsub/floodsub.html#firstSeen%2CFloodSub%2CSaltedId">floodsub: proc firstSeen(f: FloodSub; saltedId: SaltedId): Moment</a></li>
          </ul></dd>
<dt><a name="Fixed" href="#Fixed"><span>Fixed:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MAKind.Fixed" href="libp2p/multiaddress.html#Fixed">multiaddress: MAKind.Fixed</a></li>
          </ul></dd>
<dt><a name="Fixed32" href="#Fixed32"><span>Fixed32:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFieldKind.Fixed32" href="libp2p/protobuf/minprotobuf.html#Fixed32">minprotobuf: ProtoFieldKind.Fixed32</a></li>
          </ul></dd>
<dt><a name="Fixed64" href="#Fixed64"><span>Fixed64:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFieldKind.Fixed64" href="libp2p/protobuf/minprotobuf.html#Fixed64">minprotobuf: ProtoFieldKind.Fixed64</a></li>
          </ul></dd>
<dt><a name="FloodSub" href="#FloodSub"><span>FloodSub:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: type FloodSub" href="libp2p/protocols/pubsub/floodsub.html#FloodSub">floodsub: type FloodSub</a></li>
          </ul></dd>
<dt><a name="FloodSubCodec" href="#FloodSubCodec"><span>FloodSubCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: const FloodSubCodec" href="libp2p/protocols/pubsub/floodsub.html#FloodSubCodec">floodsub: const FloodSubCodec</a></li>
          </ul></dd>
<dt><a name="flushIf" href="#flushIf"><span>flushIf:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc flushIf[T](o: OffsettedSeq[T]; pred: proc (x: T): bool)" href="libp2p/utils/offsettedseq.html#flushIf%2COffsettedSeq%5BT%5D%2Cproc%28T%29">offsettedseq: proc flushIf[T](o: OffsettedSeq[T]; pred: proc (x: T): bool)</a></li>
          </ul></dd>
<dt><a name="flushIfIt" href="#flushIfIt"><span>flushIfIt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: template flushIfIt(o, pred: untyped)" href="libp2p/utils/offsettedseq.html#flushIfIt.t%2Cuntyped%2Cuntyped">offsettedseq: template flushIfIt(o, pred: untyped)</a></li>
          </ul></dd>
<dt><a name="formatItIMPL" href="#formatItIMPL"><span>formatItIMPL:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: template formatItIMPL(it: LPChannel): auto" href="libp2p/muxers/mplex/lpchannel.html#formatItIMPL.t%2CLPChannel">lpchannel: template formatItIMPL(it: LPChannel): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mplex: template formatItIMPL(it: Mplex): auto" href="libp2p/muxers/mplex/mplex.html#formatItIMPL.t%2CMplex">mplex: template formatItIMPL(it: Mplex): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxer: template formatItIMPL(it: Muxer): auto" href="libp2p/muxers/muxer.html#formatItIMPL.t%2CMuxer">muxer: template formatItIMPL(it: Muxer): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: template formatItIMPL(it: Opt[PeerId]): auto" href="libp2p/peerid.html#formatItIMPL.t%2COpt%5BPeerId%5D">peerid: template formatItIMPL(it: Opt[PeerId]): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: template formatItIMPL(it: PeerId): auto" href="libp2p/peerid.html#formatItIMPL.t%2CPeerId">peerid: template formatItIMPL(it: PeerId): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerinfo: template formatItIMPL(it: PeerInfo): auto" href="libp2p/peerinfo.html#formatItIMPL.t%2CPeerInfo">peerinfo: template formatItIMPL(it: PeerInfo): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: template formatItIMPL(it: Key): auto" href="libp2p/protocols/kademlia/types.html#formatItIMPL.t%2CKey">types: template formatItIMPL(it: Key): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: template formatItIMPL(it: PubSubPeer): auto" href="libp2p/protocols/pubsub/pubsubpeer.html#formatItIMPL.t%2CPubSubPeer">pubsubpeer: template formatItIMPL(it: PubSubPeer): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="noise: template formatItIMPL(it: NoiseConnection): auto" href="libp2p/protocols/secure/noise.html#formatItIMPL.t%2CNoiseConnection">noise: template formatItIMPL(it: NoiseConnection): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: template formatItIMPL(it: SecureConn): auto" href="libp2p/protocols/secure/secure.html#formatItIMPL.t%2CSecureConn">secure: template formatItIMPL(it: SecureConn): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bufferstream: template formatItIMPL(it: BufferStream): auto" href="libp2p/stream/bufferstream.html#formatItIMPL.t%2CBufferStream">bufferstream: template formatItIMPL(it: BufferStream): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: template formatItIMPL(it: ChronosStream): auto" href="libp2p/stream/chronosstream.html#formatItIMPL.t%2CChronosStream">chronosstream: template formatItIMPL(it: ChronosStream): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: template formatItIMPL(it: Connection): auto" href="libp2p/stream/connection.html#formatItIMPL.t%2CConnection">connection: template formatItIMPL(it: Connection): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: template formatItIMPL(it: LPStream): auto" href="libp2p/stream/lpstream.html#formatItIMPL.t%2CLPStream">lpstream: template formatItIMPL(it: LPStream): auto</a></li>
          </ul></dd>
<dt><a name="fullAddrs" href="#fullAddrs"><span>fullAddrs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: proc fullAddrs(p: PeerInfo): MaResult[seq[MultiAddress]]" href="libp2p/peerinfo.html#fullAddrs%2CPeerInfo">peerinfo: proc fullAddrs(p: PeerInfo): MaResult[seq[MultiAddress]]</a></li>
          </ul></dd>
<dt><a name="GeCached" href="#GeCached"><span>GeCached:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: object GeCached" href="libp2p/crypto/ed25519/constants.html#GeCached">constants: object GeCached</a></li>
          </ul></dd>
<dt><a name="generateX509" href="#generateX509"><span>generateX509:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: proc generateX509(identityKeyPair: KeyPair; validFrom: Time = fromUnix(157813200);
             validTo: Time = fromUnix(67090165200'i64);
             encodingFormat: EncodingFormat = EncodingFormat.DER): CertificateX509" href="libp2p/transports/tls/certificate.html#generateX509%2CKeyPair%2CTime%2CTime%2CEncodingFormat">certificate: proc generateX509(identityKeyPair: KeyPair; validFrom: Time = fromUnix(157813200);
             validTo: Time = fromUnix(67090165200'i64);
             encodingFormat: EncodingFormat = EncodingFormat.DER): CertificateX509</a></li>
          </ul></dd>
<dt><a name="GenericRendezVous" href="#GenericRendezVous"><span>GenericRendezVous:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: type GenericRendezVous" href="libp2p/protocols/rendezvous/rendezvous.html#GenericRendezVous">rendezvous: type GenericRendezVous</a></li>
          </ul></dd>
<dt><a name="GeP1P1" href="#GeP1P1"><span>GeP1P1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: object GeP1P1" href="libp2p/crypto/ed25519/constants.html#GeP1P1">constants: object GeP1P1</a></li>
          </ul></dd>
<dt><a name="GeP2" href="#GeP2"><span>GeP2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: object GeP2" href="libp2p/crypto/ed25519/constants.html#GeP2">constants: object GeP2</a></li>
          </ul></dd>
<dt><a name="GeP3" href="#GeP3"><span>GeP3:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: object GeP3" href="libp2p/crypto/ed25519/constants.html#GeP3">constants: object GeP3</a></li>
          </ul></dd>
<dt><a name="GePrecomp" href="#GePrecomp"><span>GePrecomp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: object GePrecomp" href="libp2p/crypto/ed25519/constants.html#GePrecomp">constants: object GePrecomp</a></li>
          </ul></dd>
<dt><a name="get" href="#get"><span>get:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: method get(self: PeerIDAuthClient; uri: Uri): InternalRaisesFuture[PeerIDAuthResponse,
    (PeerIDAuthError, HttpError, CancelledError)]" href="libp2p/peeridauth/client.html#get.e%2CPeerIDAuthClient%2CUri">client: method get(self: PeerIDAuthClient; uri: Uri): InternalRaisesFuture[PeerIDAuthResponse,
    (PeerIDAuthError, HttpError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc get(self: LocalTable; key: Key): Opt[EntryRecord]" href="libp2p/protocols/kademlia/types.html#get%2CLocalTable%2CKey">types: proc get(self: LocalTable; key: Key): Opt[EntryRecord]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mcache: proc get(c: MCache; msgId: MessageId): Opt[Message]" href="libp2p/protocols/pubsub/mcache.html#get%2CMCache%2CMessageId">mcache: proc get(c: MCache; msgId: MessageId): Opt[Message]</a></li>
          </ul></dd>
<dt><a name="getAgent" href="#getAgent"><span>getAgent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc getAgent(peer: PubSubPeer): string" href="libp2p/protocols/pubsub/pubsubpeer.html#getAgent%2CPubSubPeer">pubsubpeer: proc getAgent(peer: PubSubPeer): string</a></li>
          </ul></dd>
<dt><a name="getArray" href="#getArray"><span>getArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: template getArray(bs, os, ls: untyped): untyped" href="libp2p/crypto/rsa.html#getArray.t%2Cuntyped%2Cuntyped%2Cuntyped">rsa: template getArray(bs, os, ls: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="getBuffer" href="#getBuffer"><span>getBuffer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc getBuffer(field: Asn1Field): Asn1Buffer" href="libp2p/crypto/minasn1.html#getBuffer%2CAsn1Field">minasn1: proc getBuffer(field: Asn1Field): Asn1Buffer</a></li>
          </ul></dd>
<dt><a name="getBytes" href="#getBytes"><span>getBytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc getBytes(key: PrivateKey): CryptoResult[seq[byte]]" href="libp2p/crypto/crypto.html#getBytes%2CPrivateKey">crypto: proc getBytes(key: PrivateKey): CryptoResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc getBytes(key: PublicKey): CryptoResult[seq[byte]]" href="libp2p/crypto/crypto.html#getBytes%2CPublicKey">crypto: proc getBytes(key: PublicKey): CryptoResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc getBytes(sig: Signature): seq[byte]" href="libp2p/crypto/crypto.html#getBytes%2CSignature">crypto: proc getBytes(sig: Signature): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="curve25519: proc getBytes(key: Curve25519Key): seq[byte]" href="libp2p/crypto/curve25519.html#getBytes%2CCurve25519Key">curve25519: proc getBytes(key: Curve25519Key): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc getBytes(seckey: EcPrivateKey): EcResult[seq[byte]]" href="libp2p/crypto/ecnist.html#getBytes%2CEcPrivateKey">ecnist: proc getBytes(seckey: EcPrivateKey): EcResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc getBytes(pubkey: EcPublicKey): EcResult[seq[byte]]" href="libp2p/crypto/ecnist.html#getBytes%2CEcPublicKey">ecnist: proc getBytes(pubkey: EcPublicKey): EcResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc getBytes(sig: EcSignature): EcResult[seq[byte]]" href="libp2p/crypto/ecnist.html#getBytes%2CEcSignature">ecnist: proc getBytes(sig: EcSignature): EcResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc getBytes(key: EdPrivateKey): seq[byte]" href="libp2p/crypto/ed25519/ed25519.html#getBytes%2CEdPrivateKey">ed25519: proc getBytes(key: EdPrivateKey): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc getBytes(key: EdPublicKey): seq[byte]" href="libp2p/crypto/ed25519/ed25519.html#getBytes%2CEdPublicKey">ed25519: proc getBytes(key: EdPublicKey): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc getBytes(sig: EdSignature): seq[byte]" href="libp2p/crypto/ed25519/ed25519.html#getBytes%2CEdSignature">ed25519: proc getBytes(sig: EdSignature): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc getBytes(key: RsaPrivateKey): RsaResult[seq[byte]]" href="libp2p/crypto/rsa.html#getBytes%2CRsaPrivateKey">rsa: proc getBytes(key: RsaPrivateKey): RsaResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc getBytes(key: RsaPublicKey): RsaResult[seq[byte]]" href="libp2p/crypto/rsa.html#getBytes%2CRsaPublicKey">rsa: proc getBytes(key: RsaPublicKey): RsaResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc getBytes(sig: RsaSignature): RsaResult[seq[byte]]" href="libp2p/crypto/rsa.html#getBytes%2CRsaSignature">rsa: proc getBytes(sig: RsaSignature): RsaResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc getBytes(key: SkPrivateKey): seq[byte]" href="libp2p/crypto/secp.html#getBytes%2CSkPrivateKey">secp: proc getBytes(key: SkPrivateKey): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc getBytes(key: SkPublicKey): seq[byte]" href="libp2p/crypto/secp.html#getBytes%2CSkPublicKey">secp: proc getBytes(key: SkPublicKey): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc getBytes(sig: SkSignature): seq[byte]" href="libp2p/crypto/secp.html#getBytes%2CSkSignature">secp: proc getBytes(sig: SkSignature): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: template getBytes(pid: PeerId): seq[byte]" href="libp2p/peerid.html#getBytes.t%2CPeerId">peerid: template getBytes(pid: PeerId): seq[byte]</a></li>
          </ul></dd>
<dt><a name="GetConn" href="#GetConn"><span>GetConn:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type GetConn" href="libp2p/protocols/pubsub/pubsubpeer.html#GetConn">pubsubpeer: type GetConn</a></li>
          </ul></dd>
<dt><a name="GetConnDialError" href="#GetConnDialError"><span>GetConnDialError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: object GetConnDialError" href="libp2p/protocols/pubsub/pubsubpeer.html#GetConnDialError">pubsubpeer: object GetConnDialError</a></li>
          </ul></dd>
<dt><a name="getConnections" href="#getConnections"><span>getConnections:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc getConnections(c: ConnManager): Table[PeerId, seq[Muxer]]" href="libp2p/connmanager.html#getConnections%2CConnManager">connmanager: proc getConnections(c: ConnManager): Table[PeerId, seq[Muxer]]</a></li>
          </ul></dd>
<dt><a name="getField" href="#getField"><span>getField:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc getField(pb: ProtoBuffer; field: int; value: var Signature): ProtoResult[bool]" href="libp2p/crypto/crypto.html#getField%2CProtoBuffer%2Cint%2CSignature">crypto: proc getField(pb: ProtoBuffer; field: int; value: var Signature): ProtoResult[bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc getField[T: PublicKey | PrivateKey](pb: ProtoBuffer; field: int; value: var T): ProtoResult[
    bool]" href="libp2p/crypto/crypto.html#getField%2CProtoBuffer%2Cint%2CT">crypto: proc getField[T: PublicKey | PrivateKey](pb: ProtoBuffer; field: int; value: var T): ProtoResult[
    bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc getField(pb: ProtoBuffer; field: int; value: var MultiAddress): ProtoResult[bool]" href="libp2p/multiaddress.html#getField%2CProtoBuffer%2Cint%2CMultiAddress">multiaddress: proc getField(pb: ProtoBuffer; field: int; value: var MultiAddress): ProtoResult[bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc getField(pb: ProtoBuffer; field: int; pid: var PeerId): ProtoResult[bool]" href="libp2p/peerid.html#getField%2CProtoBuffer%2Cint%2CPeerId">peerid: proc getField(pb: ProtoBuffer; field: int; pid: var PeerId): ProtoResult[bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getField[T: byte | char](data: ProtoBuffer; field: int;
                         output: var openArray[T]; outlen: var int): ProtoResult[
    bool]" href="libp2p/protobuf/minprotobuf.html#getField%2CProtoBuffer%2Cint%2CopenArray%5BT%5D%2Cint">minprotobuf: proc getField[T: byte | char](data: ProtoBuffer; field: int;
                         output: var openArray[T]; outlen: var int): ProtoResult[
    bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getField(pb: ProtoBuffer; field: int; output: var ProtoBuffer): ProtoResult[bool]" href="libp2p/protobuf/minprotobuf.html#getField%2CProtoBuffer%2Cint%2CProtoBuffer">minprotobuf: proc getField(pb: ProtoBuffer; field: int; output: var ProtoBuffer): ProtoResult[bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getField[T: ProtoScalar](data: ProtoBuffer; field: int; output: var T): ProtoResult[
    bool]" href="libp2p/protobuf/minprotobuf.html#getField%2CProtoBuffer%2Cint%2CT">minprotobuf: proc getField[T: ProtoScalar](data: ProtoBuffer; field: int; output: var T): ProtoResult[
    bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getField[T: seq[byte] | string](data: ProtoBuffer; field: int; output: var T): ProtoResult[
    bool]" href="libp2p/protobuf/minprotobuf.html#getField%2CProtoBuffer%2Cint%2CT_2">minprotobuf: proc getField[T: seq[byte] | string](data: ProtoBuffer; field: int; output: var T): ProtoResult[
    bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc getField(pb: ProtoBuffer; field: int; value: var Envelope; domain: string): ProtoResult[
    bool]" href="libp2p/signed_envelope.html#getField%2CProtoBuffer%2Cint%2CEnvelope%2Cstring">signed_envelope: proc getField(pb: ProtoBuffer; field: int; value: var Envelope; domain: string): ProtoResult[
    bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc getField[T](pb: ProtoBuffer; field: int; value: var SignedPayload[T]): ProtoResult[
    bool]" href="libp2p/signed_envelope.html#getField%2CProtoBuffer%2Cint%2CSignedPayload%5BT%5D">signed_envelope: proc getField[T](pb: ProtoBuffer; field: int; value: var SignedPayload[T]): ProtoResult[
    bool]</a></li>
          </ul></dd>
<dt><a name="getGossipPeers" href="#getGossipPeers"><span>getGossipPeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc getGossipPeers(g: GossipSub): Table[PubSubPeer, ControlMessage]" href="libp2p/protocols/pubsub/gossipsub/behavior.html#getGossipPeers%2CGossipSub">behavior: proc getGossipPeers(g: GossipSub): Table[PubSubPeer, ControlMessage]</a></li>
          </ul></dd>
<dt><a name="getHostname" href="#getHostname"><span>getHostname:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="nameresolver: proc getHostname(ma: MultiAddress): string" href="libp2p/nameresolving/nameresolver.html#getHostname%2CMultiAddress">nameresolver: proc getHostname(ma: MultiAddress): string</a></li>
          </ul></dd>
<dt><a name="getIncomingSlot" href="#getIncomingSlot"><span>getIncomingSlot:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc getIncomingSlot(c: ConnManager): InternalRaisesFuture[ConnectionSlot,
    (CancelledError,)]" href="libp2p/connmanager.html#getIncomingSlot%2CConnManager">connmanager: proc getIncomingSlot(c: ConnManager): InternalRaisesFuture[ConnectionSlot,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="getInstance" href="#getInstance"><span>getInstance:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="memorymanager: proc getInstance(): memoryConnManager" href="libp2p/transports/memorymanager.html#getInstance">memorymanager: proc getInstance(): memoryConnManager</a></li>
          </ul></dd>
<dt><a name="getLen" href="#getLen"><span>getLen:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: template getLen(pb: ProtoBuffer): int" href="libp2p/protobuf/minprotobuf.html#getLen.t%2CProtoBuffer">minprotobuf: template getLen(pb: ProtoBuffer): int</a></li>
          </ul></dd>
<dt><a name="getLocalAddress" href="#getLocalAddress"><span>getLocalAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wire: proc getLocalAddress(sock: AsyncFD): TransportAddress" href="libp2p/wire.html#getLocalAddress%2CAsyncFD">wire: proc getLocalAddress(sock: AsyncFD): TransportAddress</a></li>
          </ul></dd>
<dt><a name="getMostObservedProtosAndPorts" href="#getMostObservedProtosAndPorts"><span>getMostObservedProtosAndPorts:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="observedaddrmanager: proc getMostObservedProtosAndPorts(self: ObservedAddrManager): seq[MultiAddress]" href="libp2p/observedaddrmanager.html#getMostObservedProtosAndPorts%2CObservedAddrManager">observedaddrmanager: proc getMostObservedProtosAndPorts(self: ObservedAddrManager): seq[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc getMostObservedProtosAndPorts(self: PeerStore): seq[MultiAddress]" href="libp2p/peerstore.html#getMostObservedProtosAndPorts%2CPeerStore">peerstore: proc getMostObservedProtosAndPorts(self: PeerStore): seq[MultiAddress]</a></li>
          </ul></dd>
<dt><a name="getOrCreatePeer" href="#getOrCreatePeer"><span>getOrCreatePeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: method getOrCreatePeer(g: GossipSub; peerId: PeerId; protosToDial: seq[string];
                protoNegotiated: string = &quot;&quot;): PubSubPeer" href="libp2p/protocols/pubsub/gossipsub.html#getOrCreatePeer.e%2CGossipSub%2CPeerId%2Cseq%5Bstring%5D%2Cstring">gossipsub: method getOrCreatePeer(g: GossipSub; peerId: PeerId; protosToDial: seq[string];
                protoNegotiated: string = &quot;&quot;): PubSubPeer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method getOrCreatePeer(p: PubSub; peerId: PeerId; protosToDial: seq[string];
                protoNegotiated: string = &quot;&quot;): PubSubPeer" href="libp2p/protocols/pubsub/pubsub.html#getOrCreatePeer.e%2CPubSub%2CPeerId%2Cseq%5Bstring%5D%2Cstring">pubsub: method getOrCreatePeer(p: PubSub; peerId: PeerId; protosToDial: seq[string];
                protoNegotiated: string = &quot;&quot;): PubSubPeer</a></li>
          </ul></dd>
<dt><a name="getOrder" href="#getOrder"><span>getOrder:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc getOrder(remotePubkey, localNonce: openArray[byte];
         localPubkey, remoteNonce: openArray[byte]): CryptoResult[int]" href="libp2p/crypto/crypto.html#getOrder%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D">crypto: proc getOrder(remotePubkey, localNonce: openArray[byte];
         localPubkey, remoteNonce: openArray[byte]): CryptoResult[int]</a></li>
          </ul></dd>
<dt><a name="getOutgoingSlot" href="#getOutgoingSlot"><span>getOutgoingSlot:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc getOutgoingSlot(c: ConnManager; forceDial = false): ConnectionSlot" href="libp2p/connmanager.html#getOutgoingSlot%2CConnManager">connmanager: proc getOutgoingSlot(c: ConnManager; forceDial = false): ConnectionSlot</a></li>
          </ul></dd>
<dt><a name="getPackedRepeatedField" href="#getPackedRepeatedField"><span>getPackedRepeatedField:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getPackedRepeatedField[T: ProtoScalar](data: ProtoBuffer; field: int;
                                       output: var seq[T]): ProtoResult[bool]" href="libp2p/protobuf/minprotobuf.html#getPackedRepeatedField%2CProtoBuffer%2Cint%2Cseq%5BT%5D">minprotobuf: proc getPackedRepeatedField[T: ProtoScalar](data: ProtoBuffer; field: int;
                                       output: var seq[T]): ProtoResult[bool]</a></li>
          </ul></dd>
<dt><a name="getPart" href="#getPart"><span>getPart:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc getPart(ma: MultiAddress; codec: MultiCodec): MaResult[MultiAddress]" href="libp2p/multiaddress.html#getPart%2CMultiAddress%2CMultiCodec">multiaddress: proc getPart(ma: MultiAddress; codec: MultiCodec): MaResult[MultiAddress]</a></li>
          </ul></dd>
<dt><a name="getPrivateKeyLength" href="#getPrivateKeyLength"><span>getPrivateKeyLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: template getPrivateKeyLength(curve: EcCurveKind): int" href="libp2p/crypto/ecnist.html#getPrivateKeyLength.t%2CEcCurveKind">ecnist: template getPrivateKeyLength(curve: EcCurveKind): int</a></li>
          </ul></dd>
<dt><a name="getProtocolArgument" href="#getProtocolArgument"><span>getProtocolArgument:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wildcardresolverservice: proc getProtocolArgument(ma: MultiAddress; codec: MultiCodec): MaResult[seq[byte]]" href="libp2p/services/wildcardresolverservice.html#getProtocolArgument%2CMultiAddress%2CMultiCodec">wildcardresolverservice: proc getProtocolArgument(ma: MultiAddress; codec: MultiCodec): MaResult[seq[byte]]</a></li>
          </ul></dd>
<dt><a name="getProtoHeader" href="#getProtoHeader"><span>getProtoHeader:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: template getProtoHeader(index: int; wire: ProtoFieldKind): uint64" href="libp2p/protobuf/minprotobuf.html#getProtoHeader.t%2Cint%2CProtoFieldKind">minprotobuf: template getProtoHeader(index: int; wire: ProtoFieldKind): uint64</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: template getProtoHeader(field: ProtoField): uint64" href="libp2p/protobuf/minprotobuf.html#getProtoHeader.t%2CProtoField">minprotobuf: template getProtoHeader(field: ProtoField): uint64</a></li>
          </ul></dd>
<dt><a name="getProviders" href="#getProviders"><span>getProviders:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: MessageType.getProviders" href="libp2p/protocols/kademlia/protobuf.html#getProviders">protobuf: MessageType.getProviders</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc getProviders(kad: KadDHT; key: Key): InternalRaisesFuture[HashSet[Provider],
    (LPStreamError, DialFailedError, CancelledError)]" href="libp2p/protocols/kademlia/provider.html#getProviders%2CKadDHT%2CKey">provider: proc getProviders(kad: KadDHT; key: Key): InternalRaisesFuture[HashSet[Provider],
    (LPStreamError, DialFailedError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="getPtr" href="#getPtr"><span>getPtr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: template getPtr(field: untyped): pointer" href="libp2p/crypto/minasn1.html#getPtr.t%2Cuntyped">minasn1: template getPtr(field: untyped): pointer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: template getPtr(pb: ProtoBuffer): pointer" href="libp2p/protobuf/minprotobuf.html#getPtr.t%2CProtoBuffer">minprotobuf: template getPtr(pb: ProtoBuffer): pointer</a></li>
          </ul></dd>
<dt><a name="getPublicIPAddress" href="#getPublicIPAddress"><span>getPublicIPAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc getPublicIPAddress(): IpAddress" href="libp2p/utils/ipaddr.html#getPublicIPAddress">ipaddr: proc getPublicIPAddress(): IpAddress</a></li>
          </ul></dd>
<dt><a name="getPublicKey" href="#getPublicKey"><span>getPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc getPublicKey(key: PrivateKey): CryptoResult[PublicKey]" href="libp2p/crypto/crypto.html#getPublicKey%2CPrivateKey">crypto: proc getPublicKey(key: PrivateKey): CryptoResult[PublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc getPublicKey(seckey: EcPrivateKey): EcResult[EcPublicKey]" href="libp2p/crypto/ecnist.html#getPublicKey%2CEcPrivateKey">ecnist: proc getPublicKey(seckey: EcPrivateKey): EcResult[EcPublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc getPublicKey(key: EdPrivateKey): EdPublicKey" href="libp2p/crypto/ed25519/ed25519.html#getPublicKey%2CEdPrivateKey">ed25519: proc getPublicKey(key: EdPrivateKey): EdPublicKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc getPublicKey(key: RsaPrivateKey): RsaPublicKey" href="libp2p/crypto/rsa.html#getPublicKey%2CRsaPrivateKey">rsa: proc getPublicKey(key: RsaPrivateKey): RsaPublicKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc getPublicKey(key: SkPrivateKey): SkPublicKey" href="libp2p/crypto/secp.html#getPublicKey%2CSkPrivateKey">secp: proc getPublicKey(key: SkPrivateKey): SkPublicKey</a></li>
          </ul></dd>
<dt><a name="getPublicKeyLength" href="#getPublicKeyLength"><span>getPublicKeyLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: template getPublicKeyLength(curve: EcCurveKind): int" href="libp2p/crypto/ecnist.html#getPublicKeyLength.t%2CEcCurveKind">ecnist: template getPublicKeyLength(curve: EcCurveKind): int</a></li>
          </ul></dd>
<dt><a name="getRawBytes" href="#getRawBytes"><span>getRawBytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc getRawBytes(key: PrivateKey | PublicKey): CryptoResult[seq[byte]]" href="libp2p/crypto/crypto.html#getRawBytes">crypto: proc getRawBytes(key: PrivateKey | PublicKey): CryptoResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc getRawBytes(seckey: EcPrivateKey): EcResult[seq[byte]]" href="libp2p/crypto/ecnist.html#getRawBytes%2CEcPrivateKey">ecnist: proc getRawBytes(seckey: EcPrivateKey): EcResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc getRawBytes(pubkey: EcPublicKey): EcResult[seq[byte]]" href="libp2p/crypto/ecnist.html#getRawBytes%2CEcPublicKey">ecnist: proc getRawBytes(pubkey: EcPublicKey): EcResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc getRawBytes(sig: EcSignature): EcResult[seq[byte]]" href="libp2p/crypto/ecnist.html#getRawBytes%2CEcSignature">ecnist: proc getRawBytes(sig: EcSignature): EcResult[seq[byte]]</a></li>
          </ul></dd>
<dt><a name="getRepeatedField" href="#getRepeatedField"><span>getRepeatedField:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc getRepeatedField(pb: ProtoBuffer; field: int; value: var seq[MultiAddress]): ProtoResult[
    bool]" href="libp2p/multiaddress.html#getRepeatedField%2CProtoBuffer%2Cint%2Cseq%5BMultiAddress%5D">multiaddress: proc getRepeatedField(pb: ProtoBuffer; field: int; value: var seq[MultiAddress]): ProtoResult[
    bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getRepeatedField[T: seq[byte] | string](data: ProtoBuffer; field: int;
                                        output: var seq[T]): ProtoResult[bool]" href="libp2p/protobuf/minprotobuf.html#getRepeatedField%2CProtoBuffer%2Cint%2Cseq%5BT%5D">minprotobuf: proc getRepeatedField[T: seq[byte] | string](data: ProtoBuffer; field: int;
                                        output: var seq[T]): ProtoResult[bool]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getRepeatedField[T: ProtoScalar](data: ProtoBuffer; field: int;
                                 output: var seq[T]): ProtoResult[bool]" href="libp2p/protobuf/minprotobuf.html#getRepeatedField%2CProtoBuffer%2Cint%2Cseq%5BT%5D_2">minprotobuf: proc getRepeatedField[T: ProtoScalar](data: ProtoBuffer; field: int;
                                 output: var seq[T]): ProtoResult[bool]</a></li>
          </ul></dd>
<dt><a name="getRequiredField" href="#getRequiredField"><span>getRequiredField:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getRequiredField[T](pb: ProtoBuffer; field: int; output: var T): ProtoResult[
    void]" href="libp2p/protobuf/minprotobuf.html#getRequiredField%2CProtoBuffer%2Cint%2CT">minprotobuf: proc getRequiredField[T](pb: ProtoBuffer; field: int; output: var T): ProtoResult[
    void]</a></li>
          </ul></dd>
<dt><a name="getRequiredRepeatedField" href="#getRequiredRepeatedField"><span>getRequiredRepeatedField:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc getRequiredRepeatedField[T](pb: ProtoBuffer; field: int; output: var seq[T]): ProtoResult[
    void]" href="libp2p/protobuf/minprotobuf.html#getRequiredRepeatedField%2CProtoBuffer%2Cint%2Cseq%5BT%5D">minprotobuf: proc getRequiredRepeatedField[T](pb: ProtoBuffer; field: int; output: var seq[T]): ProtoResult[
    void]</a></li>
          </ul></dd>
<dt><a name="getSecret" href="#getSecret"><span>getSecret:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: proc getSecret(pubkey: EcPublicKey; seckey: EcPrivateKey): seq[byte]" href="libp2p/crypto/ecnist.html#getSecret%2CEcPublicKey%2CEcPrivateKey">ecnist: proc getSecret(pubkey: EcPublicKey; seckey: EcPrivateKey): seq[byte]</a></li>
          </ul></dd>
<dt><a name="getStream" href="#getStream"><span>getStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc getStream(c: ConnManager; muxer: Muxer): InternalRaisesFuture[Connection,
    (LPStreamError, MuxerError, CancelledError)]" href="libp2p/connmanager.html#getStream%2CConnManager%2CMuxer">connmanager: proc getStream(c: ConnManager; muxer: Muxer): InternalRaisesFuture[Connection,
    (LPStreamError, MuxerError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connmanager: proc getStream(c: ConnManager; peerId: PeerId): InternalRaisesFuture[Connection,
    (LPStreamError, MuxerError, CancelledError)]" href="libp2p/connmanager.html#getStream%2CConnManager%2CPeerId">connmanager: proc getStream(c: ConnManager; peerId: PeerId): InternalRaisesFuture[Connection,
    (LPStreamError, MuxerError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connmanager: proc getStream(c: ConnManager; peerId: PeerId; dir: Direction): InternalRaisesFuture[
    Connection, (LPStreamError, MuxerError, CancelledError)]" href="libp2p/connmanager.html#getStream%2CConnManager%2CPeerId%2CDirection">connmanager: proc getStream(c: ConnManager; peerId: PeerId; dir: Direction): InternalRaisesFuture[
    Connection, (LPStreamError, MuxerError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="getStreams" href="#getStreams"><span>getStreams:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mplex: method getStreams(m: Mplex): seq[Connection]" href="libp2p/muxers/mplex/mplex.html#getStreams.e%2CMplex">mplex: method getStreams(m: Mplex): seq[Connection]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxer: method getStreams(m: Muxer): seq[Connection]" href="libp2p/muxers/muxer.html#getStreams.e%2CMuxer">muxer: method getStreams(m: Muxer): seq[Connection]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method getStreams(m: Yamux): seq[Connection]" href="libp2p/muxers/yamux/yamux.html#getStreams.e%2CYamux">yamux: method getStreams(m: Yamux): seq[Connection]</a></li>
          </ul></dd>
<dt><a name="getSVarint" href="#getSVarint"><span>getSVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: proc getSVarint(pbytes: openArray[byte]; outsize: var int;
           outval: var (PBZigVarint | PBSomeSVarint)): VarintResult[void]" href="libp2p/varint.html#getSVarint%2CopenArray%5Bbyte%5D%2Cint%2C">varint: proc getSVarint(pbytes: openArray[byte]; outsize: var int;
           outval: var (PBZigVarint | PBSomeSVarint)): VarintResult[void]</a></li>
          </ul></dd>
<dt><a name="getUVarint" href="#getUVarint"><span>getUVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: proc getUVarint[T: PB | LP](vtype: typedesc[T]; pbytes: openArray[byte];
                       outlen: var int; outval: var SomeUVarint): VarintResult[
    void]" href="libp2p/varint.html#getUVarint%2Ctypedesc%5BT%5D%2CopenArray%5Bbyte%5D%2Cint%2CSomeUVarint">varint: proc getUVarint[T: PB | LP](vtype: typedesc[T]; pbytes: openArray[byte];
                       outlen: var int; outval: var SomeUVarint): VarintResult[
    void]</a></li>
          </ul></dd>
<dt><a name="getValue" href="#getValue"><span>getValue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="get: proc getValue(kad: KadDHT; key: Key): InternalRaisesFuture[
    Result[EntryRecord, string], (CancelledError,)]" href="libp2p/protocols/kademlia/get.html#getValue%2CKadDHT%2CKey">get: proc getValue(kad: KadDHT; key: Key): InternalRaisesFuture[
    Result[EntryRecord, string], (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: MessageType.getValue" href="libp2p/protocols/kademlia/protobuf.html#getValue">protobuf: MessageType.getValue</a></li>
          </ul></dd>
<dt><a name="getVarint" href="#getVarint"><span>getVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: proc getVarint[T: PB | LP](vtype: typedesc[T]; pbytes: openArray[byte];
                      nbytes: var int; value: var SomeVarint): VarintResult[void]" href="libp2p/varint.html#getVarint%2Ctypedesc%5BT%5D%2CopenArray%5Bbyte%5D%2Cint%2CSomeVarint">varint: proc getVarint[T: PB | LP](vtype: typedesc[T]; pbytes: openArray[byte];
                      nbytes: var int; value: var SomeVarint): VarintResult[void]</a></li>
          </ul></dd>
<dt><a name="getWrapped" href="#getWrapped"><span>getWrapped:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: method getWrapped(s: LPChannel): Connection" href="libp2p/muxers/mplex/lpchannel.html#getWrapped.e%2CLPChannel">lpchannel: method getWrapped(s: LPChannel): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method getWrapped(channel: YamuxChannel): Connection" href="libp2p/muxers/yamux/yamux.html#getWrapped.e%2CYamuxChannel">yamux: method getWrapped(channel: YamuxChannel): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rconn: method getWrapped(self: RelayConnection): Connection" href="libp2p/protocols/connectivity/relay/rconn.html#getWrapped.e%2CRelayConnection">rconn: method getWrapped(self: RelayConnection): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: method getWrapped(s: SecureConn): Connection" href="libp2p/protocols/secure/secure.html#getWrapped.e%2CSecureConn">secure: method getWrapped(s: SecureConn): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bridgestream: method getWrapped(s: BridgeStream): Connection" href="libp2p/stream/bridgestream.html#getWrapped.e%2CBridgeStream">bridgestream: method getWrapped(s: BridgeStream): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method getWrapped(s: ChronosStream): Connection" href="libp2p/stream/chronosstream.html#getWrapped.e%2CChronosStream">chronosstream: method getWrapped(s: ChronosStream): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: method getWrapped(s: Connection): Connection" href="libp2p/stream/connection.html#getWrapped.e%2CConnection">connection: method getWrapped(s: Connection): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method getWrapped(self: QuicSession): P2PConnection" href="libp2p/transports/quictransport.html#getWrapped.e%2CQuicSession">quictransport: method getWrapped(self: QuicSession): P2PConnection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method getWrapped(self: QuicStream): P2PConnection" href="libp2p/transports/quictransport.html#getWrapped.e%2CQuicStream">quictransport: method getWrapped(self: QuicStream): P2PConnection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method getWrapped(s: WsStream): Connection" href="libp2p/transports/wstransport.html#getWrapped.e%2CWsStream">wstransport: method getWrapped(s: WsStream): Connection</a></li>
          </ul></dd>
<dt><a name="goffset" href="#goffset"><span>goffset:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: template goffset(secret, id, o: untyped): untyped" href="libp2p/crypto/crypto.html#goffset.t%2Cuntyped%2Cuntyped%2Cuntyped">crypto: template goffset(secret, id, o: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="GossipBackoffPeriod" href="#GossipBackoffPeriod"><span>GossipBackoffPeriod:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipBackoffPeriod" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipBackoffPeriod">types: const GossipBackoffPeriod</a></li>
          </ul></dd>
<dt><a name="GossipSub" href="#GossipSub"><span>GossipSub:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type GossipSub" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSub">types: type GossipSub</a></li>
          </ul></dd>
<dt><a name="GossipSubCodec_10" href="#GossipSubCodec_10"><span>GossipSubCodec_10:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubCodec_10" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubCodec_10">types: const GossipSubCodec_10</a></li>
          </ul></dd>
<dt><a name="GossipSubCodec_11" href="#GossipSubCodec_11"><span>GossipSubCodec_11:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubCodec_11" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubCodec_11">types: const GossipSubCodec_11</a></li>
          </ul></dd>
<dt><a name="GossipSubCodec_12" href="#GossipSubCodec_12"><span>GossipSubCodec_12:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubCodec_12" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubCodec_12">types: const GossipSubCodec_12</a></li>
          </ul></dd>
<dt><a name="GossipSubCodec_14" href="#GossipSubCodec_14"><span>GossipSubCodec_14:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubCodec_14" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubCodec_14">types: const GossipSubCodec_14</a></li>
          </ul></dd>
<dt><a name="GossipSubD" href="#GossipSubD"><span>GossipSubD:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubD" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubD">types: const GossipSubD</a></li>
          </ul></dd>
<dt><a name="GossipSubDhi" href="#GossipSubDhi"><span>GossipSubDhi:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubDhi" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubDhi">types: const GossipSubDhi</a></li>
          </ul></dd>
<dt><a name="GossipSubDlo" href="#GossipSubDlo"><span>GossipSubDlo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubDlo" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubDlo">types: const GossipSubDlo</a></li>
          </ul></dd>
<dt><a name="GossipSubFanoutTTL" href="#GossipSubFanoutTTL"><span>GossipSubFanoutTTL:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubFanoutTTL" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubFanoutTTL">types: const GossipSubFanoutTTL</a></li>
          </ul></dd>
<dt><a name="GossipSubHeartbeatInterval" href="#GossipSubHeartbeatInterval"><span>GossipSubHeartbeatInterval:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubHeartbeatInterval" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubHeartbeatInterval">types: const GossipSubHeartbeatInterval</a></li>
          </ul></dd>
<dt><a name="GossipSubHistoryGossip" href="#GossipSubHistoryGossip"><span>GossipSubHistoryGossip:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubHistoryGossip" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubHistoryGossip">types: const GossipSubHistoryGossip</a></li>
          </ul></dd>
<dt><a name="GossipSubHistoryLength" href="#GossipSubHistoryLength"><span>GossipSubHistoryLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const GossipSubHistoryLength" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubHistoryLength">types: const GossipSubHistoryLength</a></li>
          </ul></dd>
<dt><a name="GossipSubParams" href="#GossipSubParams"><span>GossipSubParams:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object GossipSubParams" href="libp2p/protocols/pubsub/gossipsub/types.html#GossipSubParams">types: object GossipSubParams</a></li>
          </ul></dd>
<dt><a name="grafted" href="#grafted"><span>grafted:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc grafted(g: GossipSub; p: PubSubPeer; topic: string)" href="libp2p/protocols/pubsub/gossipsub/behavior.html#grafted%2CGossipSub%2CPubSubPeer%2Cstring">behavior: proc grafted(g: GossipSub; p: PubSubPeer; topic: string)</a></li>
          </ul></dd>
<dt><a name="guessDialableAddr" href="#guessDialableAddr"><span>guessDialableAddr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="observedaddrmanager: proc guessDialableAddr(self: ObservedAddrManager; ma: MultiAddress): MultiAddress" href="libp2p/observedaddrmanager.html#guessDialableAddr%2CObservedAddrManager%2CMultiAddress">observedaddrmanager: proc guessDialableAddr(self: ObservedAddrManager; ma: MultiAddress): MultiAddress</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc guessDialableAddr(self: PeerStore; ma: MultiAddress): MultiAddress" href="libp2p/peerstore.html#guessDialableAddr%2CPeerStore%2CMultiAddress">peerstore: proc guessDialableAddr(self: PeerStore; ma: MultiAddress): MultiAddress</a></li>
          </ul></dd>
<dt><a name="handle" href="#handle"><span>handle:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: proc handle(m: MultistreamSelect; conn: Connection; active: bool = false): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/multistream.html#handle%2CMultistreamSelect%2CConnection%2Cbool">multistream: proc handle(m: MultistreamSelect; conn: Connection; active: bool = false): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multistream: proc handle(_: type MultistreamSelect; conn: Connection; protos: seq[string];
       matchers = newSeq[Matcher](); active: bool = false): InternalRaisesFuture[
    string, (CancelledError, LPStreamError, MultiStreamError)]" href="libp2p/multistream.html#handle%2CtypeMultistreamSelect%2CConnection%2Cseq%5Bstring%5D%2Cbool">multistream: proc handle(_: type MultistreamSelect; conn: Connection; protos: seq[string];
       matchers = newSeq[Matcher](); active: bool = false): InternalRaisesFuture[
    string, (CancelledError, LPStreamError, MultiStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mplex: method handle(m: Mplex): InternalRaisesFuture[void, void]" href="libp2p/muxers/mplex/mplex.html#handle.e%2CMplex">mplex: method handle(m: Mplex): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxer: method handle(m: Muxer): InternalRaisesFuture[void, void]" href="libp2p/muxers/muxer.html#handle.e%2CMuxer">muxer: method handle(m: Muxer): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method handle(m: Yamux): InternalRaisesFuture[void, void]" href="libp2p/muxers/yamux/yamux.html#handle.e%2CYamux">yamux: method handle(m: Yamux): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method handle(m: QuicMuxer): InternalRaisesFuture[void, void]" href="libp2p/transports/quictransport.html#handle.e%2CQuicMuxer">quictransport: method handle(m: QuicMuxer): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="handleAddProvider" href="#handleAddProvider"><span>handleAddProvider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc handleAddProvider(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/kademlia/provider.html#handleAddProvider%2CKadDHT%2CConnection%2CMessage">provider: proc handleAddProvider(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handleBackingOff" href="#handleBackingOff"><span>handleBackingOff:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc handleBackingOff(t: var BackoffTable; topic: string)" href="libp2p/protocols/pubsub/gossipsub/behavior.html#handleBackingOff%2CBackoffTable%2Cstring">behavior: proc handleBackingOff(t: var BackoffTable; topic: string)</a></li>
          </ul></dd>
<dt><a name="handleConn" href="#handleConn"><span>handleConn:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: method handleConn(p: PubSub; conn: Connection; proto: string): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/pubsub/pubsub.html#handleConn.e%2CPubSub%2CConnection%2Cstring">pubsub: method handleConn(p: PubSub; conn: Connection; proto: string): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handleData" href="#handleData"><span>handleData:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc handleData(p: PubSub; topic: string; data: seq[byte]): InternalRaisesFuture[
    void, void]" href="libp2p/protocols/pubsub/pubsub.html#handleData%2CPubSub%2Cstring%2Cseq%5Bbyte%5D">pubsub: proc handleData(p: PubSub; topic: string; data: seq[byte]): InternalRaisesFuture[
    void, void]</a></li>
          </ul></dd>
<dt><a name="handleDialDataRequest" href="#handleDialDataRequest"><span>handleDialDataRequest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc handleDialDataRequest(conn: Connection; req: DialDataRequest): InternalRaisesFuture[
    DialResponse, (CancelledError, AutonatV2Error, LPStreamError)]" href="libp2p/protocols/connectivity/autonatv2/client.html#handleDialDataRequest%2CConnection%2CDialDataRequest">client: proc handleDialDataRequest(conn: Connection; req: DialDataRequest): InternalRaisesFuture[
    DialResponse, (CancelledError, AutonatV2Error, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="handleFindNode" href="#handleFindNode"><span>handleFindNode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="find: proc handleFindNode(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/kademlia/find.html#handleFindNode%2CKadDHT%2CConnection%2CMessage">find: proc handleFindNode(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handleGetProviders" href="#handleGetProviders"><span>handleGetProviders:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc handleGetProviders(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/kademlia/provider.html#handleGetProviders%2CKadDHT%2CConnection%2CMessage">provider: proc handleGetProviders(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handleGetValue" href="#handleGetValue"><span>handleGetValue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="get: proc handleGetValue(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/kademlia/get.html#handleGetValue%2CKadDHT%2CConnection%2CMessage">get: proc handleGetValue(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handleGraft" href="#handleGraft"><span>handleGraft:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc handleGraft(g: GossipSub; peer: PubSubPeer; grafts: seq[ControlGraft]): seq[
    ControlPrune]" href="libp2p/protocols/pubsub/gossipsub/behavior.html#handleGraft%2CGossipSub%2CPubSubPeer%2Cseq%5BControlGraft%5D">behavior: proc handleGraft(g: GossipSub; peer: PubSubPeer; grafts: seq[ControlGraft]): seq[
    ControlPrune]</a></li>
          </ul></dd>
<dt><a name="handleHop" href="#handleHop"><span>handleHop:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: proc handleHop(r: Relay; connSrc: Connection; msg: RelayMessage): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/connectivity/relay/relay.html#handleHop%2CRelay%2CConnection%2CRelayMessage">relay: proc handleHop(r: Relay; connSrc: Connection; msg: RelayMessage): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handleHopStreamV2" href="#handleHopStreamV2"><span>handleHopStreamV2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: proc handleHopStreamV2(r: Relay; conn: Connection): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/connectivity/relay/relay.html#handleHopStreamV2%2CRelay%2CConnection">relay: proc handleHopStreamV2(r: Relay; conn: Connection): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="handleIDontWant" href="#handleIDontWant"><span>handleIDontWant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc handleIDontWant(g: GossipSub; peer: PubSubPeer; iDontWants: seq[ControlIWant])" href="libp2p/protocols/pubsub/gossipsub/behavior.html#handleIDontWant%2CGossipSub%2CPubSubPeer%2Cseq%5BControlIWant%5D">behavior: proc handleIDontWant(g: GossipSub; peer: PubSubPeer; iDontWants: seq[ControlIWant])</a></li>
          </ul></dd>
<dt><a name="handleIHave" href="#handleIHave"><span>handleIHave:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc handleIHave(g: GossipSub; peer: PubSubPeer; ihaves: seq[ControlIHave]): ControlIWant" href="libp2p/protocols/pubsub/gossipsub/behavior.html#handleIHave%2CGossipSub%2CPubSubPeer%2Cseq%5BControlIHave%5D">behavior: proc handleIHave(g: GossipSub; peer: PubSubPeer; ihaves: seq[ControlIHave]): ControlIWant</a></li>
          </ul></dd>
<dt><a name="handleIWant" href="#handleIWant"><span>handleIWant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc handleIWant(g: GossipSub; peer: PubSubPeer; iwants: seq[ControlIWant]): tuple[
    messages: seq[Message], ids: seq[MessageId]]" href="libp2p/protocols/pubsub/gossipsub/behavior.html#handleIWant%2CGossipSub%2CPubSubPeer%2Cseq%5BControlIWant%5D">behavior: proc handleIWant(g: GossipSub; peer: PubSubPeer; iwants: seq[ControlIWant]): tuple[
    messages: seq[Message], ids: seq[MessageId]]</a></li>
          </ul></dd>
<dt><a name="handlePing" href="#handlePing"><span>handlePing:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: proc handlePing(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/kademlia/ping.html#handlePing%2CKadDHT%2CConnection%2CMessage">ping: proc handlePing(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handlePrune" href="#handlePrune"><span>handlePrune:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc handlePrune(g: GossipSub; peer: PubSubPeer; prunes: seq[ControlPrune])" href="libp2p/protocols/pubsub/gossipsub/behavior.html#handlePrune%2CGossipSub%2CPubSubPeer%2Cseq%5BControlPrune%5D">behavior: proc handlePrune(g: GossipSub; peer: PubSubPeer; prunes: seq[ControlPrune])</a></li>
          </ul></dd>
<dt><a name="handlePutValue" href="#handlePutValue"><span>handlePutValue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="put: proc handlePutValue(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/protocols/kademlia/put.html#handlePutValue%2CKadDHT%2CConnection%2CMessage">put: proc handlePutValue(kad: KadDHT; conn: Connection; msg: Message): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="handler" href="#handler"><span>handler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: template handler(p: LPProtocol): LPProtoHandler" href="libp2p/protocols/protocol.html#handler.t%2CLPProtocol">protocol: template handler(p: LPProtocol): LPProtoHandler</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protocol: template handler(p: LPProtocol; conn: Connection; proto: string): Future[void]" href="libp2p/protocols/protocol.html#handler.t%2CLPProtocol%2CConnection%2Cstring">protocol: template handler(p: LPProtocol; conn: Connection; proto: string): Future[void]</a></li>
          </ul></dd>
<dt><a name="handler%3D" href="#handler%3D"><span>handler=:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: proc handler=(p: LPProtocol; handler: LPProtoHandler)" href="libp2p/protocols/protocol.html#handler%3D%2CLPProtocol%2CLPProtoHandler">protocol: proc handler=(p: LPProtocol; handler: LPProtoHandler)</a></li>
          </ul></dd>
<dt><a name="HandlerHolder" href="#HandlerHolder"><span>HandlerHolder:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: type HandlerHolder" href="libp2p/multistream.html#HandlerHolder">multistream: type HandlerHolder</a></li>
          </ul></dd>
<dt><a name="handles" href="#handles"><span>handles:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rtransport: method handles(self: RelayTransport; ma: MultiAddress): bool" href="libp2p/protocols/connectivity/relay/rtransport.html#handles.e%2CRelayTransport%2CMultiAddress">rtransport: method handles(self: RelayTransport; ma: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: method handles(self: MemoryTransport; ma: MultiAddress): bool" href="libp2p/transports/memorytransport.html#handles.e%2CMemoryTransport%2CMultiAddress">memorytransport: method handles(self: MemoryTransport; ma: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method handles(transport: QuicTransport; address: MultiAddress): bool" href="libp2p/transports/quictransport.html#handles.e%2CQuicTransport%2CMultiAddress">quictransport: method handles(transport: QuicTransport; address: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="tcptransport: method handles(t: TcpTransport; address: MultiAddress): bool" href="libp2p/transports/tcptransport.html#handles.e%2CTcpTransport%2CMultiAddress">tcptransport: method handles(t: TcpTransport; address: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="transport: method handles(self: Transport; address: MultiAddress): bool" href="libp2p/transports/transport.html#handles.e%2CTransport%2CMultiAddress">transport: method handles(self: Transport; address: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method handles(t: WsTransport; address: MultiAddress): bool" href="libp2p/transports/wstransport.html#handles.e%2CWsTransport%2CMultiAddress">wstransport: method handles(t: WsTransport; address: MultiAddress): bool</a></li>
          </ul></dd>
<dt><a name="handshake" href="#handshake"><span>handshake:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: method handshake(p: Noise; conn: Connection; initiator: bool; peerId: Opt[PeerId]): InternalRaisesFuture[
    SecureConn, (CancelledError, LPStreamError)]" href="libp2p/protocols/secure/noise.html#handshake.e%2CNoise%2CConnection%2Cbool%2COpt%5BPeerId%5D">noise: method handshake(p: Noise; conn: Connection; initiator: bool; peerId: Opt[PeerId]): InternalRaisesFuture[
    SecureConn, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: method handshake(s: Secure; conn: Connection; initiator: bool; peerId: Opt[PeerId]): InternalRaisesFuture[
    SecureConn, (CancelledError, LPStreamError)]" href="libp2p/protocols/secure/secure.html#handshake.e%2CSecure%2CConnection%2Cbool%2COpt%5BPeerId%5D">secure: method handshake(s: Secure; conn: Connection; initiator: bool; peerId: Opt[PeerId]): InternalRaisesFuture[
    SecureConn, (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="hash" href="#hash"><span>hash:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc hash(cid: Cid): Hash" href="libp2p/cid.html#hash%2CCid">cid: proc hash(cid: Cid): Hash</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc hash(a: MultiAddress): Hash" href="libp2p/multiaddress.html#hash%2CMultiAddress">multiaddress: proc hash(a: MultiAddress): Hash</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc hash(m: MultiCodec): Hash" href="libp2p/multicodec.html#hash%2CMultiCodec">multicodec: proc hash(m: MultiCodec): Hash</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: template hash(pid: PeerId): Hash" href="libp2p/peerid.html#hash.t%2CPeerId">peerid: template hash(pid: PeerId): Hash</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc hash(p: PubSubPeer): Hash" href="libp2p/protocols/pubsub/pubsubpeer.html#hash%2CPubSubPeer">pubsubpeer: proc hash(p: PubSubPeer): Hash</a></li>
          <li><a class="reference external"
          data-doc-search-tag="timedcache: proc hash(a: TimedEntry): Hash" href="libp2p/protocols/pubsub/timedcache.html#hash%2CTimedEntry">timedcache: proc hash(a: TimedEntry): Hash</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: proc hash(p: Connection): Hash" href="libp2p/stream/connection.html#hash%2CConnection">connection: proc hash(p: Connection): Hash</a></li>
          </ul></dd>
<dt><a name="HashError" href="#HashError"><span>HashError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: CryptoError.HashError" href="libp2p/crypto/crypto.html#HashError">crypto: CryptoError.HashError</a></li>
          </ul></dd>
<dt><a name="hasKey" href="#hasKey"><span>hasKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc hasKey(pk: ProvidedKeys; c: Cid): bool" href="libp2p/protocols/kademlia/provider.html#hasKey%2CProvidedKeys%2CCid">provider: proc hasKey(pk: ProvidedKeys; c: Cid): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc hasKey(ps: var PreambleStore; msgId: MessageId): bool" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#hasKey%2CPreambleStore%2CMessageId">preamblestore: proc hasKey(ps: var PreambleStore; msgId: MessageId): bool</a></li>
          </ul></dd>
<dt><a name="hasObservers" href="#hasObservers"><span>hasObservers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc hasObservers(p: PubSubPeer): bool" href="libp2p/protocols/pubsub/pubsubpeer.html#hasObservers%2CPubSubPeer">pubsubpeer: proc hasObservers(p: PubSubPeer): bool</a></li>
          </ul></dd>
<dt><a name="hasPeer" href="#hasPeer"><span>hasPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peertable: proc hasPeer(table: PeerTable; topic: string; peer: PubSubPeer): bool" href="libp2p/protocols/pubsub/peertable.html#hasPeer%2CPeerTable%2Cstring%2CPubSubPeer">peertable: proc hasPeer(table: PeerTable; topic: string; peer: PubSubPeer): bool</a></li>
          </ul></dd>
<dt><a name="hasPeerId" href="#hasPeerId"><span>hasPeerId:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peertable: proc hasPeerId(t: PeerTable; topic: string; peerId: PeerId): bool" href="libp2p/protocols/pubsub/peertable.html#hasPeerId%2CPeerTable%2Cstring%2CPeerId">peertable: proc hasPeerId(t: PeerTable; topic: string; peerId: PeerId): bool</a></li>
          </ul></dd>
<dt><a name="hasPublicIPAddress" href="#hasPublicIPAddress"><span>hasPublicIPAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc hasPublicIPAddress(): bool" href="libp2p/utils/ipaddr.html#hasPublicIPAddress">ipaddr: proc hasPublicIPAddress(): bool</a></li>
          </ul></dd>
<dt><a name="hasPublicKey" href="#hasPublicKey"><span>hasPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: proc hasPublicKey(pid: PeerId): bool" href="libp2p/peerid.html#hasPublicKey%2CPeerId">peerid: proc hasPublicKey(pid: PeerId): bool</a></li>
          </ul></dd>
<dt><a name="hasSeen" href="#hasSeen"><span>hasSeen:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: proc hasSeen(f: FloodSub; saltedId: SaltedId): bool" href="libp2p/protocols/pubsub/floodsub.html#hasSeen%2CFloodSub%2CSaltedId">floodsub: proc hasSeen(f: FloodSub; saltedId: SaltedId): bool</a></li>
          </ul></dd>
<dt><a name="hasSendConn" href="#hasSendConn"><span>hasSendConn:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc hasSendConn(p: PubSubPeer): bool" href="libp2p/protocols/pubsub/pubsubpeer.html#hasSendConn%2CPubSubPeer">pubsubpeer: proc hasSendConn(p: PubSubPeer): bool</a></li>
          </ul></dd>
<dt><a name="heartbeat" href="#heartbeat"><span>heartbeat:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc heartbeat(g: GossipSub): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/pubsub/gossipsub/behavior.html#heartbeat%2CGossipSub">behavior: proc heartbeat(g: GossipSub): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="heartbeat: template heartbeat(name: string; interval: Duration; body: untyped): untyped" href="libp2p/utils/heartbeat.html#heartbeat.t%2Cstring%2CDuration%2Cuntyped">heartbeat: template heartbeat(name: string; interval: Duration; body: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="hex" href="#hex"><span>hex:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc hex(cid: Cid): string" href="libp2p/cid.html#hex%2CCid">cid: proc hex(cid: Cid): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc hex(value: MultiAddress): string" href="libp2p/multiaddress.html#hex%2CMultiAddress">multiaddress: proc hex(value: MultiAddress): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc hex(value: MultiHash): string" href="libp2p/multihash.html#hex%2CMultiHash">multihash: proc hex(value: MultiHash): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc hex(pid: PeerId): string" href="libp2p/peerid.html#hex%2CPeerId">peerid: proc hex(pid: PeerId): string</a></li>
          </ul></dd>
<dt><a name="high" href="#high"><span>high:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc high[T](o: OffsettedSeq[T]): int" href="libp2p/utils/offsettedseq.html#high%2COffsettedSeq%5BT%5D">offsettedseq: proc high[T](o: OffsettedSeq[T]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: proc high(vb: VBuffer): int" href="libp2p/vbuffer.html#high%2CVBuffer">vbuffer: proc high(vb: VBuffer): int</a></li>
          </ul></dd>
<dt><a name="hint" href="#hint"><span>hint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type hint" href="libp2p/varint.html#hint">varint: type hint</a></li>
          </ul></dd>
<dt><a name="hint32" href="#hint32"><span>hint32:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type hint32" href="libp2p/varint.html#hint32">varint: type hint32</a></li>
          </ul></dd>
<dt><a name="hint64" href="#hint64"><span>hint64:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type hint64" href="libp2p/varint.html#hint64">varint: type hint64</a></li>
          </ul></dd>
<dt><a name="hkdf" href="#hkdf"><span>hkdf:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="hkdf: proc hkdf[T: sha256; len: static int](_: type[T]; salt, ikm, info: openArray[byte];
                                 outputs: var openArray[HkdfResult[len]])" href="libp2p/crypto/hkdf.html#hkdf%2Ctype%5BT%5D%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D%2CopenArray%5Bbyte%5D%2CopenArray%5BHkdfResult%5Blen%5D%5D">hkdf: proc hkdf[T: sha256; len: static int](_: type[T]; salt, ikm, info: openArray[byte];
                                 outputs: var openArray[HkdfResult[len]])</a></li>
          </ul></dd>
<dt><a name="HkdfResult" href="#HkdfResult"><span>HkdfResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="hkdf: type HkdfResult" href="libp2p/crypto/hkdf.html#HkdfResult">hkdf: type HkdfResult</a></li>
          </ul></dd>
<dt><a name="HopMessage" href="#HopMessage"><span>HopMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object HopMessage" href="libp2p/protocols/connectivity/relay/messages.html#HopMessage">messages: object HopMessage</a></li>
          </ul></dd>
<dt><a name="HopMessageType" href="#HopMessageType"><span>HopMessageType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: enum HopMessageType" href="libp2p/protocols/connectivity/relay/messages.html#HopMessageType">messages: enum HopMessageType</a></li>
          </ul></dd>
<dt><a name="HTTP" href="#HTTP"><span>HTTP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const HTTP" href="libp2p/multiaddress.html#HTTP">multiaddress: const HTTP</a></li>
          </ul></dd>
<dt><a name="HttpCreated" href="#HttpCreated"><span>HttpCreated:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: const HttpCreated" href="libp2p/autotls/service.html#HttpCreated">service: const HttpCreated</a></li>
          </ul></dd>
<dt><a name="HttpOk" href="#HttpOk"><span>HttpOk:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: const HttpOk" href="libp2p/autotls/service.html#HttpOk">service: const HttpOk</a></li>
          </ul></dd>
<dt><a name="HTTPResponse" href="#HTTPResponse"><span>HTTPResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: object HTTPResponse" href="libp2p/autotls/acme/api.html#HTTPResponse">api: object HTTPResponse</a></li>
          </ul></dd>
<dt><a name="HTTPS" href="#HTTPS"><span>HTTPS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const HTTPS" href="libp2p/multiaddress.html#HTTPS">multiaddress: const HTTPS</a></li>
          </ul></dd>
<dt><a name="identify" href="#identify"><span>identify:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: proc identify(peerStore: PeerStore; muxer: Muxer): InternalRaisesFuture[void, (
    CancelledError, IdentityNoMatchError, IdentityInvalidMsgError,
    MultiStreamError, LPStreamError, MuxerError)]" href="libp2p/peerstore.html#identify%2CPeerStore%2CMuxer">peerstore: proc identify(peerStore: PeerStore; muxer: Muxer): InternalRaisesFuture[void, (
    CancelledError, IdentityNoMatchError, IdentityInvalidMsgError,
    MultiStreamError, LPStreamError, MuxerError)]</a></li>
          </ul></dd>
<dt><a name="Identify" href="#Identify"><span>Identify:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: type Identify" href="libp2p/protocols/identify.html#Identify">identify: type Identify</a></li>
          </ul></dd>
<dt><a name="identify" href="#identify"><span>identify:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: proc identify(self: Identify; conn: Connection; remotePeerId: PeerId): InternalRaisesFuture[
    IdentifyInfo, (IdentityInvalidMsgError, IdentityNoMatchError, LPStreamError,
                   CancelledError)]" href="libp2p/protocols/identify.html#identify%2CIdentify%2CConnection%2CPeerId">identify: proc identify(self: Identify; conn: Connection; remotePeerId: PeerId): InternalRaisesFuture[
    IdentifyInfo, (IdentityInvalidMsgError, IdentityNoMatchError, LPStreamError,
                   CancelledError)]</a></li>
          </ul></dd>
<dt><a name="IdentifyCodec" href="#IdentifyCodec"><span>IdentifyCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: const IdentifyCodec" href="libp2p/protocols/identify.html#IdentifyCodec">identify: const IdentifyCodec</a></li>
          </ul></dd>
<dt><a name="IdentifyError" href="#IdentifyError"><span>IdentifyError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: object IdentifyError" href="libp2p/protocols/identify.html#IdentifyError">identify: object IdentifyError</a></li>
          </ul></dd>
<dt><a name="IdentifyInfo" href="#IdentifyInfo"><span>IdentifyInfo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: object IdentifyInfo" href="libp2p/protocols/identify.html#IdentifyInfo">identify: object IdentifyInfo</a></li>
          </ul></dd>
<dt><a name="IdentifyNoPubKeyError" href="#IdentifyNoPubKeyError"><span>IdentifyNoPubKeyError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: object IdentifyNoPubKeyError" href="libp2p/protocols/identify.html#IdentifyNoPubKeyError">identify: object IdentifyNoPubKeyError</a></li>
          </ul></dd>
<dt><a name="IdentifyPush" href="#IdentifyPush"><span>IdentifyPush:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: type IdentifyPush" href="libp2p/protocols/identify.html#IdentifyPush">identify: type IdentifyPush</a></li>
          </ul></dd>
<dt><a name="IdentifyPushCodec" href="#IdentifyPushCodec"><span>IdentifyPushCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: const IdentifyPushCodec" href="libp2p/protocols/identify.html#IdentifyPushCodec">identify: const IdentifyPushCodec</a></li>
          </ul></dd>
<dt><a name="IdentifyPushHandler" href="#IdentifyPushHandler"><span>IdentifyPushHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: type IdentifyPushHandler" href="libp2p/protocols/identify.html#IdentifyPushHandler">identify: type IdentifyPushHandler</a></li>
          </ul></dd>
<dt><a name="IdentityInvalidMsgError" href="#IdentityInvalidMsgError"><span>IdentityInvalidMsgError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: object IdentityInvalidMsgError" href="libp2p/protocols/identify.html#IdentityInvalidMsgError">identify: object IdentityInvalidMsgError</a></li>
          </ul></dd>
<dt><a name="IdentityNoMatchError" href="#IdentityNoMatchError"><span>IdentityNoMatchError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: object IdentityNoMatchError" href="libp2p/protocols/identify.html#IdentityNoMatchError">identify: object IdentityNoMatchError</a></li>
          </ul></dd>
<dt><a name="IdentityPubKeySerializationError" href="#IdentityPubKeySerializationError"><span>IdentityPubKeySerializationError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object IdentityPubKeySerializationError" href="libp2p/transports/tls/certificate.html#IdentityPubKeySerializationError">certificate: object IdentityPubKeySerializationError</a></li>
          </ul></dd>
<dt><a name="IdentitySigningError" href="#IdentitySigningError"><span>IdentitySigningError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object IdentitySigningError" href="libp2p/transports/tls/certificate.html#IdentitySigningError">certificate: object IdentitySigningError</a></li>
          </ul></dd>
<dt><a name="IdLength" href="#IdLength"><span>IdLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const IdLength" href="libp2p/protocols/kademlia/types.html#IdLength">types: const IdLength</a></li>
          </ul></dd>
<dt><a name="IDontWantMaxCount" href="#IDontWantMaxCount"><span>IDontWantMaxCount:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const IDontWantMaxCount" href="libp2p/protocols/pubsub/gossipsub/types.html#IDontWantMaxCount">types: const IDontWantMaxCount</a></li>
          </ul></dd>
<dt><a name="iDontWantMessageSizeThreshold" href="#iDontWantMessageSizeThreshold"><span>iDontWantMessageSizeThreshold:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: const iDontWantMessageSizeThreshold" href="libp2p/protocols/pubsub/gossipsub.html#iDontWantMessageSizeThreshold">gossipsub: const iDontWantMessageSizeThreshold</a></li>
          </ul></dd>
<dt><a name="IHaveMaxLength" href="#IHaveMaxLength"><span>IHaveMaxLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const IHaveMaxLength" href="libp2p/protocols/pubsub/gossipsub/types.html#IHaveMaxLength">types: const IHaveMaxLength</a></li>
          </ul></dd>
<dt><a name="IHavePeerBudget" href="#IHavePeerBudget"><span>IHavePeerBudget:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const IHavePeerBudget" href="libp2p/protocols/pubsub/gossipsub/types.html#IHavePeerBudget">types: const IHavePeerBudget</a></li>
          </ul></dd>
<dt><a name="includeFile" href="#includeFile"><span>includeFile:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: macro includeFile(file: static[string]): untyped" href="libp2p/utility.html#includeFile.m%2Cstatic%5Bstring%5D">utility: macro includeFile(file: static[string]): untyped</a></li>
          </ul></dd>
<dt><a name="init" href="#init"><span>init:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc init(ctype: typedesc[Cid]; version: CidVersion; content: MultiCodec;
     hash: MultiHash): Result[Cid, CidError]" href="libp2p/cid.html#init%2Ctypedesc%5BCid%5D%2CCidVersion%2CMultiCodec%2CMultiHash">cid: proc init(ctype: typedesc[Cid]; version: CidVersion; content: MultiCodec;
     hash: MultiHash): Result[Cid, CidError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="cid: proc init[T: char | byte](ctype: typedesc[Cid]; data: openArray[T]): Result[Cid,
    CidError]" href="libp2p/cid.html#init%2Ctypedesc%5BCid%5D%2CopenArray%5BT%5D">cid: proc init[T: char | byte](ctype: typedesc[Cid]; data: openArray[T]): Result[Cid,
    CidError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(key: var PrivateKey; data: openArray[byte]): bool" href="libp2p/crypto/crypto.html#init%2CPrivateKey%2CopenArray%5Bbyte%5D">crypto: proc init(key: var PrivateKey; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(key: var PublicKey; data: openArray[byte]): bool" href="libp2p/crypto/crypto.html#init%2CPublicKey%2CopenArray%5Bbyte%5D">crypto: proc init(key: var PublicKey; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(sig: var Signature; data: openArray[byte]): bool" href="libp2p/crypto/crypto.html#init%2CSignature%2CopenArray%5Bbyte%5D">crypto: proc init(sig: var Signature; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(sig: var Signature; data: string): bool" href="libp2p/crypto/crypto.html#init%2CSignature%2Cstring">crypto: proc init(sig: var Signature; data: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init[T: PrivateKey | PublicKey](key: var T; data: string): bool" href="libp2p/crypto/crypto.html#init%2CT%2Cstring">crypto: proc init[T: PrivateKey | PublicKey](key: var T; data: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PrivateKey]; key: rsa.RsaPrivateKey): PrivateKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPrivateKey%5D%2C">crypto: proc init(t: typedesc[PrivateKey]; key: rsa.RsaPrivateKey): PrivateKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PrivateKey]; key: ecnist.EcPrivateKey): PrivateKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPrivateKey%5D%2C_2">crypto: proc init(t: typedesc[PrivateKey]; key: ecnist.EcPrivateKey): PrivateKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PrivateKey]; key: EdPrivateKey): PrivateKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPrivateKey%5D%2CEdPrivateKey">crypto: proc init(t: typedesc[PrivateKey]; key: EdPrivateKey): PrivateKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PrivateKey]; data: openArray[byte]): CryptoResult[PrivateKey]" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPrivateKey%5D%2CopenArray%5Bbyte%5D">crypto: proc init(t: typedesc[PrivateKey]; data: openArray[byte]): CryptoResult[PrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PrivateKey]; key: SkPrivateKey): PrivateKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPrivateKey%5D%2CSkPrivateKey">crypto: proc init(t: typedesc[PrivateKey]; key: SkPrivateKey): PrivateKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PrivateKey]; data: string): CryptoResult[PrivateKey]" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPrivateKey%5D%2Cstring">crypto: proc init(t: typedesc[PrivateKey]; data: string): CryptoResult[PrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PublicKey]; key: rsa.RsaPublicKey): PublicKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPublicKey%5D%2C">crypto: proc init(t: typedesc[PublicKey]; key: rsa.RsaPublicKey): PublicKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PublicKey]; key: ecnist.EcPublicKey): PublicKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPublicKey%5D%2C_2">crypto: proc init(t: typedesc[PublicKey]; key: ecnist.EcPublicKey): PublicKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PublicKey]; key: EdPublicKey): PublicKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPublicKey%5D%2CEdPublicKey">crypto: proc init(t: typedesc[PublicKey]; key: EdPublicKey): PublicKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PublicKey]; data: openArray[byte]): CryptoResult[PublicKey]" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPublicKey%5D%2CopenArray%5Bbyte%5D">crypto: proc init(t: typedesc[PublicKey]; data: openArray[byte]): CryptoResult[PublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PublicKey]; key: SkPublicKey): PublicKey" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPublicKey%5D%2CSkPublicKey">crypto: proc init(t: typedesc[PublicKey]; key: SkPublicKey): PublicKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[PublicKey]; data: string): CryptoResult[PublicKey]" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BPublicKey%5D%2Cstring">crypto: proc init(t: typedesc[PublicKey]; data: string): CryptoResult[PublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[Signature]; data: openArray[byte]): CryptoResult[Signature]" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BSignature%5D%2CopenArray%5Bbyte%5D">crypto: proc init(t: typedesc[Signature]; data: openArray[byte]): CryptoResult[Signature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc init(t: typedesc[Signature]; data: string): CryptoResult[Signature]" href="libp2p/crypto/crypto.html#init%2Ctypedesc%5BSignature%5D%2Cstring">crypto: proc init(t: typedesc[Signature]; data: string): CryptoResult[Signature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init(key: var EcPrivateKey; data: openArray[byte]): Result[void, Asn1Error]" href="libp2p/crypto/ecnist.html#init%2CEcPrivateKey%2CopenArray%5Bbyte%5D">ecnist: proc init(key: var EcPrivateKey; data: openArray[byte]): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init(pubkey: var EcPublicKey; data: openArray[byte]): Result[void, Asn1Error]" href="libp2p/crypto/ecnist.html#init%2CEcPublicKey%2CopenArray%5Bbyte%5D">ecnist: proc init(pubkey: var EcPublicKey; data: openArray[byte]): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init(sig: var EcSignature; data: openArray[byte]): Result[void, Asn1Error]" href="libp2p/crypto/ecnist.html#init%2CEcSignature%2CopenArray%5Bbyte%5D">ecnist: proc init(sig: var EcSignature; data: openArray[byte]): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init[T: EcPKI](sospk: var T; data: string): Result[void, Asn1Error]" href="libp2p/crypto/ecnist.html#init%2CT%2Cstring">ecnist: proc init[T: EcPKI](sospk: var T; data: string): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init(t: typedesc[EcPrivateKey]; data: openArray[byte]): EcResult[EcPrivateKey]" href="libp2p/crypto/ecnist.html#init%2Ctypedesc%5BEcPrivateKey%5D%2CopenArray%5Bbyte%5D">ecnist: proc init(t: typedesc[EcPrivateKey]; data: openArray[byte]): EcResult[EcPrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init(t: typedesc[EcPublicKey]; data: openArray[byte]): EcResult[EcPublicKey]" href="libp2p/crypto/ecnist.html#init%2Ctypedesc%5BEcPublicKey%5D%2CopenArray%5Bbyte%5D">ecnist: proc init(t: typedesc[EcPublicKey]; data: openArray[byte]): EcResult[EcPublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init(t: typedesc[EcSignature]; data: openArray[byte]): EcResult[EcSignature]" href="libp2p/crypto/ecnist.html#init%2Ctypedesc%5BEcSignature%5D%2CopenArray%5Bbyte%5D">ecnist: proc init(t: typedesc[EcSignature]; data: openArray[byte]): EcResult[EcSignature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc init[T: EcPKI](t: typedesc[T]; data: string): EcResult[T]" href="libp2p/crypto/ecnist.html#init%2Ctypedesc%5BT%5D%2Cstring">ecnist: proc init[T: EcPKI](t: typedesc[T]; data: string): EcResult[T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(key: var EdPrivateKey; data: openArray[byte]): bool" href="libp2p/crypto/ed25519/ed25519.html#init%2CEdPrivateKey%2CopenArray%5Bbyte%5D">ed25519: proc init(key: var EdPrivateKey; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(key: var EdPrivateKey; data: string): bool" href="libp2p/crypto/ed25519/ed25519.html#init%2CEdPrivateKey%2Cstring">ed25519: proc init(key: var EdPrivateKey; data: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(key: var EdPublicKey; data: openArray[byte]): bool" href="libp2p/crypto/ed25519/ed25519.html#init%2CEdPublicKey%2CopenArray%5Bbyte%5D">ed25519: proc init(key: var EdPublicKey; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(key: var EdPublicKey; data: string): bool" href="libp2p/crypto/ed25519/ed25519.html#init%2CEdPublicKey%2Cstring">ed25519: proc init(key: var EdPublicKey; data: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(sig: var EdSignature; data: openArray[byte]): bool" href="libp2p/crypto/ed25519/ed25519.html#init%2CEdSignature%2CopenArray%5Bbyte%5D">ed25519: proc init(sig: var EdSignature; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(sig: var EdSignature; data: string): bool" href="libp2p/crypto/ed25519/ed25519.html#init%2CEdSignature%2Cstring">ed25519: proc init(sig: var EdSignature; data: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(t: typedesc[EdPrivateKey]; data: openArray[byte]): Result[EdPrivateKey,
    EdError]" href="libp2p/crypto/ed25519/ed25519.html#init%2Ctypedesc%5BEdPrivateKey%5D%2CopenArray%5Bbyte%5D">ed25519: proc init(t: typedesc[EdPrivateKey]; data: openArray[byte]): Result[EdPrivateKey,
    EdError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(t: typedesc[EdPrivateKey]; data: string): Result[EdPrivateKey, EdError]" href="libp2p/crypto/ed25519/ed25519.html#init%2Ctypedesc%5BEdPrivateKey%5D%2Cstring">ed25519: proc init(t: typedesc[EdPrivateKey]; data: string): Result[EdPrivateKey, EdError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(t: typedesc[EdPublicKey]; data: openArray[byte]): Result[EdPublicKey,
    EdError]" href="libp2p/crypto/ed25519/ed25519.html#init%2Ctypedesc%5BEdPublicKey%5D%2CopenArray%5Bbyte%5D">ed25519: proc init(t: typedesc[EdPublicKey]; data: openArray[byte]): Result[EdPublicKey,
    EdError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(t: typedesc[EdPublicKey]; data: string): Result[EdPublicKey, EdError]" href="libp2p/crypto/ed25519/ed25519.html#init%2Ctypedesc%5BEdPublicKey%5D%2Cstring">ed25519: proc init(t: typedesc[EdPublicKey]; data: string): Result[EdPublicKey, EdError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(t: typedesc[EdSignature]; data: openArray[byte]): Result[EdSignature,
    EdError]" href="libp2p/crypto/ed25519/ed25519.html#init%2Ctypedesc%5BEdSignature%5D%2CopenArray%5Bbyte%5D">ed25519: proc init(t: typedesc[EdSignature]; data: openArray[byte]): Result[EdSignature,
    EdError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc init(t: typedesc[EdSignature]; data: string): Result[EdSignature, EdError]" href="libp2p/crypto/ed25519/ed25519.html#init%2Ctypedesc%5BEdSignature%5D%2Cstring">ed25519: proc init(t: typedesc[EdSignature]; data: string): Result[EdSignature, EdError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc init(t: typedesc[Asn1Buffer]): Asn1Buffer" href="libp2p/crypto/minasn1.html#init%2Ctypedesc%5BAsn1Buffer%5D">minasn1: proc init(t: typedesc[Asn1Buffer]): Asn1Buffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc init(t: typedesc[Asn1Buffer]; data: openArray[byte]): Asn1Buffer" href="libp2p/crypto/minasn1.html#init%2Ctypedesc%5BAsn1Buffer%5D%2CopenArray%5Bbyte%5D">minasn1: proc init(t: typedesc[Asn1Buffer]; data: openArray[byte]): Asn1Buffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc init(t: typedesc[Asn1Buffer]; data: string): Asn1Buffer" href="libp2p/crypto/minasn1.html#init%2Ctypedesc%5BAsn1Buffer%5D%2Cstring">minasn1: proc init(t: typedesc[Asn1Buffer]; data: string): Asn1Buffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc init(t: typedesc[Asn1Composite]; tag: Asn1Tag): Asn1Composite" href="libp2p/crypto/minasn1.html#init%2Ctypedesc%5BAsn1Composite%5D%2CAsn1Tag">minasn1: proc init(t: typedesc[Asn1Composite]; tag: Asn1Tag): Asn1Composite</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc init(t: typedesc[Asn1Composite]; idx: int): Asn1Composite" href="libp2p/crypto/minasn1.html#init%2Ctypedesc%5BAsn1Composite%5D%2Cint">minasn1: proc init(t: typedesc[Asn1Composite]; idx: int): Asn1Composite</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init(key: var RsaPrivateKey; data: openArray[byte]): Result[void, Asn1Error]" href="libp2p/crypto/rsa.html#init%2CRsaPrivateKey%2CopenArray%5Bbyte%5D">rsa: proc init(key: var RsaPrivateKey; data: openArray[byte]): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init(key: var RsaPublicKey; data: openArray[byte]): Result[void, Asn1Error]" href="libp2p/crypto/rsa.html#init%2CRsaPublicKey%2CopenArray%5Bbyte%5D">rsa: proc init(key: var RsaPublicKey; data: openArray[byte]): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init(sig: var RsaSignature; data: openArray[byte]): Result[void, Asn1Error]" href="libp2p/crypto/rsa.html#init%2CRsaSignature%2CopenArray%5Bbyte%5D">rsa: proc init(sig: var RsaSignature; data: openArray[byte]): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init[T: RsaPKI](sospk: var T; data: string): Result[void, Asn1Error]" href="libp2p/crypto/rsa.html#init%2CT%2Cstring">rsa: proc init[T: RsaPKI](sospk: var T; data: string): Result[void, Asn1Error]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init(t: typedesc[RsaPrivateKey]; data: openArray[byte]): RsaResult[RsaPrivateKey]" href="libp2p/crypto/rsa.html#init%2Ctypedesc%5BRsaPrivateKey%5D%2CopenArray%5Bbyte%5D">rsa: proc init(t: typedesc[RsaPrivateKey]; data: openArray[byte]): RsaResult[RsaPrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init(t: typedesc[RsaPublicKey]; data: openArray[byte]): RsaResult[RsaPublicKey]" href="libp2p/crypto/rsa.html#init%2Ctypedesc%5BRsaPublicKey%5D%2CopenArray%5Bbyte%5D">rsa: proc init(t: typedesc[RsaPublicKey]; data: openArray[byte]): RsaResult[RsaPublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init(t: typedesc[RsaSignature]; data: openArray[byte]): RsaResult[RsaSignature]" href="libp2p/crypto/rsa.html#init%2Ctypedesc%5BRsaSignature%5D%2CopenArray%5Bbyte%5D">rsa: proc init(t: typedesc[RsaSignature]; data: openArray[byte]): RsaResult[RsaSignature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc init[T: RsaPKI](t: typedesc[T]; data: string): T" href="libp2p/crypto/rsa.html#init%2Ctypedesc%5BT%5D%2Cstring">rsa: proc init[T: RsaPKI](t: typedesc[T]; data: string): T</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(key: var SkPrivateKey; data: openArray[byte]): SkResult[void]" href="libp2p/crypto/secp.html#init%2CSkPrivateKey%2CopenArray%5Bbyte%5D">secp: proc init(key: var SkPrivateKey; data: openArray[byte]): SkResult[void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(key: var SkPrivateKey; data: string): SkResult[void]" href="libp2p/crypto/secp.html#init%2CSkPrivateKey%2Cstring">secp: proc init(key: var SkPrivateKey; data: string): SkResult[void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(key: var SkPublicKey; data: openArray[byte]): SkResult[void]" href="libp2p/crypto/secp.html#init%2CSkPublicKey%2CopenArray%5Bbyte%5D">secp: proc init(key: var SkPublicKey; data: openArray[byte]): SkResult[void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(key: var SkPublicKey; data: string): SkResult[void]" href="libp2p/crypto/secp.html#init%2CSkPublicKey%2Cstring">secp: proc init(key: var SkPublicKey; data: string): SkResult[void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(sig: var SkSignature; data: openArray[byte]): SkResult[void]" href="libp2p/crypto/secp.html#init%2CSkSignature%2CopenArray%5Bbyte%5D">secp: proc init(sig: var SkSignature; data: openArray[byte]): SkResult[void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(sig: var SkSignature; data: string): SkResult[void]" href="libp2p/crypto/secp.html#init%2CSkSignature%2Cstring">secp: proc init(sig: var SkSignature; data: string): SkResult[void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(t: typedesc[SkPrivateKey]; data: openArray[byte]): SkResult[SkPrivateKey]" href="libp2p/crypto/secp.html#init%2Ctypedesc%5BSkPrivateKey%5D%2CopenArray%5Bbyte%5D">secp: proc init(t: typedesc[SkPrivateKey]; data: openArray[byte]): SkResult[SkPrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(t: typedesc[SkPrivateKey]; data: string): SkResult[SkPrivateKey]" href="libp2p/crypto/secp.html#init%2Ctypedesc%5BSkPrivateKey%5D%2Cstring">secp: proc init(t: typedesc[SkPrivateKey]; data: string): SkResult[SkPrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(t: typedesc[SkPublicKey]; data: openArray[byte]): SkResult[SkPublicKey]" href="libp2p/crypto/secp.html#init%2Ctypedesc%5BSkPublicKey%5D%2CopenArray%5Bbyte%5D">secp: proc init(t: typedesc[SkPublicKey]; data: openArray[byte]): SkResult[SkPublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(t: typedesc[SkPublicKey]; data: string): SkResult[SkPublicKey]" href="libp2p/crypto/secp.html#init%2Ctypedesc%5BSkPublicKey%5D%2Cstring">secp: proc init(t: typedesc[SkPublicKey]; data: string): SkResult[SkPublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(t: typedesc[SkSignature]; data: openArray[byte]): SkResult[SkSignature]" href="libp2p/crypto/secp.html#init%2Ctypedesc%5BSkSignature%5D%2CopenArray%5Bbyte%5D">secp: proc init(t: typedesc[SkSignature]; data: openArray[byte]): SkResult[SkSignature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc init(t: typedesc[SkSignature]; data: string): SkResult[SkSignature]" href="libp2p/crypto/secp.html#init%2Ctypedesc%5BSkSignature%5D%2Cstring">secp: proc init(t: typedesc[SkSignature]; data: string): SkResult[SkSignature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]): MultiAddress" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D">multiaddress: proc init(mtype: typedesc[MultiAddress]): MultiAddress</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]; address: IpAddress;
     protocol: IpTransportProtocol; port: Port): MultiAddress" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D%2CIpAddress%2CIpTransportProtocol%2CPort">multiaddress: proc init(mtype: typedesc[MultiAddress]; address: IpAddress;
     protocol: IpTransportProtocol; port: Port): MultiAddress</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]; protocol: MultiCodec; value: int): MaResult[
    MultiAddress]" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D%2CMultiCodec%2Cint">multiaddress: proc init(mtype: typedesc[MultiAddress]; protocol: MultiCodec; value: int): MaResult[
    MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]; protocol: MultiCodec;
     value: openArray[byte] = []): MaResult[MultiAddress]" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D%2CMultiCodec%2CopenArray%5Bbyte%5D">multiaddress: proc init(mtype: typedesc[MultiAddress]; protocol: MultiCodec;
     value: openArray[byte] = []): MaResult[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]; protocol: MultiCodec; value: PeerId): MaResult[
    MultiAddress]" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D%2CMultiCodec%2CPeerId">multiaddress: proc init(mtype: typedesc[MultiAddress]; protocol: MultiCodec; value: PeerId): MaResult[
    MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]; data: openArray[byte]): MaResult[
    MultiAddress]" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D%2CopenArray%5Bbyte%5D">multiaddress: proc init(mtype: typedesc[MultiAddress]; data: openArray[byte]): MaResult[
    MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]; value: string): MaResult[MultiAddress]" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D%2Cstring">multiaddress: proc init(mtype: typedesc[MultiAddress]; value: string): MaResult[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc init(mtype: typedesc[MultiAddress]; address: TransportAddress;
     protocol = IPPROTO_TCP): MaResult[MultiAddress]" href="libp2p/multiaddress.html#init%2Ctypedesc%5BMultiAddress%5D%2CTransportAddress">multiaddress: proc init(mtype: typedesc[MultiAddress]; address: TransportAddress;
     protocol = IPPROTO_TCP): MaResult[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc init[T](mhtype: typedesc[MultiHash]; hashcode: MultiCodec; mdigest: MDigest[T]): MhResult[
    MultiHash]" href="libp2p/multihash.html#init%2Ctypedesc%5BMultiHash%5D%2CMultiCodec%2CMDigest%5BT%5D">multihash: proc init[T](mhtype: typedesc[MultiHash]; hashcode: MultiCodec; mdigest: MDigest[T]): MhResult[
    MultiHash]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc init(mhtype: typedesc[MultiHash]; hashcode: MultiCodec; bdigest: openArray[byte]): MhResult[
    MultiHash]" href="libp2p/multihash.html#init%2Ctypedesc%5BMultiHash%5D%2CMultiCodec%2CopenArray%5Bbyte%5D">multihash: proc init(mhtype: typedesc[MultiHash]; hashcode: MultiCodec; bdigest: openArray[byte]): MhResult[
    MultiHash]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc init(mhtype: typedesc[MultiHash]; data: openArray[byte]): MhResult[MultiHash]" href="libp2p/multihash.html#init%2Ctypedesc%5BMultiHash%5D%2CopenArray%5Bbyte%5D">multihash: proc init(mhtype: typedesc[MultiHash]; data: openArray[byte]): MhResult[MultiHash]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc init(mhtype: typedesc[MultiHash]; data: string): MhResult[MultiHash]" href="libp2p/multihash.html#init%2Ctypedesc%5BMultiHash%5D%2Cstring">multihash: proc init(mhtype: typedesc[MultiHash]; data: string): MhResult[MultiHash]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc init[T](mhtype: typedesc[MultiHash]; hashname: string; mdigest: MDigest[T]): MhResult[
    MultiHash]" href="libp2p/multihash.html#init%2Ctypedesc%5BMultiHash%5D%2Cstring%2CMDigest%5BT%5D">multihash: proc init[T](mhtype: typedesc[MultiHash]; hashname: string; mdigest: MDigest[T]): MhResult[
    MultiHash]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc init(mhtype: typedesc[MultiHash]; hashname: string; bdigest: openArray[byte]): MhResult[
    MultiHash]" href="libp2p/multihash.html#init%2Ctypedesc%5BMultiHash%5D%2Cstring%2CopenArray%5Bbyte%5D">multihash: proc init(mhtype: typedesc[MultiHash]; hashname: string; bdigest: openArray[byte]): MhResult[
    MultiHash]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpchannel: proc init(L: type LPChannel; id: uint64; conn: Connection; initiator: bool;
     name: string = &quot;&quot;; timeout: Duration = DefaultChanTimeout): LPChannel" href="libp2p/muxers/mplex/lpchannel.html#init%2CtypeLPChannel%2Cuint64%2CConnection%2Cbool%2Cstring%2CDuration">lpchannel: proc init(L: type LPChannel; id: uint64; conn: Connection; initiator: bool;
     name: string = &quot;&quot;; timeout: Duration = DefaultChanTimeout): LPChannel</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc init(pid: var PeerId; data: openArray[byte]): bool" href="libp2p/peerid.html#init%2CPeerId%2CopenArray%5Bbyte%5D">peerid: proc init(pid: var PeerId; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc init(pid: var PeerId; data: string): bool" href="libp2p/peerid.html#init%2CPeerId%2Cstring">peerid: proc init(pid: var PeerId; data: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc init(t: typedesc[PeerId]; data: openArray[byte]): Result[PeerId, cstring]" href="libp2p/peerid.html#init%2Ctypedesc%5BPeerId%5D%2CopenArray%5Bbyte%5D">peerid: proc init(t: typedesc[PeerId]; data: openArray[byte]): Result[PeerId, cstring]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc init(t: typedesc[PeerId]; seckey: PrivateKey): Result[PeerId, cstring]" href="libp2p/peerid.html#init%2Ctypedesc%5BPeerId%5D%2CPrivateKey">peerid: proc init(t: typedesc[PeerId]; seckey: PrivateKey): Result[PeerId, cstring]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc init(t: typedesc[PeerId]; pubkey: PublicKey): Result[PeerId, cstring]" href="libp2p/peerid.html#init%2Ctypedesc%5BPeerId%5D%2CPublicKey">peerid: proc init(t: typedesc[PeerId]; pubkey: PublicKey): Result[PeerId, cstring]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc init(t: typedesc[PeerId]; data: string): Result[PeerId, cstring]" href="libp2p/peerid.html#init%2Ctypedesc%5BPeerId%5D%2Cstring">peerid: proc init(t: typedesc[PeerId]; data: string): Result[PeerId, cstring]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc init(T: typedesc[Voucher]; relayPeerId: PeerId; reservingPeerId: PeerId;
     expiration: uint64): T:type" href="libp2p/protocols/connectivity/relay/messages.html#init%2Ctypedesc%5BVoucher%5D%2CPeerId%2CPeerId%2Cuint64">messages: proc init(T: typedesc[Voucher]; relayPeerId: PeerId; reservingPeerId: PeerId;
     expiration: uint64): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="identify: proc init(p: IdentifyPush)" href="libp2p/protocols/identify.html#init%2CIdentifyPush">identify: proc init(p: IdentifyPush)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="identify: method init(p: Identify)" href="libp2p/protocols/identify.html#init.e%2CIdentify">identify: method init(p: Identify)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lookupstate: proc init(T: type LookupState; targetId: Key; initialPeers: seq[PeerId]; alpha: int;
     replication: int; hasher: Opt[XorDHasher]): T:type" href="libp2p/protocols/kademlia/lookupstate.html#init%2CtypeLookupState%2CKey%2Cseq%5BPeerId%5D%2Cint%2Cint%2COpt%5BXorDHasher%5D">lookupstate: proc init(T: type LookupState; targetId: Key; initialPeers: seq[PeerId]; alpha: int;
     replication: int; hasher: Opt[XorDHasher]): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc init(T: typedesc[EntryRecord]; value: Key; time: Opt[TimeStamp]): EntryRecord" href="libp2p/protocols/kademlia/types.html#init%2Ctypedesc%5BEntryRecord%5D%2CKey%2COpt%5BTimeStamp%5D">types: proc init(T: typedesc[EntryRecord]; value: Key; time: Opt[TimeStamp]): EntryRecord</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ping: method init(p: Ping)" href="libp2p/protocols/ping.html#init.e%2CPing">ping: method init(p: Ping)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protocol: method init(p: LPProtocol)" href="libp2p/protocols/protocol.html#init.e%2CLPProtocol">protocol: method init(p: LPProtocol)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bandwidth: proc init(T: type[BandwidthTracking]; alpha: float = DefaultAlpha): T:type" href="libp2p/protocols/pubsub/bandwidth.html#init%2Ctype%5BBandwidthTracking%5D%2Cfloat">bandwidth: proc init(T: type[BandwidthTracking]; alpha: float = DefaultAlpha): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bandwidth: proc init(T: type[ExponentialMovingAverage]; alpha: float = DefaultAlpha): T:type" href="libp2p/protocols/pubsub/bandwidth.html#init%2Ctype%5BExponentialMovingAverage%5D%2Cfloat">bandwidth: proc init(T: type[ExponentialMovingAverage]; alpha: float = DefaultAlpha): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="floodsub: method init(f: FloodSub)" href="libp2p/protocols/pubsub/floodsub.html#init.e%2CFloodSub">floodsub: method init(f: FloodSub)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: proc init(_: type[GossipSubParams]; pruneBackoff = 1.minutes;
     unsubscribeBackoff = 5.seconds; floodPublish = true;
     gossipFactor: float64 = 0.25; d = GossipSubD; dLow = GossipSubDlo;
     dHigh = GossipSubDhi; dScore = GossipSubDlo; dOut = 4 - 1;
     dLazy = GossipSubD; heartbeatInterval = GossipSubHeartbeatInterval;
     historyLength = GossipSubHistoryLength;
     historyGossip = GossipSubHistoryGossip; fanoutTTL = GossipSubFanoutTTL;
     seenTTL = 2.minutes; gossipThreshold = -100.0; publishThreshold = -1000.0;
     graylistThreshold = -10000.0; opportunisticGraftThreshold = 0.0;
     decayInterval = 1.seconds; decayToZero = 0.01; retainScore = 2.minutes;
     appSpecificWeight = 0.0; ipColocationFactorWeight = 0.0;
     ipColocationFactorThreshold = 1.0; behaviourPenaltyWeight = -1.0;
     behaviourPenaltyDecay = 0.999;
     directPeers = initTable[PeerId, seq[MultiAddress]]();
     disconnectBadPeers = false; enablePX = false;
     bandwidthEstimatebps = 100000000;
     overheadRateLimit = Opt.none(tuple[bytes: int, interval: Duration]);
     disconnectPeerAboveRateLimit = false; maxNumElementsInNonPriorityQueue = DefaultMaxNumElementsInNonPriorityQueue;
     sendIDontWantOnPublish = false): GossipSubParams" href="libp2p/protocols/pubsub/gossipsub.html#init%2Ctype%5BGossipSubParams%5D%2Cfloat64%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cfloat%2Cint">gossipsub: proc init(_: type[GossipSubParams]; pruneBackoff = 1.minutes;
     unsubscribeBackoff = 5.seconds; floodPublish = true;
     gossipFactor: float64 = 0.25; d = GossipSubD; dLow = GossipSubDlo;
     dHigh = GossipSubDhi; dScore = GossipSubDlo; dOut = 4 - 1;
     dLazy = GossipSubD; heartbeatInterval = GossipSubHeartbeatInterval;
     historyLength = GossipSubHistoryLength;
     historyGossip = GossipSubHistoryGossip; fanoutTTL = GossipSubFanoutTTL;
     seenTTL = 2.minutes; gossipThreshold = -100.0; publishThreshold = -1000.0;
     graylistThreshold = -10000.0; opportunisticGraftThreshold = 0.0;
     decayInterval = 1.seconds; decayToZero = 0.01; retainScore = 2.minutes;
     appSpecificWeight = 0.0; ipColocationFactorWeight = 0.0;
     ipColocationFactorThreshold = 1.0; behaviourPenaltyWeight = -1.0;
     behaviourPenaltyDecay = 0.999;
     directPeers = initTable[PeerId, seq[MultiAddress]]();
     disconnectBadPeers = false; enablePX = false;
     bandwidthEstimatebps = 100000000;
     overheadRateLimit = Opt.none(tuple[bytes: int, interval: Duration]);
     disconnectPeerAboveRateLimit = false; maxNumElementsInNonPriorityQueue = DefaultMaxNumElementsInNonPriorityQueue;
     sendIDontWantOnPublish = false): GossipSubParams</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: method init(g: GossipSub)" href="libp2p/protocols/pubsub/gossipsub.html#init.e%2CGossipSub">gossipsub: method init(g: GossipSub)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc init(T: typedesc[PeerSet]): T:type" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#init%2Ctypedesc%5BPeerSet%5D">preamblestore: proc init(T: typedesc[PeerSet]): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc init(T: typedesc[PreambleInfo]; preamble: ControlPreamble; sender: PubSubPeer;
     startsAt: Moment; expiresAt: Moment): T:type" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#init%2Ctypedesc%5BPreambleInfo%5D%2CControlPreamble%2CPubSubPeer%2CMoment%2CMoment">preamblestore: proc init(T: typedesc[PreambleInfo]; preamble: ControlPreamble; sender: PubSubPeer;
     startsAt: Moment; expiresAt: Moment): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc init(T: typedesc[PreambleStore]): T:type" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#init%2Ctypedesc%5BPreambleStore%5D">preamblestore: proc init(T: typedesc[PreambleStore]): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="scoring: proc init(_: type[TopicParams]): TopicParams" href="libp2p/protocols/pubsub/gossipsub/scoring.html#init%2Ctype%5BTopicParams%5D">scoring: proc init(_: type[TopicParams]): TopicParams</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mcache: proc init(T: type MCache; window, history: Natural): T:type" href="libp2p/protocols/pubsub/mcache.html#init%2CtypeMCache%2CNatural%2CNatural">mcache: proc init(T: type MCache; window, history: Natural): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: proc init[PubParams: object | bool](P: typedesc[PubSub]; switch: Switch;
                               triggerSelf: bool = false;
                               anonymize: bool = false;
                               verifySignature: bool = true; sign: bool = true;
    msgIdProvider: MsgIdProvider = defaultMsgIdProvider; subscriptionValidator: SubscriptionValidator = nil;
                               maxMessageSize: int = 1024 * 1024;
                               rng: ref HmacDrbgContext = newRng();
                               parameters: PubParams = false;
    customConnCallbacks: Option[CustomConnectionCallbacks] = none(
    CustomConnectionCallbacks)): P:type" href="libp2p/protocols/pubsub/pubsub.html#init%2Ctypedesc%5BPubSub%5D%2CSwitch%2Cbool%2Cbool%2Cbool%2Cbool%2CMsgIdProvider%2CSubscriptionValidator%2Cint%2Cref.HmacDrbgContext%2CPubParams%2COption%5BCustomConnectionCallbacks%5D">pubsub: proc init[PubParams: object | bool](P: typedesc[PubSub]; switch: Switch;
                               triggerSelf: bool = false;
                               anonymize: bool = false;
                               verifySignature: bool = true; sign: bool = true;
    msgIdProvider: MsgIdProvider = defaultMsgIdProvider; subscriptionValidator: SubscriptionValidator = nil;
                               maxMessageSize: int = 1024 * 1024;
                               rng: ref HmacDrbgContext = newRng();
                               parameters: PubParams = false;
    customConnCallbacks: Option[CustomConnectionCallbacks] = none(
    CustomConnectionCallbacks)): P:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="message: proc init(T: type Message; peer: Option[PeerInfo]; data: seq[byte]; topic: string;
     seqno: Option[uint64]; sign: bool = true): Message" href="libp2p/protocols/pubsub/rpc/message.html#init%2CtypeMessage%2COption%5BPeerInfo%5D%2Cseq%5Bbyte%5D%2Cstring%2COption%5Buint64%5D%2Cbool">message: proc init(T: type Message; peer: Option[PeerInfo]; data: seq[byte]; topic: string;
     seqno: Option[uint64]; sign: bool = true): Message</a></li>
          <li><a class="reference external"
          data-doc-search-tag="message: proc init(T: type Message; peerId: PeerId; data: seq[byte]; topic: string;
     seqno: Option[uint64]): Message" href="libp2p/protocols/pubsub/rpc/message.html#init%2CtypeMessage%2CPeerId%2Cseq%5Bbyte%5D%2Cstring%2COption%5Buint64%5D">message: proc init(T: type Message; peerId: PeerId; data: seq[byte]; topic: string;
     seqno: Option[uint64]): Message</a></li>
          <li><a class="reference external"
          data-doc-search-tag="timedcache: proc init[K](T: type TimedCache[K]; timeout: Duration = Timeout; maxSize: int = 0): T:type" href="libp2p/protocols/pubsub/timedcache.html#init%2CtypeTimedCache%5BK%5D%2CDuration%2Cint">timedcache: proc init[K](T: type TimedCache[K]; timeout: Duration = Timeout; maxSize: int = 0): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="noise: method init(p: Noise)" href="libp2p/protocols/secure/noise.html#init.e%2CNoise">noise: method init(p: Noise)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: method init(s: Secure)" href="libp2p/protocols/secure/secure.html#init.e%2CSecure">secure: method init(s: Secure)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routing_record: proc init(T: typedesc[PeerRecord]; peerId: PeerId; addresses: seq[MultiAddress];
     seqNo = toUnix(getTime()).uint64): T:type" href="libp2p/routing_record.html#init%2Ctypedesc%5BPeerRecord%5D%2CPeerId%2Cseq%5BMultiAddress%5D">routing_record: proc init(T: typedesc[PeerRecord]; peerId: PeerId; addresses: seq[MultiAddress];
     seqNo = toUnix(getTime()).uint64): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc init(T: typedesc[Envelope]; privateKey: PrivateKey; payloadType: seq[byte];
     payload: seq[byte]; domain: string): Result[Envelope, CryptoError]" href="libp2p/signed_envelope.html#init%2Ctypedesc%5BEnvelope%5D%2CPrivateKey%2Cseq%5Bbyte%5D%2Cseq%5Bbyte%5D%2Cstring">signed_envelope: proc init(T: typedesc[Envelope]; privateKey: PrivateKey; payloadType: seq[byte];
     payload: seq[byte]; domain: string): Result[Envelope, CryptoError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc init[T](_: typedesc[SignedPayload[T]]; privateKey: PrivateKey; data: T): Result[
    SignedPayload[T], CryptoError]" href="libp2p/signed_envelope.html#init%2Ctypedesc%5BSignedPayload%5BT%5D%5D%2CPrivateKey%2CT">signed_envelope: proc init[T](_: typedesc[SignedPayload[T]]; privateKey: PrivateKey; data: T): Result[
    SignedPayload[T], CryptoError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: proc init(C: type ChronosStream; client: StreamTransport; dir: Direction;
     timeout = DefaultChronosStreamTimeout; observedAddr: Opt[MultiAddress];
     localAddr: Opt[MultiAddress]): ChronosStream" href="libp2p/stream/chronosstream.html#init%2CtypeChronosStream%2CStreamTransport%2CDirection%2COpt%5BMultiAddress%5D%2COpt%5BMultiAddress%5D">chronosstream: proc init(C: type ChronosStream; client: StreamTransport; dir: Direction;
     timeout = DefaultChronosStreamTimeout; observedAddr: Opt[MultiAddress];
     localAddr: Opt[MultiAddress]): ChronosStream</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bytesview: proc init(t: typedesc[BytesView]; data: sink seq[byte]): BytesView" href="libp2p/utils/bytesview.html#init%2Ctypedesc%5BBytesView%5D%2Csinkseq%5Bbyte%5D">bytesview: proc init(t: typedesc[BytesView]; data: sink seq[byte]): BytesView</a></li>
          </ul></dd>
<dt><a name="init58" href="#init58"><span>init58:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: proc init58(mhtype: typedesc[MultiHash]; data: string): MultiHash" href="libp2p/multihash.html#init58%2Ctypedesc%5BMultiHash%5D%2Cstring">multihash: proc init58(mhtype: typedesc[MultiHash]; data: string): MultiHash</a></li>
          </ul></dd>
<dt><a name="InitializationError" href="#InitializationError"><span>InitializationError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: object InitializationError" href="libp2p/protocols/pubsub/pubsub.html#InitializationError">pubsub: object InitializationError</a></li>
          </ul></dd>
<dt><a name="initialize" href="#initialize"><span>initialize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: proc initialize(self: Transport)" href="libp2p/transports/transport.html#initialize%2CTransport">transport: proc initialize(self: Transport)</a></li>
          </ul></dd>
<dt><a name="initOffsettedSeq" href="#initOffsettedSeq"><span>initOffsettedSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc initOffsettedSeq[T](offset: int = 0): OffsettedSeq[T]" href="libp2p/utils/offsettedseq.html#initOffsettedSeq%2Cint">offsettedseq: proc initOffsettedSeq[T](offset: int = 0): OffsettedSeq[T]</a></li>
          </ul></dd>
<dt><a name="initProtoBuffer" href="#initProtoBuffer"><span>initProtoBuffer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc initProtoBuffer(data: openArray[byte]; offset = 0; options: set[ProtoFlags] = {}): ProtoBuffer" href="libp2p/protobuf/minprotobuf.html#initProtoBuffer%2CopenArray%5Bbyte%5D%2Cint%2Cset%5BProtoFlags%5D">minprotobuf: proc initProtoBuffer(data: openArray[byte]; offset = 0; options: set[ProtoFlags] = {}): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc initProtoBuffer(data: seq[byte]; offset = 0; options: set[ProtoFlags] = {}): ProtoBuffer" href="libp2p/protobuf/minprotobuf.html#initProtoBuffer%2Cseq%5Bbyte%5D%2Cint%2Cset%5BProtoFlags%5D">minprotobuf: proc initProtoBuffer(data: seq[byte]; offset = 0; options: set[ProtoFlags] = {}): ProtoBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc initProtoBuffer(options: set[ProtoFlags] = {}): ProtoBuffer" href="libp2p/protobuf/minprotobuf.html#initProtoBuffer%2Cset%5BProtoFlags%5D">minprotobuf: proc initProtoBuffer(options: set[ProtoFlags] = {}): ProtoBuffer</a></li>
          </ul></dd>
<dt><a name="initPubSub" href="#initPubSub"><span>initPubSub:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: method initPubSub(f: FloodSub)" href="libp2p/protocols/pubsub/floodsub.html#initPubSub.e%2CFloodSub">floodsub: method initPubSub(f: FloodSub)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: method initPubSub(g: GossipSub)" href="libp2p/protocols/pubsub/gossipsub.html#initPubSub.e%2CGossipSub">gossipsub: method initPubSub(g: GossipSub)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method initPubSub(p: PubSub)" href="libp2p/protocols/pubsub/pubsub.html#initPubSub.e%2CPubSub">pubsub: method initPubSub(p: PubSub)</a></li>
          </ul></dd>
<dt><a name="initRaw" href="#initRaw"><span>initRaw:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw(key: var EcPrivateKey; data: openArray[byte]): bool" href="libp2p/crypto/ecnist.html#initRaw%2CEcPrivateKey%2CopenArray%5Bbyte%5D">ecnist: proc initRaw(key: var EcPrivateKey; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw(pubkey: var EcPublicKey; data: openArray[byte]): bool" href="libp2p/crypto/ecnist.html#initRaw%2CEcPublicKey%2CopenArray%5Bbyte%5D">ecnist: proc initRaw(pubkey: var EcPublicKey; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw(sig: var EcSignature; data: openArray[byte]): bool" href="libp2p/crypto/ecnist.html#initRaw%2CEcSignature%2CopenArray%5Bbyte%5D">ecnist: proc initRaw(sig: var EcSignature; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw[T: EcPKI](sospk: var T; data: string): bool" href="libp2p/crypto/ecnist.html#initRaw%2CT%2Cstring">ecnist: proc initRaw[T: EcPKI](sospk: var T; data: string): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw(t: typedesc[EcPrivateKey]; data: openArray[byte]): EcResult[EcPrivateKey]" href="libp2p/crypto/ecnist.html#initRaw%2Ctypedesc%5BEcPrivateKey%5D%2CopenArray%5Bbyte%5D">ecnist: proc initRaw(t: typedesc[EcPrivateKey]; data: openArray[byte]): EcResult[EcPrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw(t: typedesc[EcPublicKey]; data: openArray[byte]): EcResult[EcPublicKey]" href="libp2p/crypto/ecnist.html#initRaw%2Ctypedesc%5BEcPublicKey%5D%2CopenArray%5Bbyte%5D">ecnist: proc initRaw(t: typedesc[EcPublicKey]; data: openArray[byte]): EcResult[EcPublicKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw(t: typedesc[EcSignature]; data: openArray[byte]): EcResult[EcSignature]" href="libp2p/crypto/ecnist.html#initRaw%2Ctypedesc%5BEcSignature%5D%2CopenArray%5Bbyte%5D">ecnist: proc initRaw(t: typedesc[EcSignature]; data: openArray[byte]): EcResult[EcSignature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc initRaw[T: EcPKI](t: typedesc[T]; data: string): T" href="libp2p/crypto/ecnist.html#initRaw%2Ctypedesc%5BT%5D%2Cstring">ecnist: proc initRaw[T: EcPKI](t: typedesc[T]; data: string): T</a></li>
          </ul></dd>
<dt><a name="initStream" href="#initStream"><span>initStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: method initStream(s: LPChannel)" href="libp2p/muxers/mplex/lpchannel.html#initStream.e%2CLPChannel">lpchannel: method initStream(s: LPChannel)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: method initStream(s: SecureConn)" href="libp2p/protocols/secure/secure.html#initStream.e%2CSecureConn">secure: method initStream(s: SecureConn)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bufferstream: method initStream(s: BufferStream)" href="libp2p/stream/bufferstream.html#initStream.e%2CBufferStream">bufferstream: method initStream(s: BufferStream)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method initStream(s: ChronosStream)" href="libp2p/stream/chronosstream.html#initStream.e%2CChronosStream">chronosstream: method initStream(s: ChronosStream)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: method initStream(s: Connection)" href="libp2p/stream/connection.html#initStream.e%2CConnection">connection: method initStream(s: Connection)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method initStream(s: LPStream)" href="libp2p/stream/lpstream.html#initStream.e%2CLPStream">lpstream: method initStream(s: LPStream)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method initStream(s: WsStream)" href="libp2p/transports/wstransport.html#initStream.e%2CWsStream">wstransport: method initStream(s: WsStream)</a></li>
          </ul></dd>
<dt><a name="initTAddress" href="#initTAddress"><span>initTAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wire: proc initTAddress(ma: MultiAddress): MaResult[TransportAddress]" href="libp2p/wire.html#initTAddress%2CMultiAddress">wire: proc initTAddress(ma: MultiAddress): MaResult[TransportAddress]</a></li>
          </ul></dd>
<dt><a name="initVBuffer" href="#initVBuffer"><span>initVBuffer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc initVBuffer(): VBuffer" href="libp2p/vbuffer.html#initVBuffer">vbuffer: proc initVBuffer(): VBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: proc initVBuffer(data: openArray[byte]; offset = 0): VBuffer" href="libp2p/vbuffer.html#initVBuffer%2CopenArray%5Bbyte%5D%2Cint">vbuffer: proc initVBuffer(data: openArray[byte]; offset = 0): VBuffer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: proc initVBuffer(data: seq[byte]; offset = 0): VBuffer" href="libp2p/vbuffer.html#initVBuffer%2Cseq%5Bbyte%5D%2Cint">vbuffer: proc initVBuffer(data: seq[byte]; offset = 0): VBuffer</a></li>
          </ul></dd>
<dt><a name="insert" href="#insert"><span>insert:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routingtable: proc insert(rtable: var RoutingTable; nodeId: Key): bool" href="libp2p/protocols/kademlia/routingtable.html#insert%2CRoutingTable%2CKey">routingtable: proc insert(rtable: var RoutingTable; nodeId: Key): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routingtable: proc insert(rtable: var RoutingTable; peerId: PeerId): bool" href="libp2p/protocols/kademlia/routingtable.html#insert%2CRoutingTable%2CPeerId">routingtable: proc insert(rtable: var RoutingTable; peerId: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc insert(self: var LocalTable; key: Key; value: sink seq[byte]; time: TimeStamp)" href="libp2p/protocols/kademlia/types.html#insert%2CLocalTable%2CKey%2Csinkseq%5Bbyte%5D%2CTimeStamp">types: proc insert(self: var LocalTable; key: Key; value: sink seq[byte]; time: TimeStamp)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc insert(ps: var PreambleStore; msgId: MessageId; info: PreambleInfo)" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#insert%2CPreambleStore%2CMessageId%2CPreambleInfo">preamblestore: proc insert(ps: var PreambleStore; msgId: MessageId; info: PreambleInfo)</a></li>
          </ul></dd>
<dt><a name="InternalError" href="#InternalError"><span>InternalError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: ResponseStatus.InternalError" href="libp2p/protocols/connectivity/autonat/types.html#InternalError">types: ResponseStatus.InternalError</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.InternalError" href="libp2p/protocols/rendezvous/protobuf.html#InternalError">protobuf: ResponseStatus.InternalError</a></li>
          </ul></dd>
<dt><a name="intoChaChaPolyKey" href="#intoChaChaPolyKey"><span>intoChaChaPolyKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: proc intoChaChaPolyKey(s: openArray[byte]): ChaChaPolyKey" href="libp2p/crypto/chacha20poly1305.html#intoChaChaPolyKey%2CopenArray%5Bbyte%5D">chacha20poly1305: proc intoChaChaPolyKey(s: openArray[byte]): ChaChaPolyKey</a></li>
          </ul></dd>
<dt><a name="intoChaChaPolyNonce" href="#intoChaChaPolyNonce"><span>intoChaChaPolyNonce:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: proc intoChaChaPolyNonce(s: openArray[byte]): ChaChaPolyNonce" href="libp2p/crypto/chacha20poly1305.html#intoChaChaPolyNonce%2CopenArray%5Bbyte%5D">chacha20poly1305: proc intoChaChaPolyNonce(s: openArray[byte]): ChaChaPolyNonce</a></li>
          </ul></dd>
<dt><a name="intoChaChaPolyTag" href="#intoChaChaPolyTag"><span>intoChaChaPolyTag:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="chacha20poly1305: proc intoChaChaPolyTag(s: openArray[byte]): ChaChaPolyTag" href="libp2p/crypto/chacha20poly1305.html#intoChaChaPolyTag%2CopenArray%5Bbyte%5D">chacha20poly1305: proc intoChaChaPolyTag(s: openArray[byte]): ChaChaPolyTag</a></li>
          </ul></dd>
<dt><a name="intoCurve25519Key" href="#intoCurve25519Key"><span>intoCurve25519Key:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: proc intoCurve25519Key(s: openArray[byte]): Curve25519Key" href="libp2p/crypto/curve25519.html#intoCurve25519Key%2CopenArray%5Bbyte%5D">curve25519: proc intoCurve25519Key(s: openArray[byte]): Curve25519Key</a></li>
          </ul></dd>
<dt><a name="InvalidChannelIdError" href="#InvalidChannelIdError"><span>InvalidChannelIdError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mplex: object InvalidChannelIdError" href="libp2p/muxers/mplex/mplex.html#InvalidChannelIdError">mplex: object InvalidChannelIdError</a></li>
          </ul></dd>
<dt><a name="InvalidCookie" href="#InvalidCookie"><span>InvalidCookie:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.InvalidCookie" href="libp2p/protocols/rendezvous/protobuf.html#InvalidCookie">protobuf: ResponseStatus.InvalidCookie</a></li>
          </ul></dd>
<dt><a name="InvalidMplexMsgType" href="#InvalidMplexMsgType"><span>InvalidMplexMsgType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="coder: object InvalidMplexMsgType" href="libp2p/muxers/mplex/coder.html#InvalidMplexMsgType">coder: object InvalidMplexMsgType</a></li>
          </ul></dd>
<dt><a name="InvalidMultiCodec" href="#InvalidMultiCodec"><span>InvalidMultiCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multicodec: const InvalidMultiCodec" href="libp2p/multicodec.html#InvalidMultiCodec">multicodec: const InvalidMultiCodec</a></li>
          </ul></dd>
<dt><a name="InvalidNamespace" href="#InvalidNamespace"><span>InvalidNamespace:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.InvalidNamespace" href="libp2p/protocols/rendezvous/protobuf.html#InvalidNamespace">protobuf: ResponseStatus.InvalidNamespace</a></li>
          </ul></dd>
<dt><a name="InvalidSignedPeerRecord" href="#InvalidSignedPeerRecord"><span>InvalidSignedPeerRecord:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.InvalidSignedPeerRecord" href="libp2p/protocols/rendezvous/protobuf.html#InvalidSignedPeerRecord">protobuf: ResponseStatus.InvalidSignedPeerRecord</a></li>
          </ul></dd>
<dt><a name="InvalidTTL" href="#InvalidTTL"><span>InvalidTTL:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.InvalidTTL" href="libp2p/protocols/rendezvous/protobuf.html#InvalidTTL">protobuf: ResponseStatus.InvalidTTL</a></li>
          </ul></dd>
<dt><a name="InvalidVarintError" href="#InvalidVarintError"><span>InvalidVarintError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object InvalidVarintError" href="libp2p/stream/lpstream.html#InvalidVarintError">lpstream: object InvalidVarintError</a></li>
          </ul></dd>
<dt><a name="IP" href="#IP"><span>IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const IP" href="libp2p/multiaddress.html#IP">multiaddress: const IP</a></li>
          </ul></dd>
<dt><a name="IP4" href="#IP4"><span>IP4:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const IP4" href="libp2p/multiaddress.html#IP4">multiaddress: const IP4</a></li>
          </ul></dd>
<dt><a name="IP6" href="#IP6"><span>IP6:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const IP6" href="libp2p/multiaddress.html#IP6">multiaddress: const IP6</a></li>
          </ul></dd>
<dt><a name="ipAddrMatches" href="#ipAddrMatches"><span>ipAddrMatches:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc ipAddrMatches(lookup: MultiAddress; addrs: seq[MultiAddress]; ip4: bool = true): bool" href="libp2p/utils/ipaddr.html#ipAddrMatches%2CMultiAddress%2Cseq%5BMultiAddress%5D%2Cbool">ipaddr: proc ipAddrMatches(lookup: MultiAddress; addrs: seq[MultiAddress]; ip4: bool = true): bool</a></li>
          </ul></dd>
<dt><a name="IPFS" href="#IPFS"><span>IPFS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const IPFS" href="libp2p/multiaddress.html#IPFS">multiaddress: const IPFS</a></li>
          </ul></dd>
<dt><a name="ipSupport" href="#ipSupport"><span>ipSupport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc ipSupport(addrs: seq[MultiAddress]): (bool, bool)" href="libp2p/utils/ipaddr.html#ipSupport%2Cseq%5BMultiAddress%5D">ipaddr: proc ipSupport(addrs: seq[MultiAddress]): (bool, bool)</a></li>
          </ul></dd>
<dt><a name="IpTransportProtocol" href="#IpTransportProtocol"><span>IpTransportProtocol:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: enum IpTransportProtocol" href="libp2p/multiaddress.html#IpTransportProtocol">multiaddress: enum IpTransportProtocol</a></li>
          </ul></dd>
<dt><a name="isConnected" href="#isConnected"><span>isConnected:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: proc isConnected(s: Switch; peerId: PeerId): bool" href="libp2p/switch.html#isConnected%2CSwitch%2CPeerId">switch: proc isConnected(s: Switch; peerId: PeerId): bool</a></li>
          </ul></dd>
<dt><a name="isEmpty" href="#isEmpty"><span>isEmpty:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: template isEmpty(ab: Asn1Buffer): bool" href="libp2p/crypto/minasn1.html#isEmpty.t%2CAsn1Buffer">minasn1: template isEmpty(ab: Asn1Buffer): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc isEmpty(ma: MultiAddress): bool" href="libp2p/multiaddress.html#isEmpty%2CMultiAddress">multiaddress: proc isEmpty(ma: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: template isEmpty(pb: ProtoBuffer): bool" href="libp2p/protobuf/minprotobuf.html#isEmpty.t%2CProtoBuffer">minprotobuf: template isEmpty(pb: ProtoBuffer): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="zeroqueue: proc isEmpty(q: ZeroQueue): bool" href="libp2p/utils/zeroqueue.html#isEmpty%2CZeroQueue">zeroqueue: proc isEmpty(q: ZeroQueue): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: template isEmpty(vb: VBuffer): bool" href="libp2p/vbuffer.html#isEmpty.t%2CVBuffer">vbuffer: template isEmpty(vb: VBuffer): bool</a></li>
          </ul></dd>
<dt><a name="isEnough" href="#isEnough"><span>isEnough:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: template isEnough(ab: Asn1Buffer; length: int64): bool" href="libp2p/crypto/minasn1.html#isEnough.t%2CAsn1Buffer%2Cint64">minasn1: template isEnough(ab: Asn1Buffer; length: int64): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: template isEnough(pb: ProtoBuffer; length: uint64): bool" href="libp2p/protobuf/minprotobuf.html#isEnough.t%2CProtoBuffer%2Cuint64">minprotobuf: template isEnough(pb: ProtoBuffer; length: uint64): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: template isEnough(vb: VBuffer; length: int): bool" href="libp2p/vbuffer.html#isEnough.t%2CVBuffer%2Cint">vbuffer: template isEnough(vb: VBuffer; length: int): bool</a></li>
          </ul></dd>
<dt><a name="isFull" href="#isFull"><span>isFull:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc isFull(pk: ProvidedKeys): bool" href="libp2p/protocols/kademlia/provider.html#isFull%2CProvidedKeys">provider: proc isFull(pk: ProvidedKeys): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc isFull(pr: ProviderRecords): bool" href="libp2p/protocols/kademlia/provider.html#isFull%2CProviderRecords">provider: proc isFull(pr: ProviderRecords): bool</a></li>
          </ul></dd>
<dt><a name="isIPv4" href="#isIPv4"><span>isIPv4:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc isIPv4(ip: IpAddress): bool" href="libp2p/utils/ipaddr.html#isIPv4%2CIpAddress">ipaddr: proc isIPv4(ip: IpAddress): bool</a></li>
          </ul></dd>
<dt><a name="isIPv6" href="#isIPv6"><span>isIPv6:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc isIPv6(ip: IpAddress): bool" href="libp2p/utils/ipaddr.html#isIPv6%2CIpAddress">ipaddr: proc isIPv6(ip: IpAddress): bool</a></li>
          </ul></dd>
<dt><a name="isPrivate" href="#isPrivate"><span>isPrivate:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc isPrivate(ip: IpAddress): bool" href="libp2p/utils/ipaddr.html#isPrivate%2CIpAddress">ipaddr: proc isPrivate(ip: IpAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ipaddr: proc isPrivate(ip: string): bool" href="libp2p/utils/ipaddr.html#isPrivate%2Cstring">ipaddr: proc isPrivate(ip: string): bool</a></li>
          </ul></dd>
<dt><a name="isPublic" href="#isPublic"><span>isPublic:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ipaddr: proc isPublic(ip: IpAddress): bool" href="libp2p/utils/ipaddr.html#isPublic%2CIpAddress">ipaddr: proc isPublic(ip: IpAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ipaddr: proc isPublic(ip: string): bool" href="libp2p/utils/ipaddr.html#isPublic%2Cstring">ipaddr: proc isPublic(ip: string): bool</a></li>
          </ul></dd>
<dt><a name="isPublicMA" href="#isPublicMA"><span>isPublicMA:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wire: proc isPublicMA(ma: MultiAddress): bool" href="libp2p/wire.html#isPublicMA%2CMultiAddress">wire: proc isPublicMA(ma: MultiAddress): bool</a></li>
          </ul></dd>
<dt><a name="isReachable" href="#isReachable"><span>isReachable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc isReachable(self: NetworkReachability): bool" href="libp2p/protocols/connectivity/autonat/types.html#isReachable%2CNetworkReachability">types: proc isReachable(self: NetworkReachability): bool</a></li>
          </ul></dd>
<dt><a name="isRelayed" href="#isRelayed"><span>isRelayed:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: proc isRelayed(conn: Connection): bool" href="libp2p/protocols/connectivity/relay/relay.html#isRelayed%2CConnection">relay: proc isRelayed(conn: Connection): bool</a></li>
          </ul></dd>
<dt><a name="isStale" href="#isStale"><span>isStale:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routingtable: proc isStale(bucket: Bucket): bool" href="libp2p/protocols/kademlia/routingtable.html#isStale%2CBucket">routingtable: proc isStale(bucket: Bucket): bool</a></li>
          </ul></dd>
<dt><a name="isValid" href="#isValid"><span>isValid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: method isValid(self: DefaultEntryValidator; key: Key; record: EntryRecord): bool" href="libp2p/protocols/kademlia/types.html#isValid.e%2CDefaultEntryValidator%2CKey%2CEntryRecord">types: method isValid(self: DefaultEntryValidator; key: Key; record: EntryRecord): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: method isValid(self: EntryValidator; key: Key; record: EntryRecord): bool" href="libp2p/protocols/kademlia/types.html#isValid.e%2CEntryValidator%2CKey%2CEntryRecord">types: method isValid(self: EntryValidator; key: Key; record: EntryRecord): bool</a></li>
          </ul></dd>
<dt><a name="items" href="#items"><span>items:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: iterator items(ma: MultiAddress): MaResult[MultiAddress]" href="libp2p/multiaddress.html#items.i%2CMultiAddress">multiaddress: iterator items(ma: MultiAddress): MaResult[MultiAddress]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="offsettedseq: iterator items[T](o: OffsettedSeq[T]): T" href="libp2p/utils/offsettedseq.html#items.i%2COffsettedSeq%5BT%5D">offsettedseq: iterator items[T](o: OffsettedSeq[T]): T</a></li>
          </ul></dd>
<dt><a name="iv" href="#iv"><span>iv:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc iv(secret: Secret; id: int): seq[byte]" href="libp2p/crypto/crypto.html#iv%2CSecret%2Cint">crypto: proc iv(secret: Secret; id: int): seq[byte]</a></li>
          </ul></dd>
<dt><a name="ivOpenArray" href="#ivOpenArray"><span>ivOpenArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: template ivOpenArray(secret: Secret; id: int): untyped" href="libp2p/crypto/crypto.html#ivOpenArray.t%2CSecret%2Cint">crypto: template ivOpenArray(secret: Secret; id: int): untyped</a></li>
          </ul></dd>
<dt><a name="join" href="#join"><span>join:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: method join(s: LPStream): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/stream/lpstream.html#join.e%2CLPStream">lpstream: method join(s: LPStream): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="KadCodec" href="#KadCodec"><span>KadCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const KadCodec" href="libp2p/protocols/kademlia/types.html#KadCodec">types: const KadCodec</a></li>
          </ul></dd>
<dt><a name="KadDHT" href="#KadDHT"><span>KadDHT:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type KadDHT" href="libp2p/protocols/kademlia/types.html#KadDHT">types: type KadDHT</a></li>
          </ul></dd>
<dt><a name="KadDHTConfig" href="#KadDHTConfig"><span>KadDHTConfig:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type KadDHTConfig" href="libp2p/protocols/kademlia/types.html#KadDHTConfig">types: type KadDHTConfig</a></li>
          </ul></dd>
<dt><a name="key" href="#key"><span>key:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc key(secret: Secret; id: int): seq[byte]" href="libp2p/crypto/crypto.html#key%2CSecret%2Cint">crypto: proc key(secret: Secret; id: int): seq[byte]</a></li>
          </ul></dd>
<dt><a name="Key" href="#Key"><span>Key:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type Key" href="libp2p/protocols/kademlia/types.html#Key">types: type Key</a></li>
          </ul></dd>
<dt><a name="KeyAuthorization" href="#KeyAuthorization"><span>KeyAuthorization:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type KeyAuthorization" href="libp2p/autotls/acme/client.html#KeyAuthorization">client: type KeyAuthorization</a></li>
          </ul></dd>
<dt><a name="KeyBook" href="#KeyBook"><span>KeyBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type KeyBook" href="libp2p/peerstore.html#KeyBook">peerstore: type KeyBook</a></li>
          </ul></dd>
<dt><a name="KeyError" href="#KeyError"><span>KeyError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: CryptoError.KeyError" href="libp2p/crypto/crypto.html#KeyError">crypto: CryptoError.KeyError</a></li>
          </ul></dd>
<dt><a name="KeyGenerationError" href="#KeyGenerationError"><span>KeyGenerationError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object KeyGenerationError" href="libp2p/transports/tls/certificate.html#KeyGenerationError">certificate: object KeyGenerationError</a></li>
          </ul></dd>
<dt><a name="keyOpenArray" href="#keyOpenArray"><span>keyOpenArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: template keyOpenArray(secret: Secret; id: int): untyped" href="libp2p/crypto/crypto.html#keyOpenArray.t%2CSecret%2Cint">crypto: template keyOpenArray(secret: Secret; id: int): untyped</a></li>
          </ul></dd>
<dt><a name="KeyPair" href="#KeyPair"><span>KeyPair:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: object KeyPair" href="libp2p/crypto/crypto.html#KeyPair">crypto: object KeyPair</a></li>
          </ul></dd>
<dt><a name="Kid" href="#Kid"><span>Kid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: type Kid" href="libp2p/autotls/acme/api.html#Kid">api: type Kid</a></li>
          </ul></dd>
<dt><a name="KnownLibP2PTopics" href="#KnownLibP2PTopics"><span>KnownLibP2PTopics:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: const KnownLibP2PTopics" href="libp2p/protocols/pubsub/pubsub.html#KnownLibP2PTopics">pubsub: const KnownLibP2PTopics</a></li>
          </ul></dd>
<dt><a name="KnownLibP2PTopicsSeq" href="#KnownLibP2PTopicsSeq"><span>KnownLibP2PTopicsSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: const KnownLibP2PTopicsSeq" href="libp2p/protocols/pubsub/pubsub.html#KnownLibP2PTopicsSeq">pubsub: const KnownLibP2PTopicsSeq</a></li>
          </ul></dd>
<dt><a name="LastSeenBook" href="#LastSeenBook"><span>LastSeenBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type LastSeenBook" href="libp2p/peerstore.html#LastSeenBook">peerstore: type LastSeenBook</a></li>
          </ul></dd>
<dt><a name="leadingZeros" href="#leadingZeros"><span>leadingZeros:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc leadingZeros(dist: XorDistance): int" href="libp2p/protocols/kademlia/types.html#leadingZeros%2CXorDistance">types: proc leadingZeros(dist: XorDistance): int</a></li>
          </ul></dd>
<dt><a name="len" href="#len"><span>len:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc len(field: Asn1Field): int" href="libp2p/crypto/minasn1.html#len%2CAsn1Field">minasn1: proc len(field: Asn1Field): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc len[T: Asn1Buffer | Asn1Composite](abc: T): int" href="libp2p/crypto/minasn1.html#len%2CT">minasn1: proc len[T: Asn1Buffer | Asn1Composite](abc: T): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc len(ma: MultiAddress): MaResult[int]" href="libp2p/multiaddress.html#len%2CMultiAddress">multiaddress: proc len(ma: MultiAddress): MaResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: template len(pid: PeerId): int" href="libp2p/peerid.html#len.t%2CPeerId">peerid: template len(pid: PeerId): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc len[T](peerBook: PeerBook[T]): int" href="libp2p/peerstore.html#len%2CPeerBook%5BT%5D">peerstore: proc len[T](peerBook: PeerBook[T]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc len(pk: ProvidedKeys): int" href="libp2p/protocols/kademlia/provider.html#len%2CProvidedKeys">provider: proc len(pk: ProvidedKeys): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc len(pr: ProviderRecords): int" href="libp2p/protocols/kademlia/provider.html#len%2CProviderRecords">provider: proc len(pr: ProviderRecords): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="preamblestore: proc len(ps: var PreambleStore): int" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#len%2CPreambleStore">preamblestore: proc len(ps: var PreambleStore): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bufferstream: proc len(s: BufferStream): int" href="libp2p/stream/bufferstream.html#len%2CBufferStream">bufferstream: proc len(s: BufferStream): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bytesview: proc len(v: BytesView): int" href="libp2p/utils/bytesview.html#len%2CBytesView">bytesview: proc len(v: BytesView): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="zeroqueue: proc len(q: ZeroQueue): int64" href="libp2p/utils/zeroqueue.html#len%2CZeroQueue">zeroqueue: proc len(q: ZeroQueue): int64</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: proc len(vb: VBuffer): int" href="libp2p/vbuffer.html#len%2CVBuffer">vbuffer: proc len(vb: VBuffer): int</a></li>
          </ul></dd>
<dt><a name="Length" href="#Length"><span>Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MAKind.Length" href="libp2p/multiaddress.html#Length">multiaddress: MAKind.Length</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFieldKind.Length" href="libp2p/protobuf/minprotobuf.html#Length">minprotobuf: ProtoFieldKind.Length</a></li>
          </ul></dd>
<dt><a name="lenu64" href="#lenu64"><span>lenu64:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: template lenu64(x: untyped): untyped" href="libp2p/protobuf/minprotobuf.html#lenu64.t%2Cuntyped">minprotobuf: template lenu64(x: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="LetsEncryptURL" href="#LetsEncryptURL"><span>LetsEncryptURL:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: const LetsEncryptURL" href="libp2p/autotls/acme/api.html#LetsEncryptURL">api: const LetsEncryptURL</a></li>
          </ul></dd>
<dt><a name="LetsEncryptURLStaging" href="#LetsEncryptURLStaging"><span>LetsEncryptURLStaging:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: const LetsEncryptURLStaging" href="libp2p/autotls/acme/api.html#LetsEncryptURLStaging">api: const LetsEncryptURLStaging</a></li>
          </ul></dd>
<dt><a name="libp2p_autonat_v2_reachability_confidence" href="#libp2p_autonat_v2_reachability_confidence"><span>libp2p_autonat_v2_reachability_confidence:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: type libp2p_autonat_v2_reachability_confidence" href="libp2p/protocols/connectivity/autonatv2/service.html#libp2p_autonat_v2_reachability_confidence">service: type libp2p_autonat_v2_reachability_confidence</a></li>
          </ul></dd>
<dt><a name="libp2p_contentids_exts" href="#libp2p_contentids_exts"><span>libp2p_contentids_exts:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: const libp2p_contentids_exts" href="libp2p/cid.html#libp2p_contentids_exts">cid: const libp2p_contentids_exts</a></li>
          </ul></dd>
<dt><a name="libp2p_failed_upgrades_incoming" href="#libp2p_failed_upgrades_incoming"><span>libp2p_failed_upgrades_incoming:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="upgrade: type libp2p_failed_upgrades_incoming" href="libp2p/upgrademngrs/upgrade.html#libp2p_failed_upgrades_incoming">upgrade: type libp2p_failed_upgrades_incoming</a></li>
          </ul></dd>
<dt><a name="libp2p_failed_upgrades_outgoing" href="#libp2p_failed_upgrades_outgoing"><span>libp2p_failed_upgrades_outgoing:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="upgrade: type libp2p_failed_upgrades_outgoing" href="libp2p/upgrademngrs/upgrade.html#libp2p_failed_upgrades_outgoing">upgrade: type libp2p_failed_upgrades_outgoing</a></li>
          </ul></dd>
<dt><a name="libp2p_gossipsub_peers_rate_limit_hits" href="#libp2p_gossipsub_peers_rate_limit_hits"><span>libp2p_gossipsub_peers_rate_limit_hits:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: type libp2p_gossipsub_peers_rate_limit_hits" href="libp2p/protocols/pubsub/gossipsub/scoring.html#libp2p_gossipsub_peers_rate_limit_hits">scoring: type libp2p_gossipsub_peers_rate_limit_hits</a></li>
          </ul></dd>
<dt><a name="libp2p_multiaddress_exts" href="#libp2p_multiaddress_exts"><span>libp2p_multiaddress_exts:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const libp2p_multiaddress_exts" href="libp2p/multiaddress.html#libp2p_multiaddress_exts">multiaddress: const libp2p_multiaddress_exts</a></li>
          </ul></dd>
<dt><a name="libp2p_multibase_exts" href="#libp2p_multibase_exts"><span>libp2p_multibase_exts:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multibase: const libp2p_multibase_exts" href="libp2p/multibase.html#libp2p_multibase_exts">multibase: const libp2p_multibase_exts</a></li>
          </ul></dd>
<dt><a name="libp2p_multicodec_exts" href="#libp2p_multicodec_exts"><span>libp2p_multicodec_exts:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multicodec: const libp2p_multicodec_exts" href="libp2p/multicodec.html#libp2p_multicodec_exts">multicodec: const libp2p_multicodec_exts</a></li>
          </ul></dd>
<dt><a name="libp2p_multihash_exts" href="#libp2p_multihash_exts"><span>libp2p_multihash_exts:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: const libp2p_multihash_exts" href="libp2p/multihash.html#libp2p_multihash_exts">multihash: const libp2p_multihash_exts</a></li>
          </ul></dd>
<dt><a name="libp2p_network_bytes" href="#libp2p_network_bytes"><span>libp2p_network_bytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connection: type libp2p_network_bytes" href="libp2p/stream/connection.html#libp2p_network_bytes">connection: type libp2p_network_bytes</a></li>
          </ul></dd>
<dt><a name="libp2p_pki_schemes" href="#libp2p_pki_schemes"><span>libp2p_pki_schemes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: const libp2p_pki_schemes" href="libp2p/crypto/crypto.html#libp2p_pki_schemes">crypto: const libp2p_pki_schemes</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_broadcast_graft" href="#libp2p_pubsub_broadcast_graft"><span>libp2p_pubsub_broadcast_graft:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_broadcast_graft" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_broadcast_graft">pubsub: type libp2p_pubsub_broadcast_graft</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_broadcast_ihave" href="#libp2p_pubsub_broadcast_ihave"><span>libp2p_pubsub_broadcast_ihave:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_broadcast_ihave" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_broadcast_ihave">pubsub: type libp2p_pubsub_broadcast_ihave</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_broadcast_iwant" href="#libp2p_pubsub_broadcast_iwant"><span>libp2p_pubsub_broadcast_iwant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_broadcast_iwant" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_broadcast_iwant">pubsub: type libp2p_pubsub_broadcast_iwant</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_broadcast_messages" href="#libp2p_pubsub_broadcast_messages"><span>libp2p_pubsub_broadcast_messages:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_broadcast_messages" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_broadcast_messages">pubsub: type libp2p_pubsub_broadcast_messages</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_broadcast_prune" href="#libp2p_pubsub_broadcast_prune"><span>libp2p_pubsub_broadcast_prune:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_broadcast_prune" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_broadcast_prune">pubsub: type libp2p_pubsub_broadcast_prune</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_broadcast_subscriptions" href="#libp2p_pubsub_broadcast_subscriptions"><span>libp2p_pubsub_broadcast_subscriptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_broadcast_subscriptions" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_broadcast_subscriptions">pubsub: type libp2p_pubsub_broadcast_subscriptions</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_broadcast_unsubscriptions" href="#libp2p_pubsub_broadcast_unsubscriptions"><span>libp2p_pubsub_broadcast_unsubscriptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_broadcast_unsubscriptions" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_broadcast_unsubscriptions">pubsub: type libp2p_pubsub_broadcast_unsubscriptions</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_messages_published" href="#libp2p_pubsub_messages_published"><span>libp2p_pubsub_messages_published:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_messages_published" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_messages_published">pubsub: type libp2p_pubsub_messages_published</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_messages_rebroadcasted" href="#libp2p_pubsub_messages_rebroadcasted"><span>libp2p_pubsub_messages_rebroadcasted:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_messages_rebroadcasted" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_messages_rebroadcasted">pubsub: type libp2p_pubsub_messages_rebroadcasted</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_received_graft" href="#libp2p_pubsub_received_graft"><span>libp2p_pubsub_received_graft:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_received_graft" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_received_graft">pubsub: type libp2p_pubsub_received_graft</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_received_ihave" href="#libp2p_pubsub_received_ihave"><span>libp2p_pubsub_received_ihave:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_received_ihave" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_received_ihave">pubsub: type libp2p_pubsub_received_ihave</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_received_iwant" href="#libp2p_pubsub_received_iwant"><span>libp2p_pubsub_received_iwant:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_received_iwant" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_received_iwant">pubsub: type libp2p_pubsub_received_iwant</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_received_messages" href="#libp2p_pubsub_received_messages"><span>libp2p_pubsub_received_messages:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_received_messages" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_received_messages">pubsub: type libp2p_pubsub_received_messages</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_received_prune" href="#libp2p_pubsub_received_prune"><span>libp2p_pubsub_received_prune:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_received_prune" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_received_prune">pubsub: type libp2p_pubsub_received_prune</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_received_subscriptions" href="#libp2p_pubsub_received_subscriptions"><span>libp2p_pubsub_received_subscriptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_received_subscriptions" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_received_subscriptions">pubsub: type libp2p_pubsub_received_subscriptions</a></li>
          </ul></dd>
<dt><a name="libp2p_pubsub_received_unsubscriptions" href="#libp2p_pubsub_received_unsubscriptions"><span>libp2p_pubsub_received_unsubscriptions:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type libp2p_pubsub_received_unsubscriptions" href="libp2p/protocols/pubsub/pubsub.html#libp2p_pubsub_received_unsubscriptions">pubsub: type libp2p_pubsub_received_unsubscriptions</a></li>
          </ul></dd>
<dt><a name="Limit" href="#Limit"><span>Limit:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object Limit" href="libp2p/protocols/connectivity/relay/messages.html#Limit">messages: object Limit</a></li>
          </ul></dd>
<dt><a name="list" href="#list"><span>list:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: proc list(m: MultistreamSelect; conn: Connection): InternalRaisesFuture[seq[string],
    (CancelledError, LPStreamError, MultiStreamError)]" href="libp2p/multistream.html#list%2CMultistreamSelect%2CConnection">multistream: proc list(m: MultistreamSelect; conn: Connection): InternalRaisesFuture[seq[string],
    (CancelledError, LPStreamError, MultiStreamError)]</a></li>
          </ul></dd>
<dt><a name="LocalTable" href="#LocalTable"><span>LocalTable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type LocalTable" href="libp2p/protocols/kademlia/types.html#LocalTable">types: type LocalTable</a></li>
          </ul></dd>
<dt><a name="LookupNode" href="#LookupNode"><span>LookupNode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lookupstate: object LookupNode" href="libp2p/protocols/kademlia/lookupstate.html#LookupNode">lookupstate: object LookupNode</a></li>
          </ul></dd>
<dt><a name="LookupState" href="#LookupState"><span>LookupState:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lookupstate: object LookupState" href="libp2p/protocols/kademlia/lookupstate.html#LookupState">lookupstate: object LookupState</a></li>
          </ul></dd>
<dt><a name="low" href="#low"><span>low:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: proc low[T](o: OffsettedSeq[T]): int" href="libp2p/utils/offsettedseq.html#low%2COffsettedSeq%5BT%5D">offsettedseq: proc low[T](o: OffsettedSeq[T]): int</a></li>
          </ul></dd>
<dt><a name="LP" href="#LP"><span>LP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: object LP" href="libp2p/varint.html#LP">varint: object LP</a></li>
          </ul></dd>
<dt><a name="LPChannel" href="#LPChannel"><span>LPChannel:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: type LPChannel" href="libp2p/muxers/mplex/lpchannel.html#LPChannel">lpchannel: type LPChannel</a></li>
          </ul></dd>
<dt><a name="LPChannelTrackerName" href="#LPChannelTrackerName"><span>LPChannelTrackerName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: const LPChannelTrackerName" href="libp2p/muxers/mplex/lpchannel.html#LPChannelTrackerName">lpchannel: const LPChannelTrackerName</a></li>
          </ul></dd>
<dt><a name="LPError" href="#LPError"><span>LPError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="errors: object LPError" href="libp2p/errors.html#LPError">errors: object LPError</a></li>
          </ul></dd>
<dt><a name="LPProtocol" href="#LPProtocol"><span>LPProtocol:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: type LPProtocol" href="libp2p/protocols/protocol.html#LPProtocol">protocol: type LPProtocol</a></li>
          </ul></dd>
<dt><a name="LPProtoHandler" href="#LPProtoHandler"><span>LPProtoHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: type LPProtoHandler" href="libp2p/protocols/protocol.html#LPProtoHandler">protocol: type LPProtoHandler</a></li>
          </ul></dd>
<dt><a name="LPSomeUVarint" href="#LPSomeUVarint"><span>LPSomeUVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type LPSomeUVarint" href="libp2p/varint.html#LPSomeUVarint">varint: type LPSomeUVarint</a></li>
          </ul></dd>
<dt><a name="LPSomeVarint" href="#LPSomeVarint"><span>LPSomeVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type LPSomeVarint" href="libp2p/varint.html#LPSomeVarint">varint: type LPSomeVarint</a></li>
          </ul></dd>
<dt><a name="LPStream" href="#LPStream"><span>LPStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: type LPStream" href="libp2p/stream/lpstream.html#LPStream">lpstream: type LPStream</a></li>
          </ul></dd>
<dt><a name="LPStreamClosedError" href="#LPStreamClosedError"><span>LPStreamClosedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamClosedError" href="libp2p/stream/lpstream.html#LPStreamClosedError">lpstream: object LPStreamClosedError</a></li>
          </ul></dd>
<dt><a name="LPStreamConnDownError" href="#LPStreamConnDownError"><span>LPStreamConnDownError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamConnDownError" href="libp2p/stream/lpstream.html#LPStreamConnDownError">lpstream: object LPStreamConnDownError</a></li>
          </ul></dd>
<dt><a name="LPStreamEOFError" href="#LPStreamEOFError"><span>LPStreamEOFError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamEOFError" href="libp2p/stream/lpstream.html#LPStreamEOFError">lpstream: object LPStreamEOFError</a></li>
          </ul></dd>
<dt><a name="LPStreamError" href="#LPStreamError"><span>LPStreamError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamError" href="libp2p/stream/lpstream.html#LPStreamError">lpstream: object LPStreamError</a></li>
          </ul></dd>
<dt><a name="LPStreamIncompleteError" href="#LPStreamIncompleteError"><span>LPStreamIncompleteError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamIncompleteError" href="libp2p/stream/lpstream.html#LPStreamIncompleteError">lpstream: object LPStreamIncompleteError</a></li>
          </ul></dd>
<dt><a name="LPStreamLimitError" href="#LPStreamLimitError"><span>LPStreamLimitError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamLimitError" href="libp2p/stream/lpstream.html#LPStreamLimitError">lpstream: object LPStreamLimitError</a></li>
          </ul></dd>
<dt><a name="LPStreamRemoteClosedError" href="#LPStreamRemoteClosedError"><span>LPStreamRemoteClosedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamRemoteClosedError" href="libp2p/stream/lpstream.html#LPStreamRemoteClosedError">lpstream: object LPStreamRemoteClosedError</a></li>
          </ul></dd>
<dt><a name="LPStreamResetError" href="#LPStreamResetError"><span>LPStreamResetError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object LPStreamResetError" href="libp2p/stream/lpstream.html#LPStreamResetError">lpstream: object LPStreamResetError</a></li>
          </ul></dd>
<dt><a name="LPStreamTrackerName" href="#LPStreamTrackerName"><span>LPStreamTrackerName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: const LPStreamTrackerName" href="libp2p/stream/lpstream.html#LPStreamTrackerName">lpstream: const LPStreamTrackerName</a></li>
          </ul></dd>
<dt><a name="mac" href="#mac"><span>mac:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc mac(secret: Secret; id: int): seq[byte]" href="libp2p/crypto/crypto.html#mac%2CSecret%2Cint">crypto: proc mac(secret: Secret; id: int): seq[byte]</a></li>
          </ul></dd>
<dt><a name="macOpenArray" href="#macOpenArray"><span>macOpenArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: template macOpenArray(secret: Secret; id: int): untyped" href="libp2p/crypto/crypto.html#macOpenArray.t%2CSecret%2Cint">crypto: template macOpenArray(secret: Secret; id: int): untyped</a></li>
          </ul></dd>
<dt><a name="maErr" href="#maErr"><span>maErr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc maErr(msg: string): ref MaError" href="libp2p/multiaddress.html#maErr%2Cstring">multiaddress: proc maErr(msg: string): ref MaError</a></li>
          </ul></dd>
<dt><a name="MaError" href="#MaError"><span>MaError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: object MaError" href="libp2p/multiaddress.html#MaError">multiaddress: object MaError</a></li>
          </ul></dd>
<dt><a name="MaInvalidAddress" href="#MaInvalidAddress"><span>MaInvalidAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: object MaInvalidAddress" href="libp2p/multiaddress.html#MaInvalidAddress">multiaddress: object MaInvalidAddress</a></li>
          </ul></dd>
<dt><a name="MAKind" href="#MAKind"><span>MAKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: enum MAKind" href="libp2p/multiaddress.html#MAKind">multiaddress: enum MAKind</a></li>
          </ul></dd>
<dt><a name="MalformedMessage" href="#MalformedMessage"><span>MalformedMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.MalformedMessage" href="libp2p/protocols/connectivity/relay/messages.html#MalformedMessage">messages: StatusV2.MalformedMessage</a></li>
          </ul></dd>
<dt><a name="manageExpiredProviders" href="#manageExpiredProviders"><span>manageExpiredProviders:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc manageExpiredProviders(kad: KadDHT): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/kademlia/provider.html#manageExpiredProviders%2CKadDHT">provider: proc manageExpiredProviders(kad: KadDHT): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="manageRepublishProvidedKeys" href="#manageRepublishProvidedKeys"><span>manageRepublishProvidedKeys:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc manageRepublishProvidedKeys(kad: KadDHT): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/kademlia/provider.html#manageRepublishProvidedKeys%2CKadDHT">provider: proc manageRepublishProvidedKeys(kad: KadDHT): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="mapAnd" href="#mapAnd"><span>mapAnd:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc mapAnd(args: varargs[MaPattern]): MaPattern" href="libp2p/multiaddress.html#mapAnd%2Cvarargs%5BMaPattern%5D">multiaddress: proc mapAnd(args: varargs[MaPattern]): MaPattern</a></li>
          </ul></dd>
<dt><a name="MaPatResult" href="#MaPatResult"><span>MaPatResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: object MaPatResult" href="libp2p/multiaddress.html#MaPatResult">multiaddress: object MaPatResult</a></li>
          </ul></dd>
<dt><a name="MaPattern" href="#MaPattern"><span>MaPattern:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: object MaPattern" href="libp2p/multiaddress.html#MaPattern">multiaddress: object MaPattern</a></li>
          </ul></dd>
<dt><a name="MaPatternOp" href="#MaPatternOp"><span>MaPatternOp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: enum MaPatternOp" href="libp2p/multiaddress.html#MaPatternOp">multiaddress: enum MaPatternOp</a></li>
          </ul></dd>
<dt><a name="mapEq" href="#mapEq"><span>mapEq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc mapEq(codec: string): MaPattern" href="libp2p/multiaddress.html#mapEq%2Cstring">multiaddress: proc mapEq(codec: string): MaPattern</a></li>
          </ul></dd>
<dt><a name="mapOr" href="#mapOr"><span>mapOr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc mapOr(args: varargs[MaPattern]): MaPattern" href="libp2p/multiaddress.html#mapOr%2Cvarargs%5BMaPattern%5D">multiaddress: proc mapOr(args: varargs[MaPattern]): MaPattern</a></li>
          </ul></dd>
<dt><a name="MAProtocol" href="#MAProtocol"><span>MAProtocol:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: object MAProtocol" href="libp2p/multiaddress.html#MAProtocol">multiaddress: object MAProtocol</a></li>
          </ul></dd>
<dt><a name="MaResult" href="#MaResult"><span>MaResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: type MaResult" href="libp2p/multiaddress.html#MaResult">multiaddress: type MaResult</a></li>
          </ul></dd>
<dt><a name="Marker" href="#Marker"><span>Marker:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MAKind.Marker" href="libp2p/multiaddress.html#Marker">multiaddress: MAKind.Marker</a></li>
          </ul></dd>
<dt><a name="markFailed" href="#markFailed"><span>markFailed:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lookupstate: proc markFailed(state: var LookupState; peerId: PeerId)" href="libp2p/protocols/kademlia/lookupstate.html#markFailed%2CLookupState%2CPeerId">lookupstate: proc markFailed(state: var LookupState; peerId: PeerId)</a></li>
          </ul></dd>
<dt><a name="markPending" href="#markPending"><span>markPending:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lookupstate: proc markPending(state: var LookupState; peerId: PeerId)" href="libp2p/protocols/kademlia/lookupstate.html#markPending%2CLookupState%2CPeerId">lookupstate: proc markPending(state: var LookupState; peerId: PeerId)</a></li>
          </ul></dd>
<dt><a name="match" href="#match"><span>match:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc match(pat: MaPattern; address: MultiAddress): bool" href="libp2p/multiaddress.html#match%2CMaPattern%2CMultiAddress">multiaddress: proc match(pat: MaPattern; address: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc match(pid: PeerId; seckey: PrivateKey): bool" href="libp2p/peerid.html#match%2CPeerId%2CPrivateKey">peerid: proc match(pid: PeerId; seckey: PrivateKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc match(pid: PeerId; pubkey: PublicKey): bool" href="libp2p/peerid.html#match%2CPeerId%2CPublicKey">peerid: proc match(pid: PeerId; pubkey: PublicKey): bool</a></li>
          </ul></dd>
<dt><a name="Matcher" href="#Matcher"><span>Matcher:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: type Matcher" href="libp2p/multistream.html#Matcher">multistream: type Matcher</a></li>
          </ul></dd>
<dt><a name="matchPartial" href="#matchPartial"><span>matchPartial:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc matchPartial(pat: MaPattern; address: MultiAddress): bool" href="libp2p/multiaddress.html#matchPartial%2CMaPattern%2CMultiAddress">multiaddress: proc matchPartial(pat: MaPattern; address: MultiAddress): bool</a></li>
          </ul></dd>
<dt><a name="MaxAcceptedDialDataRequest" href="#MaxAcceptedDialDataRequest"><span>MaxAcceptedDialDataRequest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: const MaxAcceptedDialDataRequest" href="libp2p/protocols/connectivity/autonatv2/client.html#MaxAcceptedDialDataRequest">client: const MaxAcceptedDialDataRequest</a></li>
          </ul></dd>
<dt><a name="MaxChannelCount" href="#MaxChannelCount"><span>MaxChannelCount:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: const MaxChannelCount" href="libp2p/muxers/yamux/yamux.html#MaxChannelCount">yamux: const MaxChannelCount</a></li>
          </ul></dd>
<dt><a name="MaxCircuit" href="#MaxCircuit"><span>MaxCircuit:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: const MaxCircuit" href="libp2p/protocols/connectivity/relay/relay.html#MaxCircuit">relay: const MaxCircuit</a></li>
          </ul></dd>
<dt><a name="MaxCircuitPerPeer" href="#MaxCircuitPerPeer"><span>MaxCircuitPerPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: const MaxCircuitPerPeer" href="libp2p/protocols/connectivity/relay/relay.html#MaxCircuitPerPeer">relay: const MaxCircuitPerPeer</a></li>
          </ul></dd>
<dt><a name="MaxConnections" href="#MaxConnections"><span>MaxConnections:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: const MaxConnections" href="libp2p/connmanager.html#MaxConnections">connmanager: const MaxConnections</a></li>
          </ul></dd>
<dt><a name="MaxConnectionsPerPeer" href="#MaxConnectionsPerPeer"><span>MaxConnectionsPerPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: const MaxConnectionsPerPeer" href="libp2p/connmanager.html#MaxConnectionsPerPeer">connmanager: const MaxConnectionsPerPeer</a></li>
          </ul></dd>
<dt><a name="MaxDialDataResponsePayload" href="#MaxDialDataResponsePayload"><span>MaxDialDataResponsePayload:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: const MaxDialDataResponsePayload" href="libp2p/protocols/connectivity/autonatv2/client.html#MaxDialDataResponsePayload">client: const MaxDialDataResponsePayload</a></li>
          </ul></dd>
<dt><a name="MaxHashSize" href="#MaxHashSize"><span>MaxHashSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: const MaxHashSize" href="libp2p/multihash.html#MaxHashSize">multihash: const MaxHashSize</a></li>
          </ul></dd>
<dt><a name="MaximumDuration" href="#MaximumDuration"><span>MaximumDuration:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: const MaximumDuration" href="libp2p/protocols/rendezvous/rendezvous.html#MaximumDuration">rendezvous: const MaximumDuration</a></li>
          </ul></dd>
<dt><a name="maxIncomingStreams" href="#maxIncomingStreams"><span>maxIncomingStreams:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: proc maxIncomingStreams(p: LPProtocol): int" href="libp2p/protocols/protocol.html#maxIncomingStreams%2CLPProtocol">protocol: proc maxIncomingStreams(p: LPProtocol): int</a></li>
          </ul></dd>
<dt><a name="maxIncomingStreams%3D" href="#maxIncomingStreams%3D"><span>maxIncomingStreams=:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protocol: proc maxIncomingStreams=(p: LPProtocol; val: int)" href="libp2p/protocols/protocol.html#maxIncomingStreams%3D%2CLPProtocol%2Cint">protocol: proc maxIncomingStreams=(p: LPProtocol; val: int)</a></li>
          </ul></dd>
<dt><a name="maxInlineKeyLength" href="#maxInlineKeyLength"><span>maxInlineKeyLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: const maxInlineKeyLength" href="libp2p/peerid.html#maxInlineKeyLength">peerid: const maxInlineKeyLength</a></li>
          </ul></dd>
<dt><a name="MaxMsgSize" href="#MaxMsgSize"><span>MaxMsgSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="coder: const MaxMsgSize" href="libp2p/muxers/mplex/coder.html#MaxMsgSize">coder: const MaxMsgSize</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: const MaxMsgSize" href="libp2p/protocols/kademlia/types.html#MaxMsgSize">types: const MaxMsgSize</a></li>
          </ul></dd>
<dt><a name="MaxOpportunisticGraftPeers" href="#MaxOpportunisticGraftPeers"><span>MaxOpportunisticGraftPeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const MaxOpportunisticGraftPeers" href="libp2p/protocols/pubsub/gossipsub/types.html#MaxOpportunisticGraftPeers">types: const MaxOpportunisticGraftPeers</a></li>
          </ul></dd>
<dt><a name="MaxSizeError" href="#MaxSizeError"><span>MaxSizeError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: object MaxSizeError" href="libp2p/stream/lpstream.html#MaxSizeError">lpstream: object MaxSizeError</a></li>
          </ul></dd>
<dt><a name="MBSTRING_ASC" href="#MBSTRING_ASC"><span>MBSTRING_ASC:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const MBSTRING_ASC" href="libp2p/transports/tls/certificate_ffi.html#MBSTRING_ASC">certificate_ffi: const MBSTRING_ASC</a></li>
          </ul></dd>
<dt><a name="MBSTRING_BMP" href="#MBSTRING_BMP"><span>MBSTRING_BMP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const MBSTRING_BMP" href="libp2p/transports/tls/certificate_ffi.html#MBSTRING_BMP">certificate_ffi: const MBSTRING_BMP</a></li>
          </ul></dd>
<dt><a name="MBSTRING_FLAG" href="#MBSTRING_FLAG"><span>MBSTRING_FLAG:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const MBSTRING_FLAG" href="libp2p/transports/tls/certificate_ffi.html#MBSTRING_FLAG">certificate_ffi: const MBSTRING_FLAG</a></li>
          </ul></dd>
<dt><a name="MBSTRING_UNIV" href="#MBSTRING_UNIV"><span>MBSTRING_UNIV:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const MBSTRING_UNIV" href="libp2p/transports/tls/certificate_ffi.html#MBSTRING_UNIV">certificate_ffi: const MBSTRING_UNIV</a></li>
          </ul></dd>
<dt><a name="MBSTRING_UTF8" href="#MBSTRING_UTF8"><span>MBSTRING_UTF8:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate_ffi: const MBSTRING_UTF8" href="libp2p/transports/tls/certificate_ffi.html#MBSTRING_UTF8">certificate_ffi: const MBSTRING_UTF8</a></li>
          </ul></dd>
<dt><a name="MCache" href="#MCache"><span>MCache:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mcache: object MCache" href="libp2p/protocols/pubsub/mcache.html#MCache">mcache: object MCache</a></li>
          </ul></dd>
<dt><a name="Memory" href="#Memory"><span>Memory:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const Memory" href="libp2p/multiaddress.html#Memory">multiaddress: const Memory</a></li>
          </ul></dd>
<dt><a name="MemoryAutoAddress" href="#MemoryAutoAddress"><span>MemoryAutoAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: const MemoryAutoAddress" href="libp2p/builders.html#MemoryAutoAddress">builders: const MemoryAutoAddress</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: const MemoryAutoAddress" href="libp2p/transports/memorytransport.html#MemoryAutoAddress">memorytransport: const MemoryAutoAddress</a></li>
          </ul></dd>
<dt><a name="MemoryListener" href="#MemoryListener"><span>MemoryListener:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="memorymanager: object MemoryListener" href="libp2p/transports/memorymanager.html#MemoryListener">memorymanager: object MemoryListener</a></li>
          </ul></dd>
<dt><a name="MemoryTransport" href="#MemoryTransport"><span>MemoryTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="memorytransport: type MemoryTransport" href="libp2p/transports/memorytransport.html#MemoryTransport">memorytransport: type MemoryTransport</a></li>
          </ul></dd>
<dt><a name="MemoryTransportAcceptStopped" href="#MemoryTransportAcceptStopped"><span>MemoryTransportAcceptStopped:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="memorymanager: object MemoryTransportAcceptStopped" href="libp2p/transports/memorymanager.html#MemoryTransportAcceptStopped">memorymanager: object MemoryTransportAcceptStopped</a></li>
          </ul></dd>
<dt><a name="MemoryTransportError" href="#MemoryTransportError"><span>MemoryTransportError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="memorymanager: object MemoryTransportError" href="libp2p/transports/memorymanager.html#MemoryTransportError">memorymanager: object MemoryTransportError</a></li>
          </ul></dd>
<dt><a name="MeshMetrics" href="#MeshMetrics"><span>MeshMetrics:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object MeshMetrics" href="libp2p/protocols/pubsub/gossipsub/types.html#MeshMetrics">types: object MeshMetrics</a></li>
          </ul></dd>
<dt><a name="Message" href="#Message"><span>Message:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object Message" href="libp2p/protocols/kademlia/protobuf.html#Message">protobuf: object Message</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: object Message" href="libp2p/protocols/pubsub/rpc/messages.html#Message">messages: object Message</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: object Message" href="libp2p/protocols/rendezvous/protobuf.html#Message">protobuf: object Message</a></li>
          </ul></dd>
<dt><a name="MessageId" href="#MessageId"><span>MessageId:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: type MessageId" href="libp2p/protocols/pubsub/rpc/messages.html#MessageId">messages: type MessageId</a></li>
          </ul></dd>
<dt><a name="MessageType" href="#MessageType"><span>MessageType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="coder: enum MessageType" href="libp2p/muxers/mplex/coder.html#MessageType">coder: enum MessageType</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: enum MessageType" href="libp2p/protocols/kademlia/protobuf.html#MessageType">protobuf: enum MessageType</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: enum MessageType" href="libp2p/protocols/rendezvous/protobuf.html#MessageType">protobuf: enum MessageType</a></li>
          </ul></dd>
<dt><a name="mhash" href="#mhash"><span>mhash:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc mhash(cid: Cid): Result[MultiHash, CidError]" href="libp2p/cid.html#mhash%2CCid">cid: proc mhash(cid: Cid): Result[MultiHash, CidError]</a></li>
          </ul></dd>
<dt><a name="MHash" href="#MHash"><span>MHash:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: object MHash" href="libp2p/multihash.html#MHash">multihash: object MHash</a></li>
          </ul></dd>
<dt><a name="MHashCoderProc" href="#MHashCoderProc"><span>MHashCoderProc:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: type MHashCoderProc" href="libp2p/multihash.html#MHashCoderProc">multihash: type MHashCoderProc</a></li>
          </ul></dd>
<dt><a name="MhResult" href="#MhResult"><span>MhResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: type MhResult" href="libp2p/multihash.html#MhResult">multihash: type MhResult</a></li>
          </ul></dd>
<dt><a name="MinimumAcceptedDuration" href="#MinimumAcceptedDuration"><span>MinimumAcceptedDuration:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: const MinimumAcceptedDuration" href="libp2p/protocols/rendezvous/rendezvous.html#MinimumAcceptedDuration">rendezvous: const MinimumAcceptedDuration</a></li>
          </ul></dd>
<dt><a name="MinimumDuration" href="#MinimumDuration"><span>MinimumDuration:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: const MinimumDuration" href="libp2p/protocols/rendezvous/rendezvous.html#MinimumDuration">rendezvous: const MinimumDuration</a></li>
          </ul></dd>
<dt><a name="MinKeySize" href="#MinKeySize"><span>MinKeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const MinKeySize" href="libp2p/crypto/rsa.html#MinKeySize">rsa: const MinKeySize</a></li>
          </ul></dd>
<dt><a name="mount" href="#mount"><span>mount:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: proc mount[T: LPProtocol](s: Switch; proto: T; matcher: Matcher = nil)" href="libp2p/switch.html#mount%2CSwitch%2CT%2CMatcher">switch: proc mount[T: LPProtocol](s: Switch; proto: T; matcher: Matcher = nil)</a></li>
          </ul></dd>
<dt><a name="Mplex" href="#Mplex"><span>Mplex:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mplex: type Mplex" href="libp2p/muxers/mplex/mplex.html#Mplex">mplex: type Mplex</a></li>
          </ul></dd>
<dt><a name="MplexCodec" href="#MplexCodec"><span>MplexCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mplex: const MplexCodec" href="libp2p/muxers/mplex/mplex.html#MplexCodec">mplex: const MplexCodec</a></li>
          </ul></dd>
<dt><a name="Msg" href="#Msg"><span>Msg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="coder: tuple Msg" href="libp2p/muxers/mplex/coder.html#Msg">coder: tuple Msg</a></li>
          </ul></dd>
<dt><a name="MsgIdProvider" href="#MsgIdProvider"><span>MsgIdProvider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type MsgIdProvider" href="libp2p/protocols/pubsub/pubsub.html#MsgIdProvider">pubsub: type MsgIdProvider</a></li>
          </ul></dd>
<dt><a name="MsgType" href="#MsgType"><span>MsgType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: enum MsgType" href="libp2p/protocols/connectivity/autonat/types.html#MsgType">types: enum MsgType</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: enum MsgType" href="libp2p/protocols/connectivity/autonatv2/types.html#MsgType">types: enum MsgType</a></li>
          </ul></dd>
<dt><a name="mul" href="#mul"><span>mul:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: proc mul(_: type[Curve25519]; point: var Curve25519Key; multiplier: Curve25519Key)" href="libp2p/crypto/curve25519.html#mul%2Ctype%5BCurve25519%5D%2CCurve25519Key%2CCurve25519Key">curve25519: proc mul(_: type[Curve25519]; point: var Curve25519Key; multiplier: Curve25519Key)</a></li>
          </ul></dd>
<dt><a name="MultiAddress" href="#MultiAddress"><span>MultiAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: object MultiAddress" href="libp2p/multiaddress.html#MultiAddress">multiaddress: object MultiAddress</a></li>
          </ul></dd>
<dt><a name="MultiBase" href="#MultiBase"><span>MultiBase:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multibase: object MultiBase" href="libp2p/multibase.html#MultiBase">multibase: object MultiBase</a></li>
          </ul></dd>
<dt><a name="MultiBaseStatus" href="#MultiBaseStatus"><span>MultiBaseStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multibase: enum MultiBaseStatus" href="libp2p/multibase.html#MultiBaseStatus">multibase: enum MultiBaseStatus</a></li>
          </ul></dd>
<dt><a name="MultiCodec" href="#MultiCodec"><span>MultiCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multicodec: type MultiCodec" href="libp2p/multicodec.html#MultiCodec">multicodec: type MultiCodec</a></li>
          </ul></dd>
<dt><a name="multiCodec" href="#multiCodec"><span>multiCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multicodec: proc multiCodec(code: int): MultiCodec" href="libp2p/multicodec.html#multiCodec%2Cint">multicodec: proc multiCodec(code: int): MultiCodec</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc multiCodec(name: string): MultiCodec" href="libp2p/multicodec.html#multiCodec%2Cstring">multicodec: proc multiCodec(name: string): MultiCodec</a></li>
          </ul></dd>
<dt><a name="MultiCodecError" href="#MultiCodecError"><span>MultiCodecError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multicodec: enum MultiCodecError" href="libp2p/multicodec.html#MultiCodecError">multicodec: enum MultiCodecError</a></li>
          </ul></dd>
<dt><a name="MultiCodecNotSupported" href="#MultiCodecNotSupported"><span>MultiCodecNotSupported:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multicodec: MultiCodecError.MultiCodecNotSupported" href="libp2p/multicodec.html#MultiCodecNotSupported">multicodec: MultiCodecError.MultiCodecNotSupported</a></li>
          </ul></dd>
<dt><a name="MultiHash" href="#MultiHash"><span>MultiHash:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multihash: object MultiHash" href="libp2p/multihash.html#MultiHash">multihash: object MultiHash</a></li>
          </ul></dd>
<dt><a name="MultiStreamError" href="#MultiStreamError"><span>MultiStreamError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: object MultiStreamError" href="libp2p/multistream.html#MultiStreamError">multistream: object MultiStreamError</a></li>
          </ul></dd>
<dt><a name="MultistreamSelect" href="#MultistreamSelect"><span>MultistreamSelect:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: type MultistreamSelect" href="libp2p/multistream.html#MultistreamSelect">multistream: type MultistreamSelect</a></li>
          </ul></dd>
<dt><a name="MuxedUpgrade" href="#MuxedUpgrade"><span>MuxedUpgrade:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxedupgrade: type MuxedUpgrade" href="libp2p/upgrademngrs/muxedupgrade.html#MuxedUpgrade">muxedupgrade: type MuxedUpgrade</a></li>
          </ul></dd>
<dt><a name="Muxer" href="#Muxer"><span>Muxer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: type Muxer" href="libp2p/muxers/muxer.html#Muxer">muxer: type Muxer</a></li>
          </ul></dd>
<dt><a name="MuxerConstructor" href="#MuxerConstructor"><span>MuxerConstructor:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: type MuxerConstructor" href="libp2p/muxers/muxer.html#MuxerConstructor">muxer: type MuxerConstructor</a></li>
          </ul></dd>
<dt><a name="MuxerError" href="#MuxerError"><span>MuxerError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: object MuxerError" href="libp2p/muxers/muxer.html#MuxerError">muxer: object MuxerError</a></li>
          </ul></dd>
<dt><a name="MuxerHandler" href="#MuxerHandler"><span>MuxerHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: type MuxerHandler" href="libp2p/muxers/muxer.html#MuxerHandler">muxer: type MuxerHandler</a></li>
          </ul></dd>
<dt><a name="MuxerProvider" href="#MuxerProvider"><span>MuxerProvider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: object MuxerProvider" href="libp2p/muxers/muxer.html#MuxerProvider">muxer: object MuxerProvider</a></li>
          </ul></dd>
<dt><a name="NameResolver" href="#NameResolver"><span>NameResolver:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="nameresolver: type NameResolver" href="libp2p/nameresolving/nameresolver.html#NameResolver">nameresolver: type NameResolver</a></li>
          </ul></dd>
<dt><a name="negotiateStream" href="#negotiateStream"><span>negotiateStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: method negotiateStream(self: Dial; conn: Connection; protos: seq[string]): InternalRaisesFuture[
    Connection, (CatchableError,)]" href="libp2p/dial.html#negotiateStream.e%2CDial%2CConnection%2Cseq%5Bstring%5D">dial: method negotiateStream(self: Dial; conn: Connection; protos: seq[string]): InternalRaisesFuture[
    Connection, (CatchableError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method negotiateStream(self: Dialer; conn: Connection; protos: seq[string]): InternalRaisesFuture[
    Connection, (CatchableError,)]" href="libp2p/dialer.html#negotiateStream.e%2CDialer%2CConnection%2Cseq%5Bstring%5D">dialer: method negotiateStream(self: Dialer; conn: Connection; protos: seq[string]): InternalRaisesFuture[
    Connection, (CatchableError,)]</a></li>
          </ul></dd>
<dt><a name="NetworkInterfaceProvider" href="#NetworkInterfaceProvider"><span>NetworkInterfaceProvider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wildcardresolverservice: type NetworkInterfaceProvider" href="libp2p/services/wildcardresolverservice.html#NetworkInterfaceProvider">wildcardresolverservice: type NetworkInterfaceProvider</a></li>
          </ul></dd>
<dt><a name="NetworkReachability" href="#NetworkReachability"><span>NetworkReachability:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: enum NetworkReachability" href="libp2p/protocols/connectivity/autonat/types.html#NetworkReachability">types: enum NetworkReachability</a></li>
          </ul></dd>
<dt><a name="new" href="#new"><span>new:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc new(T: type[SwitchBuilder]): T:type" href="libp2p/builders.html#new%2Ctype%5BSwitchBuilder%5D">builders: proc new(T: type[SwitchBuilder]): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connmanager: proc new(C: type ConnManager; maxConnsPerPeer = MaxConnectionsPerPeer;
    maxConnections = MaxConnections; maxIn = -1; maxOut = -1): ConnManager" href="libp2p/connmanager.html#new%2CtypeConnManager%2Cint%2Cint">connmanager: proc new(C: type ConnManager; maxConnsPerPeer = MaxConnectionsPerPeer;
    maxConnections = MaxConnections; maxIn = -1; maxOut = -1): ConnManager</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: proc new(T: type Dialer; localPeerId: PeerId; connManager: ConnManager;
    peerStore: PeerStore; transports: seq[Transport];
    nameResolver: NameResolver = nil): Dialer" href="libp2p/dialer.html#new%2CtypeDialer%2CPeerId%2CConnManager%2CPeerStore%2Cseq%5BTransport%5D%2CNameResolver">dialer: proc new(T: type Dialer; localPeerId: PeerId; connManager: ConnManager;
    peerStore: PeerStore; transports: seq[Transport];
    nameResolver: NameResolver = nil): Dialer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multistream: proc new(T: typedesc[MultistreamSelect]): T:type" href="libp2p/multistream.html#new%2Ctypedesc%5BMultistreamSelect%5D">multistream: proc new(T: typedesc[MultistreamSelect]): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mplex: proc new(M: type Mplex; conn: Connection; inTimeout: Duration = DefaultChanTimeout;
    outTimeout: Duration = DefaultChanTimeout;
    maxChannCount: int = MaxChannelCount): Mplex" href="libp2p/muxers/mplex/mplex.html#new%2CtypeMplex%2CConnection%2CDuration%2CDuration%2Cint">mplex: proc new(M: type Mplex; conn: Connection; inTimeout: Duration = DefaultChanTimeout;
    outTimeout: Duration = DefaultChanTimeout;
    maxChannCount: int = MaxChannelCount): Mplex</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxer: proc new(T: typedesc[MuxerProvider]; creator: MuxerConstructor; codec: string): T:type" href="libp2p/muxers/muxer.html#new%2Ctypedesc%5BMuxerProvider%5D%2CMuxerConstructor%2Cstring">muxer: proc new(T: typedesc[MuxerProvider]; creator: MuxerConstructor; codec: string): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: proc new(T: type[Yamux]; conn: Connection; maxChannCount: int = MaxChannelCount;
    windowSize: int = YamuxDefaultWindowSize;
    maxSendQueueSize: int = MaxSendQueueSize; inTimeout: Duration = 5.minutes;
    outTimeout: Duration = 5.minutes): T:type" href="libp2p/muxers/yamux/yamux.html#new%2Ctype%5BYamux%5D%2CConnection%2Cint%2Cint%2Cint%2CDuration%2CDuration">yamux: proc new(T: type[Yamux]; conn: Connection; maxChannCount: int = MaxChannelCount;
    windowSize: int = YamuxDefaultWindowSize;
    maxSendQueueSize: int = MaxSendQueueSize; inTimeout: Duration = 5.minutes;
    outTimeout: Duration = 5.minutes): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="observedaddrmanager: proc new(T: typedesc[ObservedAddrManager]; maxSize = 10; minCount = 3): T:type" href="libp2p/observedaddrmanager.html#new%2Ctypedesc%5BObservedAddrManager%5D%2Cint%2Cint">observedaddrmanager: proc new(T: typedesc[ObservedAddrManager]; maxSize = 10; minCount = 3): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="client: proc new(T: typedesc[PeerIDAuthClient]; rng: ref HmacDrbgContext = newRng()): PeerIDAuthClient" href="libp2p/peeridauth/client.html#new%2Ctypedesc%5BPeerIDAuthClient%5D%2Cref.HmacDrbgContext">client: proc new(T: typedesc[PeerIDAuthClient]; rng: ref HmacDrbgContext = newRng()): PeerIDAuthClient</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerinfo: proc new(p: typedesc[PeerInfo]; key: PrivateKey;
    listenAddrs: openArray[MultiAddress] = [];
    protocols: openArray[string] = []; protoVersion: string = &quot;&quot;;
    agentVersion: string = &quot;&quot;; addressMappers = newSeq[AddressMapper]()): PeerInfo" href="libp2p/peerinfo.html#new%2Ctypedesc%5BPeerInfo%5D%2CPrivateKey%2CopenArray%5BMultiAddress%5D%2CopenArray%5Bstring%5D%2Cstring%2Cstring">peerinfo: proc new(p: typedesc[PeerInfo]; key: PrivateKey;
    listenAddrs: openArray[MultiAddress] = [];
    protocols: openArray[string] = []; protoVersion: string = &quot;&quot;;
    agentVersion: string = &quot;&quot;; addressMappers = newSeq[AddressMapper]()): PeerInfo</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerstore: proc new(T: type PeerStore; identify: Identify; capacity = 1000): PeerStore" href="libp2p/peerstore.html#new%2CtypePeerStore%2CIdentify%2Cint">peerstore: proc new(T: type PeerStore; identify: Identify; capacity = 1000): PeerStore</a></li>
          <li><a class="reference external"
          data-doc-search-tag="server: proc new(T: typedesc[Autonat]; switch: Switch; semSize: int = 1;
    dialTimeout = 15.seconds): T:type" href="libp2p/protocols/connectivity/autonat/server.html#new%2Ctypedesc%5BAutonat%5D%2CSwitch%2Cint">server: proc new(T: typedesc[Autonat]; switch: Switch; semSize: int = 1;
    dialTimeout = 15.seconds): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="client: proc new(T: typedesc[AutonatV2Client]; rng: ref HmacDrbgContext;
    dialBackTimeout: Duration = DefaultDialBackTimeout): T:type" href="libp2p/protocols/connectivity/autonatv2/client.html#new%2Ctypedesc%5BAutonatV2Client%5D%2Cref.HmacDrbgContext%2CDuration">client: proc new(T: typedesc[AutonatV2Client]; rng: ref HmacDrbgContext;
    dialBackTimeout: Duration = DefaultDialBackTimeout): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="server: proc new(T: typedesc[AutonatV2]; switch: Switch;
    config: AutonatV2Config = AutonatV2Config.new()): T:type" href="libp2p/protocols/connectivity/autonatv2/server.html#new%2Ctypedesc%5BAutonatV2%5D%2CSwitch%2CAutonatV2Config">server: proc new(T: typedesc[AutonatV2]; switch: Switch;
    config: AutonatV2Config = AutonatV2Config.new()): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="server: proc new(T: typedesc[AutonatV2Config]; dialTimeout: Duration = DefaultDialTimeout;
    dialDataSize: uint64 = DefaultDialDataSize; amplificationAttackTimeout: Duration = DefaultAmplificationAttackDialTimeout;
    allowPrivateAddresses: bool = false): T:type" href="libp2p/protocols/connectivity/autonatv2/server.html#new%2Ctypedesc%5BAutonatV2Config%5D%2CDuration%2Cuint64%2CDuration%2Cbool">server: proc new(T: typedesc[AutonatV2Config]; dialTimeout: Duration = DefaultDialTimeout;
    dialDataSize: uint64 = DefaultDialDataSize; amplificationAttackTimeout: Duration = DefaultAmplificationAttackDialTimeout;
    allowPrivateAddresses: bool = false): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="service: proc new(T: typedesc[AutonatV2Service]; rng: ref HmacDrbgContext;
    client: AutonatV2Client = AutonatV2Client.new();
    config: AutonatV2ServiceConfig = AutonatV2ServiceConfig.new()): T:type" href="libp2p/protocols/connectivity/autonatv2/service.html#new%2Ctypedesc%5BAutonatV2Service%5D%2Cref.HmacDrbgContext%2CAutonatV2Client%2CAutonatV2ServiceConfig">service: proc new(T: typedesc[AutonatV2Service]; rng: ref HmacDrbgContext;
    client: AutonatV2Client = AutonatV2Client.new();
    config: AutonatV2ServiceConfig = AutonatV2ServiceConfig.new()): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="service: proc new(T: typedesc[AutonatV2ServiceConfig];
    scheduleInterval: Opt[Duration] = noneDuration; askNewConnectedPeers = true;
    numPeersToAsk: int = 5; maxQueueSize: int = 10; minConfidence: float = 0.3;
    enableAddressMapper = true): T:type" href="libp2p/protocols/connectivity/autonatv2/service.html#new%2Ctypedesc%5BAutonatV2ServiceConfig%5D%2COpt%5BDuration%5D%2Cint%2Cint%2Cfloat">service: proc new(T: typedesc[AutonatV2ServiceConfig];
    scheduleInterval: Opt[Duration] = noneDuration; askNewConnectedPeers = true;
    numPeersToAsk: int = 5; maxQueueSize: int = 10; minConfidence: float = 0.3;
    enableAddressMapper = true): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="client: proc new(T: typedesc[RelayClient]; canHop: bool = false;
    reservationTTL: times.Duration = DefaultReservationTTL;
    limitDuration: uint32 = DefaultLimitDuration;
    limitData: uint64 = DefaultLimitData;
    heartbeatSleepTime: uint32 = DefaultHeartbeatSleepTime;
    maxCircuit: int = MaxCircuit; maxCircuitPerPeer: int = MaxCircuitPerPeer;
    msgSize: int = RelayClientMsgSize; circuitRelayV1: bool = false): T:type" href="libp2p/protocols/connectivity/relay/client.html#new%2Ctypedesc%5BRelayClient%5D%2Cbool%2Cuint32%2Cuint64%2Cuint32%2Cint%2Cint%2Cint%2Cbool">client: proc new(T: typedesc[RelayClient]; canHop: bool = false;
    reservationTTL: times.Duration = DefaultReservationTTL;
    limitDuration: uint32 = DefaultLimitDuration;
    limitData: uint64 = DefaultLimitData;
    heartbeatSleepTime: uint32 = DefaultHeartbeatSleepTime;
    maxCircuit: int = MaxCircuit; maxCircuitPerPeer: int = MaxCircuitPerPeer;
    msgSize: int = RelayClientMsgSize; circuitRelayV1: bool = false): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rconn: proc new(T: typedesc[RelayConnection]; conn: Connection; limitDuration: uint32;
    limitData: uint64): T:type" href="libp2p/protocols/connectivity/relay/rconn.html#new%2Ctypedesc%5BRelayConnection%5D%2CConnection%2Cuint32%2Cuint64">rconn: proc new(T: typedesc[RelayConnection]; conn: Connection; limitDuration: uint32;
    limitData: uint64): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="relay: proc new(T: typedesc[Relay]; reservationTTL: times.Duration = DefaultReservationTTL;
    limitDuration: uint32 = DefaultLimitDuration;
    limitData: uint64 = DefaultLimitData;
    heartbeatSleepTime: uint32 = DefaultHeartbeatSleepTime;
    maxCircuit: int = MaxCircuit; maxCircuitPerPeer: int = MaxCircuitPerPeer;
    msgSize: int = RelayMsgSize; circuitRelayV1: bool = false): T:type" href="libp2p/protocols/connectivity/relay/relay.html#new%2Ctypedesc%5BRelay%5D%2Cuint32%2Cuint64%2Cuint32%2Cint%2Cint%2Cint%2Cbool">relay: proc new(T: typedesc[Relay]; reservationTTL: times.Duration = DefaultReservationTTL;
    limitDuration: uint32 = DefaultLimitDuration;
    limitData: uint64 = DefaultLimitData;
    heartbeatSleepTime: uint32 = DefaultHeartbeatSleepTime;
    maxCircuit: int = MaxCircuit; maxCircuitPerPeer: int = MaxCircuitPerPeer;
    msgSize: int = RelayMsgSize; circuitRelayV1: bool = false): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rtransport: proc new(T: typedesc[RelayTransport]; cl: RelayClient; upgrader: Upgrade): T:type" href="libp2p/protocols/connectivity/relay/rtransport.html#new%2Ctypedesc%5BRelayTransport%5D%2CRelayClient%2CUpgrade">rtransport: proc new(T: typedesc[RelayTransport]; cl: RelayClient; upgrader: Upgrade): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="identify: proc new(T: typedesc[Identify]; peerInfo: PeerInfo; sendSignedPeerRecord = false;
    observedAddrManager = ObservedAddrManager.new()): T:type" href="libp2p/protocols/identify.html#new%2Ctypedesc%5BIdentify%5D%2CPeerInfo">identify: proc new(T: typedesc[Identify]; peerInfo: PeerInfo; sendSignedPeerRecord = false;
    observedAddrManager = ObservedAddrManager.new()): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="identify: proc new(T: typedesc[IdentifyPush]; handler: IdentifyPushHandler = nil): T:type" href="libp2p/protocols/identify.html#new%2Ctypedesc%5BIdentifyPush%5D%2CIdentifyPushHandler">identify: proc new(T: typedesc[IdentifyPush]; handler: IdentifyPushHandler = nil): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="kademlia: proc new(T: typedesc[KadDHT]; switch: Switch;
    bootstrapNodes: seq[(PeerId, seq[MultiAddress])] = @[];
    config: KadDHTConfig = KadDHTConfig.new();
    rng: ref HmacDrbgContext = newRng(); client: bool = false;
    codec: string = KadCodec): T:type" href="libp2p/protocols/kademlia.html#new%2Ctypedesc%5BKadDHT%5D%2CSwitch%2Cseq%5B%5D%2CKadDHTConfig%2Cref.HmacDrbgContext%2Cbool%2Cstring">kademlia: proc new(T: typedesc[KadDHT]; switch: Switch;
    bootstrapNodes: seq[(PeerId, seq[MultiAddress])] = @[];
    config: KadDHTConfig = KadDHTConfig.new();
    rng: ref HmacDrbgContext = newRng(); client: bool = false;
    codec: string = KadCodec): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routingtable: proc new(T: typedesc[RoutingTable]; selfId: Key;
    config: RoutingTableConfig = RoutingTableConfig.new()): T:type" href="libp2p/protocols/kademlia/routingtable.html#new%2Ctypedesc%5BRoutingTable%5D%2CKey%2CRoutingTableConfig">routingtable: proc new(T: typedesc[RoutingTable]; selfId: Key;
    config: RoutingTableConfig = RoutingTableConfig.new()): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routingtable: proc new(T: typedesc[RoutingTableConfig]; replication = DefaultReplication;
    hasher: Opt[XorDHasher] = NoneHasher; maxBuckets: int = DefaultMaxBuckets): T:type" href="libp2p/protocols/kademlia/routingtable.html#new%2Ctypedesc%5BRoutingTableConfig%5D%2COpt%5BXorDHasher%5D%2Cint">routingtable: proc new(T: typedesc[RoutingTableConfig]; replication = DefaultReplication;
    hasher: Opt[XorDHasher] = NoneHasher; maxBuckets: int = DefaultMaxBuckets): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc new(T: typedesc[KadDHTConfig];
    validator: EntryValidator = DefaultEntryValidator();
    selector: EntrySelector = DefaultEntrySelector();
    timeout: chronos.Duration = DefaultTimeout;
    bucketRefreshTime: chronos.Duration = DefaultBucketRefreshTime;
    retries: int = DefaultRetries; replication: int = DefaultReplication;
    alpha: int = DefaultAlpha; quorum: int = DefaultQuorum;
    providerRecordCapacity = DefaultProviderRecordCapacity;
    providedKeyCapacity = DefaultProvidedKeyCapacity;
    republishProvidedKeysInterval: chronos.Duration = DefaultRepublishInterval;
    cleanupProvidersInterval: chronos.Duration = DefaultCleanupProvidersInterval;
    providerExpirationInterval: chronos.Duration = DefaultProviderExpirationInterval): T:type" href="libp2p/protocols/kademlia/types.html#new%2Ctypedesc%5BKadDHTConfig%5D%2CEntryValidator%2CEntrySelector%2Cint%2Cint%2Cint%2Cint">types: proc new(T: typedesc[KadDHTConfig];
    validator: EntryValidator = DefaultEntryValidator();
    selector: EntrySelector = DefaultEntrySelector();
    timeout: chronos.Duration = DefaultTimeout;
    bucketRefreshTime: chronos.Duration = DefaultBucketRefreshTime;
    retries: int = DefaultRetries; replication: int = DefaultReplication;
    alpha: int = DefaultAlpha; quorum: int = DefaultQuorum;
    providerRecordCapacity = DefaultProviderRecordCapacity;
    providedKeyCapacity = DefaultProvidedKeyCapacity;
    republishProvidedKeysInterval: chronos.Duration = DefaultRepublishInterval;
    cleanupProvidersInterval: chronos.Duration = DefaultCleanupProvidersInterval;
    providerExpirationInterval: chronos.Duration = DefaultProviderExpirationInterval): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc new(T: typedesc[ProviderManager]; providerRecordCapacity: int;
    providedKeyCapacity: int): T:type" href="libp2p/protocols/kademlia/types.html#new%2Ctypedesc%5BProviderManager%5D%2Cint%2Cint">types: proc new(T: typedesc[ProviderManager]; providerRecordCapacity: int;
    providedKeyCapacity: int): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ping: proc new(T: typedesc[Ping]; handler: PingHandler = nil;
    rng: ref HmacDrbgContext = newRng()): T:type" href="libp2p/protocols/ping.html#new%2Ctypedesc%5BPing%5D%2CPingHandler%2Cref.HmacDrbgContext">ping: proc new(T: typedesc[Ping]; handler: PingHandler = nil;
    rng: ref HmacDrbgContext = newRng()): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protocol: proc new(T: type LPProtocol; codecs: seq[string]; handler: LPProtoHandler;
    maxIncomingStreams: Opt[int] | int = Opt.none(int)): T:type" href="libp2p/protocols/protocol.html#new%2CtypeLPProtocol%2Cseq%5Bstring%5D%2CLPProtoHandler">protocol: proc new(T: type LPProtocol; codecs: seq[string]; handler: LPProtoHandler;
    maxIncomingStreams: Opt[int] | int = Opt.none(int)): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc new(T: typedesc[PubSubPeer]; peerId: PeerId; getConn: GetConn; onEvent: OnEvent;
    codec: string; maxMessageSize: int; maxNumElementsInNonPriorityQueue: int = DefaultMaxNumElementsInNonPriorityQueue;
    overheadRateLimitOpt: Opt[TokenBucket] = Opt.none(TokenBucket);
    customConnCallbacks: Option[CustomConnectionCallbacks] = none(
    CustomConnectionCallbacks)): T:type" href="libp2p/protocols/pubsub/pubsubpeer.html#new%2Ctypedesc%5BPubSubPeer%5D%2CPeerId%2CGetConn%2COnEvent%2Cstring%2Cint%2Cint%2COpt%5BTokenBucket%5D%2COption%5BCustomConnectionCallbacks%5D">pubsubpeer: proc new(T: typedesc[PubSubPeer]; peerId: PeerId; getConn: GetConn; onEvent: OnEvent;
    codec: string; maxMessageSize: int; maxNumElementsInNonPriorityQueue: int = DefaultMaxNumElementsInNonPriorityQueue;
    overheadRateLimitOpt: Opt[TokenBucket] = Opt.none(TokenBucket);
    customConnCallbacks: Option[CustomConnectionCallbacks] = none(
    CustomConnectionCallbacks)): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: proc new(T: typedesc[RendezVous]; rng: ref HmacDrbgContext = newRng();
    minDuration = MinimumDuration; maxDuration = MaximumDuration): T:type" href="libp2p/protocols/rendezvous/rendezvous.html#new%2Ctypedesc%5BRendezVous%5D%2Cref.HmacDrbgContext">rendezvous: proc new(T: typedesc[RendezVous]; rng: ref HmacDrbgContext = newRng();
    minDuration = MinimumDuration; maxDuration = MaximumDuration): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: proc new(T: typedesc[RendezVous]; rng: ref HmacDrbgContext = newRng();
    minDuration = MinimumDuration; maxDuration = MaximumDuration; codec: string): T:type" href="libp2p/protocols/rendezvous/rendezvous.html#new%2Ctypedesc%5BRendezVous%5D%2Cref.HmacDrbgContext%2Cstring">rendezvous: proc new(T: typedesc[RendezVous]; rng: ref HmacDrbgContext = newRng();
    minDuration = MinimumDuration; maxDuration = MaximumDuration; codec: string): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: proc new(T: typedesc[RendezVous]; switch: Switch;
    rng: ref HmacDrbgContext = newRng(); minDuration = MinimumDuration;
    maxDuration = MaximumDuration): T:type" href="libp2p/protocols/rendezvous/rendezvous.html#new%2Ctypedesc%5BRendezVous%5D%2CSwitch%2Cref.HmacDrbgContext">rendezvous: proc new(T: typedesc[RendezVous]; switch: Switch;
    rng: ref HmacDrbgContext = newRng(); minDuration = MinimumDuration;
    maxDuration = MaximumDuration): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="noise: proc new(T: typedesc[Noise]; rng: ref HmacDrbgContext; privateKey: PrivateKey;
    outgoing: bool = true; commonPrologue: seq[byte] = @[]): T:type" href="libp2p/protocols/secure/noise.html#new%2Ctypedesc%5BNoise%5D%2Cref.HmacDrbgContext%2CPrivateKey%2Cbool%2Cseq%5Bbyte%5D">noise: proc new(T: typedesc[Noise]; rng: ref HmacDrbgContext; privateKey: PrivateKey;
    outgoing: bool = true; commonPrologue: seq[byte] = @[]): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: proc new(T: type SecureConn; conn: Connection; peerId: PeerId;
    observedAddr: Opt[MultiAddress]; localAddr: Opt[MultiAddress];
    timeout: Duration = DefaultConnectionTimeout): T:type" href="libp2p/protocols/secure/secure.html#new%2CtypeSecureConn%2CConnection%2CPeerId%2COpt%5BMultiAddress%5D%2COpt%5BMultiAddress%5D%2CDuration">secure: proc new(T: type SecureConn; conn: Connection; peerId: PeerId;
    observedAddr: Opt[MultiAddress]; localAddr: Opt[MultiAddress];
    timeout: Duration = DefaultConnectionTimeout): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wildcardresolverservice: proc new(T: typedesc[WildcardAddressResolverService];
    networkInterfaceProvider: NetworkInterfaceProvider = getAddresses): T:type" href="libp2p/services/wildcardresolverservice.html#new%2Ctypedesc%5BWildcardAddressResolverService%5D%2CNetworkInterfaceProvider">wildcardresolverservice: proc new(T: typedesc[WildcardAddressResolverService];
    networkInterfaceProvider: NetworkInterfaceProvider = getAddresses): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bufferstream: proc new(T: typedesc[BufferStream]; timeout: Duration = DefaultConnectionTimeout): T:type" href="libp2p/stream/bufferstream.html#new%2Ctypedesc%5BBufferStream%5D%2CDuration">bufferstream: proc new(T: typedesc[BufferStream]; timeout: Duration = DefaultConnectionTimeout): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: proc new(C: type Connection; peerId: PeerId; dir: Direction;
    observedAddr: Opt[MultiAddress] = Opt.none(MultiAddress);
    localAddr: Opt[MultiAddress] = Opt.none(MultiAddress);
    timeout: Duration = DefaultConnectionTimeout;
    timeoutHandler: TimeoutHandler = nil): Connection" href="libp2p/stream/connection.html#new%2CtypeConnection%2CPeerId%2CDirection%2COpt%5BMultiAddress%5D%2COpt%5BMultiAddress%5D%2CDuration%2CTimeoutHandler">connection: proc new(C: type Connection; peerId: PeerId; dir: Direction;
    observedAddr: Opt[MultiAddress] = Opt.none(MultiAddress);
    localAddr: Opt[MultiAddress] = Opt.none(MultiAddress);
    timeout: Duration = DefaultConnectionTimeout;
    timeoutHandler: TimeoutHandler = nil): Connection</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: proc new(T: typedesc[MemoryTransport]; upgrade: Upgrade = Upgrade();
    rng: ref HmacDrbgContext = newRng()): T:type" href="libp2p/transports/memorytransport.html#new%2Ctypedesc%5BMemoryTransport%5D%2CUpgrade%2Cref.HmacDrbgContext">memorytransport: proc new(T: typedesc[MemoryTransport]; upgrade: Upgrade = Upgrade();
    rng: ref HmacDrbgContext = newRng()): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: proc new(_: type QuicMuxer; conn: P2PConnection;
    peerId: Opt[PeerId] = Opt.none(PeerId)): QuicMuxer" href="libp2p/transports/quictransport.html#new%2CtypeQuicMuxer%2CP2PConnection%2COpt%5BPeerId%5D">quictransport: proc new(_: type QuicMuxer; conn: P2PConnection;
    peerId: Opt[PeerId] = Opt.none(PeerId)): QuicMuxer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: proc new(_: type QuicTransport; u: Upgrade; privateKey: PrivateKey): QuicTransport" href="libp2p/transports/quictransport.html#new%2CtypeQuicTransport%2CUpgrade%2CPrivateKey">quictransport: proc new(_: type QuicTransport; u: Upgrade; privateKey: PrivateKey): QuicTransport</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: proc new(_: type QuicTransport; u: Upgrade; privateKey: PrivateKey;
    certGenerator: CertGenerator): QuicTransport" href="libp2p/transports/quictransport.html#new%2CtypeQuicTransport%2CUpgrade%2CPrivateKey%2CCertGenerator">quictransport: proc new(_: type QuicTransport; u: Upgrade; privateKey: PrivateKey;
    certGenerator: CertGenerator): QuicTransport</a></li>
          <li><a class="reference external"
          data-doc-search-tag="tcptransport: proc new(T: typedesc[TcpTransport]; flags: set[ServerFlags] = {}; upgrade: Upgrade;
    connectionsTimeout = 10.minutes): T:type" href="libp2p/transports/tcptransport.html#new%2Ctypedesc%5BTcpTransport%5D%2Cset%5BServerFlags%5D%2CUpgrade">tcptransport: proc new(T: typedesc[TcpTransport]; flags: set[ServerFlags] = {}; upgrade: Upgrade;
    connectionsTimeout = 10.minutes): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: proc new(T: typedesc[WsTransport]; upgrade: Upgrade; flags: set[ServerFlags] = {};
    factories: openArray[ExtFactory] = []; rng: ref HmacDrbgContext = nil;
    handshakeTimeout = DefaultHeadersTimeout): T:type" href="libp2p/transports/wstransport.html#new%2Ctypedesc%5BWsTransport%5D%2CUpgrade%2Cset%5BServerFlags%5D%2CopenArray%5BExtFactory%5D%2Cref.HmacDrbgContext">wstransport: proc new(T: typedesc[WsTransport]; upgrade: Upgrade; flags: set[ServerFlags] = {};
    factories: openArray[ExtFactory] = []; rng: ref HmacDrbgContext = nil;
    handshakeTimeout = DefaultHeadersTimeout): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: proc new(T: typedesc[WsTransport]; upgrade: Upgrade; tlsPrivateKey: TLSPrivateKey;
    tlsCertificate: TLSCertificate; autotls: Opt[AutotlsService];
    tlsFlags: set[TLSFlags] = {}; flags: set[ServerFlags] = {};
    factories: openArray[ExtFactory] = []; rng: ref HmacDrbgContext = nil;
    handshakeTimeout = DefaultHeadersTimeout): T:type" href="libp2p/transports/wstransport.html#new%2Ctypedesc%5BWsTransport%5D%2CUpgrade%2CTLSPrivateKey%2CTLSCertificate%2COpt%5BAutotlsService%5D%2Cset%5BTLSFlags%5D%2Cset%5BServerFlags%5D%2CopenArray%5BExtFactory%5D%2Cref.HmacDrbgContext">wstransport: proc new(T: typedesc[WsTransport]; upgrade: Upgrade; tlsPrivateKey: TLSPrivateKey;
    tlsCertificate: TLSCertificate; autotls: Opt[AutotlsService];
    tlsFlags: set[TLSFlags] = {}; flags: set[ServerFlags] = {};
    factories: openArray[ExtFactory] = []; rng: ref HmacDrbgContext = nil;
    handshakeTimeout = DefaultHeadersTimeout): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: proc new(T: type WsStream; session: WSSession; dir: Direction;
    observedAddr: Opt[MultiAddress]; localAddr: Opt[MultiAddress];
    timeout = 10.minutes): T:type" href="libp2p/transports/wstransport.html#new%2CtypeWsStream%2CWSSession%2CDirection%2COpt%5BMultiAddress%5D%2COpt%5BMultiAddress%5D">wstransport: proc new(T: type WsStream; session: WSSession; dir: Direction;
    observedAddr: Opt[MultiAddress]; localAddr: Opt[MultiAddress];
    timeout = 10.minutes): T:type</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxedupgrade: proc new(T: type MuxedUpgrade; muxers: seq[MuxerProvider];
    secureManagers: openArray[Secure] = []; ms: MultistreamSelect): T:type" href="libp2p/upgrademngrs/muxedupgrade.html#new%2CtypeMuxedUpgrade%2Cseq%5BMuxerProvider%5D%2CopenArray%5BSecure%5D%2CMultistreamSelect">muxedupgrade: proc new(T: type MuxedUpgrade; muxers: seq[MuxerProvider];
    secureManagers: openArray[Secure] = []; ms: MultistreamSelect): T:type</a></li>
          </ul></dd>
<dt><a name="newInvalidMplexMsgType" href="#newInvalidMplexMsgType"><span>newInvalidMplexMsgType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="coder: proc newInvalidMplexMsgType(): ref InvalidMplexMsgType" href="libp2p/muxers/mplex/coder.html#newInvalidMplexMsgType">coder: proc newInvalidMplexMsgType(): ref InvalidMplexMsgType</a></li>
          </ul></dd>
<dt><a name="newLPStreamClosedError" href="#newLPStreamClosedError"><span>newLPStreamClosedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc newLPStreamClosedError(): ref LPStreamClosedError" href="libp2p/stream/lpstream.html#newLPStreamClosedError">lpstream: proc newLPStreamClosedError(): ref LPStreamClosedError</a></li>
          </ul></dd>
<dt><a name="newLPStreamConnDownError" href="#newLPStreamConnDownError"><span>newLPStreamConnDownError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc newLPStreamConnDownError(parentException: ref Exception = nil): ref LPStreamConnDownError" href="libp2p/stream/lpstream.html#newLPStreamConnDownError%2Cref.Exception">lpstream: proc newLPStreamConnDownError(parentException: ref Exception = nil): ref LPStreamConnDownError</a></li>
          </ul></dd>
<dt><a name="newLPStreamEOFError" href="#newLPStreamEOFError"><span>newLPStreamEOFError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc newLPStreamEOFError(): ref LPStreamEOFError" href="libp2p/stream/lpstream.html#newLPStreamEOFError">lpstream: proc newLPStreamEOFError(): ref LPStreamEOFError</a></li>
          </ul></dd>
<dt><a name="newLPStreamIncompleteError" href="#newLPStreamIncompleteError"><span>newLPStreamIncompleteError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc newLPStreamIncompleteError(): ref LPStreamIncompleteError" href="libp2p/stream/lpstream.html#newLPStreamIncompleteError">lpstream: proc newLPStreamIncompleteError(): ref LPStreamIncompleteError</a></li>
          </ul></dd>
<dt><a name="newLPStreamLimitError" href="#newLPStreamLimitError"><span>newLPStreamLimitError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc newLPStreamLimitError(): ref LPStreamLimitError" href="libp2p/stream/lpstream.html#newLPStreamLimitError">lpstream: proc newLPStreamLimitError(): ref LPStreamLimitError</a></li>
          </ul></dd>
<dt><a name="newLPStreamRemoteClosedError" href="#newLPStreamRemoteClosedError"><span>newLPStreamRemoteClosedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc newLPStreamRemoteClosedError(): ref LPStreamRemoteClosedError" href="libp2p/stream/lpstream.html#newLPStreamRemoteClosedError">lpstream: proc newLPStreamRemoteClosedError(): ref LPStreamRemoteClosedError</a></li>
          </ul></dd>
<dt><a name="newLPStreamResetError" href="#newLPStreamResetError"><span>newLPStreamResetError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: proc newLPStreamResetError(): ref LPStreamResetError" href="libp2p/stream/lpstream.html#newLPStreamResetError">lpstream: proc newLPStreamResetError(): ref LPStreamResetError</a></li>
          </ul></dd>
<dt><a name="newRng" href="#newRng"><span>newRng:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc newRng(): ref HmacDrbgContext" href="libp2p/crypto/crypto.html#newRng">crypto: proc newRng(): ref HmacDrbgContext</a></li>
          </ul></dd>
<dt><a name="newStandardSwitch" href="#newStandardSwitch"><span>newStandardSwitch:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc newStandardSwitch(privKey = Opt.none(PrivateKey); addrs: MultiAddress |
    seq[MultiAddress] = newSeq[MultiAddress]();
                  transport: TransportType = TransportType.TCP;
                  transportFlags: set[ServerFlags] = {}; rng = newRng();
    secureManagers: openArray[SecureProtocol] = [SecureProtocol.Noise];
                  inTimeout: Duration = 5.minutes;
                  outTimeout: Duration = 5.minutes;
                  maxConnections = MaxConnections; maxIn = -1; maxOut = -1;
                  maxConnsPerPeer = MaxConnectionsPerPeer;
                  nameResolver = Opt.none(NameResolver);
                  sendSignedPeerRecord = false; peerStoreCapacity = 1000): Switch" href="libp2p/builders.html#newStandardSwitch%2CTransportType%2Cset%5BServerFlags%5D%2CopenArray%5BSecureProtocol%5D%2CDuration%2CDuration%2Cint%2Cint%2Cint">builders: proc newStandardSwitch(privKey = Opt.none(PrivateKey); addrs: MultiAddress |
    seq[MultiAddress] = newSeq[MultiAddress]();
                  transport: TransportType = TransportType.TCP;
                  transportFlags: set[ServerFlags] = {}; rng = newRng();
    secureManagers: openArray[SecureProtocol] = [SecureProtocol.Noise];
                  inTimeout: Duration = 5.minutes;
                  outTimeout: Duration = 5.minutes;
                  maxConnections = MaxConnections; maxIn = -1; maxOut = -1;
                  maxConnsPerPeer = MaxConnectionsPerPeer;
                  nameResolver = Opt.none(NameResolver);
                  sendSignedPeerRecord = false; peerStoreCapacity = 1000): Switch</a></li>
          </ul></dd>
<dt><a name="newStandardSwitchBuilder" href="#newStandardSwitchBuilder"><span>newStandardSwitchBuilder:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc newStandardSwitchBuilder(privKey = Opt.none(PrivateKey); addrs: MultiAddress |
    seq[MultiAddress] = newSeq[MultiAddress]();
                         transport: TransportType = TransportType.TCP;
                         transportFlags: set[ServerFlags] = {}; rng = newRng();
    secureManagers: openArray[SecureProtocol] = [SecureProtocol.Noise];
                         inTimeout: Duration = 5.minutes;
                         outTimeout: Duration = 5.minutes;
                         maxConnections = MaxConnections; maxIn = -1;
                         maxOut = -1; maxConnsPerPeer = MaxConnectionsPerPeer;
                         nameResolver = Opt.none(NameResolver);
                         sendSignedPeerRecord = false; peerStoreCapacity = 1000): SwitchBuilder" href="libp2p/builders.html#newStandardSwitchBuilder%2CTransportType%2Cset%5BServerFlags%5D%2CopenArray%5BSecureProtocol%5D%2CDuration%2CDuration%2Cint%2Cint%2Cint">builders: proc newStandardSwitchBuilder(privKey = Opt.none(PrivateKey); addrs: MultiAddress |
    seq[MultiAddress] = newSeq[MultiAddress]();
                         transport: TransportType = TransportType.TCP;
                         transportFlags: set[ServerFlags] = {}; rng = newRng();
    secureManagers: openArray[SecureProtocol] = [SecureProtocol.Noise];
                         inTimeout: Duration = 5.minutes;
                         outTimeout: Duration = 5.minutes;
                         maxConnections = MaxConnections; maxIn = -1;
                         maxOut = -1; maxConnsPerPeer = MaxConnectionsPerPeer;
                         nameResolver = Opt.none(NameResolver);
                         sendSignedPeerRecord = false; peerStoreCapacity = 1000): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="newStream" href="#newStream"><span>newStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mplex: method newStream(m: Mplex; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError, MuxerError)]" href="libp2p/muxers/mplex/mplex.html#newStream.e%2CMplex%2Cstring%2Cbool">mplex: method newStream(m: Mplex; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError, MuxerError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxer: method newStream(m: Muxer; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError, MuxerError)]" href="libp2p/muxers/muxer.html#newStream.e%2CMuxer%2Cstring%2Cbool">muxer: method newStream(m: Muxer; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError, MuxerError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method newStream(m: Yamux; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError, MuxerError)]" href="libp2p/muxers/yamux/yamux.html#newStream.e%2CYamux%2Cstring%2Cbool">yamux: method newStream(m: Yamux; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError, MuxerError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method newStream(m: QuicMuxer; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    P2PConnection, (CancelledError, LPStreamError, MuxerError)]" href="libp2p/transports/quictransport.html#newStream.e%2CQuicMuxer%2Cstring%2Cbool">quictransport: method newStream(m: QuicMuxer; name: string = &quot;&quot;; lazy: bool = false): InternalRaisesFuture[
    P2PConnection, (CancelledError, LPStreamError, MuxerError)]</a></li>
          </ul></dd>
<dt><a name="newStreamInternal" href="#newStreamInternal"><span>newStreamInternal:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mplex: proc newStreamInternal(m: Mplex; initiator: bool = true; chanId: uint64 = 0;
                  name: string = &quot;&quot;; timeout: Duration): LPChannel" href="libp2p/muxers/mplex/mplex.html#newStreamInternal%2CMplex%2Cbool%2Cuint64%2Cstring%2CDuration">mplex: proc newStreamInternal(m: Mplex; initiator: bool = true; chanId: uint64 = 0;
                  name: string = &quot;&quot;; timeout: Duration): LPChannel</a></li>
          </ul></dd>
<dt><a name="newSwitch" href="#newSwitch"><span>newSwitch:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: proc newSwitch(peerInfo: PeerInfo; transports: seq[Transport];
          secureManagers: openArray[Secure] = []; connManager: ConnManager;
          ms: MultistreamSelect; peerStore: PeerStore;
          nameResolver: NameResolver = nil; services = newSeq[Service]()): Switch" href="libp2p/switch.html#newSwitch%2CPeerInfo%2Cseq%5BTransport%5D%2CopenArray%5BSecure%5D%2CConnManager%2CMultistreamSelect%2CPeerStore%2CNameResolver">switch: proc newSwitch(peerInfo: PeerInfo; transports: seq[Transport];
          secureManagers: openArray[Secure] = []; connManager: ConnManager;
          ms: MultistreamSelect; peerStore: PeerStore;
          nameResolver: NameResolver = nil; services = newSeq[Service]()): Switch</a></li>
          </ul></dd>
<dt><a name="newTransportClosedError" href="#newTransportClosedError"><span>newTransportClosedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: proc newTransportClosedError(parent: ref Exception = nil): ref TransportError" href="libp2p/transports/transport.html#newTransportClosedError%2Cref.Exception">transport: proc newTransportClosedError(parent: ref Exception = nil): ref TransportError</a></li>
          </ul></dd>
<dt><a name="NodeEntry" href="#NodeEntry"><span>NodeEntry:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object NodeEntry" href="libp2p/protocols/kademlia/types.html#NodeEntry">types: object NodeEntry</a></li>
          </ul></dd>
<dt><a name="Noise" href="#Noise"><span>Noise:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: type Noise" href="libp2p/protocols/secure/noise.html#Noise">noise: type Noise</a></li>
          </ul></dd>
<dt><a name="NoiseCodec" href="#NoiseCodec"><span>NoiseCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: const NoiseCodec" href="libp2p/protocols/secure/noise.html#NoiseCodec">noise: const NoiseCodec</a></li>
          </ul></dd>
<dt><a name="NoiseConnection" href="#NoiseConnection"><span>NoiseConnection:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: type NoiseConnection" href="libp2p/protocols/secure/noise.html#NoiseConnection">noise: type NoiseConnection</a></li>
          </ul></dd>
<dt><a name="NoiseDecryptTagError" href="#NoiseDecryptTagError"><span>NoiseDecryptTagError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: object NoiseDecryptTagError" href="libp2p/protocols/secure/noise.html#NoiseDecryptTagError">noise: object NoiseDecryptTagError</a></li>
          </ul></dd>
<dt><a name="NoiseError" href="#NoiseError"><span>NoiseError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: object NoiseError" href="libp2p/protocols/secure/noise.html#NoiseError">noise: object NoiseError</a></li>
          </ul></dd>
<dt><a name="NoiseHandshakeError" href="#NoiseHandshakeError"><span>NoiseHandshakeError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: object NoiseHandshakeError" href="libp2p/protocols/secure/noise.html#NoiseHandshakeError">noise: object NoiseHandshakeError</a></li>
          </ul></dd>
<dt><a name="NoiseNonceMaxError" href="#NoiseNonceMaxError"><span>NoiseNonceMaxError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: object NoiseNonceMaxError" href="libp2p/protocols/secure/noise.html#NoiseNonceMaxError">noise: object NoiseNonceMaxError</a></li>
          </ul></dd>
<dt><a name="NoiseOversizedPayloadError" href="#NoiseOversizedPayloadError"><span>NoiseOversizedPayloadError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: object NoiseOversizedPayloadError" href="libp2p/protocols/secure/noise.html#NoiseOversizedPayloadError">noise: object NoiseOversizedPayloadError</a></li>
          </ul></dd>
<dt><a name="Nonce" href="#Nonce"><span>Nonce:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="api: type Nonce" href="libp2p/autotls/acme/api.html#Nonce">api: type Nonce</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: type Nonce" href="libp2p/protocols/connectivity/autonatv2/types.html#Nonce">types: type Nonce</a></li>
          </ul></dd>
<dt><a name="None" href="#None"><span>None:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MAKind.None" href="libp2p/multiaddress.html#None">multiaddress: MAKind.None</a></li>
          </ul></dd>
<dt><a name="noOpHasher" href="#noOpHasher"><span>noOpHasher:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc noOpHasher(input: seq[byte]): array[IdLength, byte]" href="libp2p/protocols/kademlia/types.html#noOpHasher%2Cseq%5Bbyte%5D">types: proc noOpHasher(input: seq[byte]): array[IdLength, byte]</a></li>
          </ul></dd>
<dt><a name="NoReservation" href="#NoReservation"><span>NoReservation:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.NoReservation" href="libp2p/protocols/connectivity/relay/messages.html#NoReservation">messages: StatusV2.NoReservation</a></li>
          </ul></dd>
<dt><a name="NotAuthorized" href="#NotAuthorized"><span>NotAuthorized:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.NotAuthorized" href="libp2p/protocols/rendezvous/protobuf.html#NotAuthorized">protobuf: ResponseStatus.NotAuthorized</a></li>
          </ul></dd>
<dt><a name="notConnected" href="#notConnected"><span>notConnected:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ConnectionType.notConnected" href="libp2p/protocols/kademlia/protobuf.html#notConnected">protobuf: ConnectionType.notConnected</a></li>
          </ul></dd>
<dt><a name="NumBytes" href="#NumBytes"><span>NumBytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type NumBytes" href="libp2p/protocols/connectivity/autonatv2/types.html#NumBytes">types: type NumBytes</a></li>
          </ul></dd>
<dt><a name="ObservedAddrManager" href="#ObservedAddrManager"><span>ObservedAddrManager:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="observedaddrmanager: type ObservedAddrManager" href="libp2p/observedaddrmanager.html#ObservedAddrManager">observedaddrmanager: type ObservedAddrManager</a></li>
          </ul></dd>
<dt><a name="OffsettedSeq" href="#OffsettedSeq"><span>OffsettedSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="offsettedseq: object OffsettedSeq" href="libp2p/utils/offsettedseq.html#OffsettedSeq">offsettedseq: object OffsettedSeq</a></li>
          </ul></dd>
<dt><a name="Ok" href="#Ok"><span>Ok:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: ResponseStatus.Ok" href="libp2p/protocols/connectivity/autonat/types.html#Ok">types: ResponseStatus.Ok</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.Ok" href="libp2p/protocols/connectivity/relay/messages.html#Ok">messages: StatusV2.Ok</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.Ok" href="libp2p/protocols/rendezvous/protobuf.html#Ok">protobuf: ResponseStatus.Ok</a></li>
          </ul></dd>
<dt><a name="oldestPeer" href="#oldestPeer"><span>oldestPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routingtable: proc oldestPeer(bucket: Bucket): (NodeEntry, int)" href="libp2p/protocols/kademlia/routingtable.html#oldestPeer%2CBucket">routingtable: proc oldestPeer(bucket: Bucket): (NodeEntry, int)</a></li>
          </ul></dd>
<dt><a name="OnEvent" href="#OnEvent"><span>OnEvent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type OnEvent" href="libp2p/protocols/pubsub/pubsubpeer.html#OnEvent">pubsubpeer: type OnEvent</a></li>
          </ul></dd>
<dt><a name="OngoingReceivesStore" href="#OngoingReceivesStore"><span>OngoingReceivesStore:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type OngoingReceivesStore" href="libp2p/protocols/pubsub/gossipsub/types.html#OngoingReceivesStore">types: type OngoingReceivesStore</a></li>
          </ul></dd>
<dt><a name="Onion3" href="#Onion3"><span>Onion3:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const Onion3" href="libp2p/multiaddress.html#Onion3">multiaddress: const Onion3</a></li>
          </ul></dd>
<dt><a name="onNewPeer" href="#onNewPeer"><span>onNewPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: method onNewPeer(g: GossipSub; peer: PubSubPeer)" href="libp2p/protocols/pubsub/gossipsub.html#onNewPeer.e%2CGossipSub%2CPubSubPeer">gossipsub: method onNewPeer(g: GossipSub; peer: PubSubPeer)</a></li>
          </ul></dd>
<dt><a name="onPubSubPeerEvent" href="#onPubSubPeerEvent"><span>onPubSubPeerEvent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: method onPubSubPeerEvent(p: GossipSub; peer: PubSubPeer; event: PubSubPeerEvent)" href="libp2p/protocols/pubsub/gossipsub.html#onPubSubPeerEvent.e%2CGossipSub%2CPubSubPeer%2CPubSubPeerEvent">gossipsub: method onPubSubPeerEvent(p: GossipSub; peer: PubSubPeer; event: PubSubPeerEvent)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method onPubSubPeerEvent(p: PubSub; peer: PubSubPeer; event: PubSubPeerEvent)" href="libp2p/protocols/pubsub/pubsub.html#onPubSubPeerEvent.e%2CPubSub%2CPubSubPeer%2CPubSubPeerEvent">pubsub: method onPubSubPeerEvent(p: PubSub; peer: PubSubPeer; event: PubSubPeerEvent)</a></li>
          </ul></dd>
<dt><a name="onTopicSubscription" href="#onTopicSubscription"><span>onTopicSubscription:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: method onTopicSubscription(g: GossipSub; topic: string; subscribed: bool)" href="libp2p/protocols/pubsub/gossipsub.html#onTopicSubscription.e%2CGossipSub%2Cstring%2Cbool">gossipsub: method onTopicSubscription(g: GossipSub; topic: string; subscribed: bool)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method onTopicSubscription(p: PubSub; topic: string; subscribed: bool)" href="libp2p/protocols/pubsub/pubsub.html#onTopicSubscription.e%2CPubSub%2Cstring%2Cbool">pubsub: method onTopicSubscription(p: PubSub; topic: string; subscribed: bool)</a></li>
          </ul></dd>
<dt><a name="open" href="#open"><span>open:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: proc open(s: LPChannel): InternalRaisesFuture[void, (CancelledError, LPStreamError)]" href="libp2p/muxers/mplex/lpchannel.html#open%2CLPChannel">lpchannel: proc open(s: LPChannel): InternalRaisesFuture[void, (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="Or" href="#Or"><span>Or:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MaPatternOp.Or" href="libp2p/multiaddress.html#Or">multiaddress: MaPatternOp.Or</a></li>
          </ul></dd>
<dt><a name="orError" href="#orError"><span>orError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: template orError(exp: untyped; err: untyped): untyped" href="libp2p/cid.html#orError.t%2Cuntyped%2Cuntyped">cid: template orError(exp: untyped; err: untyped): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: template orError(exp: untyped; err: untyped): untyped" href="libp2p/crypto/crypto.html#orError.t%2Cuntyped%2Cuntyped">crypto: template orError(exp: untyped; err: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="outbound" href="#outbound"><span>outbound:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc outbound(p: PubSubPeer): bool" href="libp2p/protocols/pubsub/pubsubpeer.html#outbound%2CPubSubPeer">pubsubpeer: proc outbound(p: PubSubPeer): bool</a></li>
          </ul></dd>
<dt><a name="outboundPeers" href="#outboundPeers"><span>outboundPeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peertable: proc outboundPeers(table: PeerTable; topic: string): int" href="libp2p/protocols/pubsub/peertable.html#outboundPeers%2CPeerTable%2Cstring">peertable: proc outboundPeers(table: PeerTable; topic: string): int</a></li>
          </ul></dd>
<dt><a name="P2pCertificate" href="#P2pCertificate"><span>P2pCertificate:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object P2pCertificate" href="libp2p/transports/tls/certificate.html#P2pCertificate">certificate: object P2pCertificate</a></li>
          </ul></dd>
<dt><a name="P2pExtension" href="#P2pExtension"><span>P2pExtension:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object P2pExtension" href="libp2p/transports/tls/certificate.html#P2pExtension">certificate: object P2pExtension</a></li>
          </ul></dd>
<dt><a name="P2PPattern" href="#P2PPattern"><span>P2PPattern:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const P2PPattern" href="libp2p/multiaddress.html#P2PPattern">multiaddress: const P2PPattern</a></li>
          </ul></dd>
<dt><a name="parse" href="#parse"><span>parse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: proc parse(certificateDer: seq[byte]): P2pCertificate" href="libp2p/transports/tls/certificate.html#parse%2Cseq%5Bbyte%5D">certificate: proc parse(certificateDer: seq[byte]): P2pCertificate</a></li>
          </ul></dd>
<dt><a name="parseCertTime" href="#parseCertTime"><span>parseCertTime:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: proc parseCertTime(certTime: string): Time" href="libp2p/transports/tls/certificate.html#parseCertTime%2Cstring">certificate: proc parseCertTime(certTime: string): Time</a></li>
          </ul></dd>
<dt><a name="parseFullAddress" href="#parseFullAddress"><span>parseFullAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: proc parseFullAddress(ma: string | seq[byte]): MaResult[(PeerId, MultiAddress)]" href="libp2p/peerinfo.html#parseFullAddress">peerinfo: proc parseFullAddress(ma: string | seq[byte]): MaResult[(PeerId, MultiAddress)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerinfo: proc parseFullAddress(ma: MultiAddress): MaResult[(PeerId, MultiAddress)]" href="libp2p/peerinfo.html#parseFullAddress%2CMultiAddress">peerinfo: proc parseFullAddress(ma: MultiAddress): MaResult[(PeerId, MultiAddress)]</a></li>
          </ul></dd>
<dt><a name="Path" href="#Path"><span>Path:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: MAKind.Path" href="libp2p/multiaddress.html#Path">multiaddress: MAKind.Path</a></li>
          </ul></dd>
<dt><a name="payload" href="#payload"><span>payload:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc payload(env: Envelope): seq[byte]" href="libp2p/signed_envelope.html#payload%2CEnvelope">signed_envelope: proc payload(env: Envelope): seq[byte]</a></li>
          </ul></dd>
<dt><a name="payloadDomain" href="#payloadDomain"><span>payloadDomain:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: proc payloadDomain(_: typedesc[Voucher]): string" href="libp2p/protocols/connectivity/relay/messages.html#payloadDomain%2Ctypedesc%5BVoucher%5D">messages: proc payloadDomain(_: typedesc[Voucher]): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routing_record: proc payloadDomain(T: typedesc[PeerRecord]): string" href="libp2p/routing_record.html#payloadDomain%2Ctypedesc%5BPeerRecord%5D">routing_record: proc payloadDomain(T: typedesc[PeerRecord]): string</a></li>
          </ul></dd>
<dt><a name="payloadType" href="#payloadType"><span>payloadType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: proc payloadType(_: typedesc[Voucher]): seq[byte]" href="libp2p/protocols/connectivity/relay/messages.html#payloadType%2Ctypedesc%5BVoucher%5D">messages: proc payloadType(_: typedesc[Voucher]): seq[byte]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="routing_record: proc payloadType(T: typedesc[PeerRecord]): seq[byte]" href="libp2p/routing_record.html#payloadType%2Ctypedesc%5BPeerRecord%5D">routing_record: proc payloadType(T: typedesc[PeerRecord]): seq[byte]</a></li>
          </ul></dd>
<dt><a name="PB" href="#PB"><span>PB:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: object PB" href="libp2p/varint.html#PB">varint: object PB</a></li>
          </ul></dd>
<dt><a name="PBSomeSVarint" href="#PBSomeSVarint"><span>PBSomeSVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type PBSomeSVarint" href="libp2p/varint.html#PBSomeSVarint">varint: type PBSomeSVarint</a></li>
          </ul></dd>
<dt><a name="PBSomeUVarint" href="#PBSomeUVarint"><span>PBSomeUVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type PBSomeUVarint" href="libp2p/varint.html#PBSomeUVarint">varint: type PBSomeUVarint</a></li>
          </ul></dd>
<dt><a name="PBSomeVarint" href="#PBSomeVarint"><span>PBSomeVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type PBSomeVarint" href="libp2p/varint.html#PBSomeVarint">varint: type PBSomeVarint</a></li>
          </ul></dd>
<dt><a name="PBZigVarint" href="#PBZigVarint"><span>PBZigVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type PBZigVarint" href="libp2p/varint.html#PBZigVarint">varint: type PBZigVarint</a></li>
          </ul></dd>
<dt><a name="peekArray" href="#peekArray"><span>peekArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc peekArray[T: char | byte](vb: var VBuffer; value: var openArray[T]): int" href="libp2p/vbuffer.html#peekArray%2CVBuffer%2CopenArray%5BT%5D">vbuffer: proc peekArray[T: char | byte](vb: var VBuffer; value: var openArray[T]): int</a></li>
          </ul></dd>
<dt><a name="peekSeq" href="#peekSeq"><span>peekSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc peekSeq[T: string | seq[byte]](vb: var VBuffer; value: var T): int" href="libp2p/vbuffer.html#peekSeq%2CVBuffer%2CT">vbuffer: proc peekSeq[T: string | seq[byte]](vb: var VBuffer; value: var T): int</a></li>
          </ul></dd>
<dt><a name="peekVarint" href="#peekVarint"><span>peekVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc peekVarint(vb: var VBuffer; value: var LPSomeUVarint): int" href="libp2p/vbuffer.html#peekVarint%2CVBuffer%2CLPSomeUVarint">vbuffer: proc peekVarint(vb: var VBuffer; value: var LPSomeUVarint): int</a></li>
          </ul></dd>
<dt><a name="Peer" href="#Peer"><span>Peer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object Peer" href="libp2p/protocols/connectivity/relay/messages.html#Peer">messages: object Peer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: object Peer" href="libp2p/protocols/kademlia/protobuf.html#Peer">protobuf: object Peer</a></li>
          </ul></dd>
<dt><a name="PeerBook" href="#PeerBook"><span>PeerBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type PeerBook" href="libp2p/peerstore.html#PeerBook">peerstore: type PeerBook</a></li>
          </ul></dd>
<dt><a name="PeerBookChangeHandler" href="#PeerBookChangeHandler"><span>PeerBookChangeHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type PeerBookChangeHandler" href="libp2p/peerstore.html#PeerBookChangeHandler">peerstore: type PeerBookChangeHandler</a></li>
          </ul></dd>
<dt><a name="PeerEvent" href="#PeerEvent"><span>PeerEvent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: object PeerEvent" href="libp2p/connmanager.html#PeerEvent">connmanager: object PeerEvent</a></li>
          </ul></dd>
<dt><a name="PeerEventHandler" href="#PeerEventHandler"><span>PeerEventHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: type PeerEventHandler" href="libp2p/connmanager.html#PeerEventHandler">connmanager: type PeerEventHandler</a></li>
          </ul></dd>
<dt><a name="PeerEventKind" href="#PeerEventKind"><span>PeerEventKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: enum PeerEventKind" href="libp2p/connmanager.html#PeerEventKind">connmanager: enum PeerEventKind</a></li>
          </ul></dd>
<dt><a name="peerExchangeList" href="#peerExchangeList"><span>peerExchangeList:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc peerExchangeList(g: GossipSub; topic: string): seq[PeerInfoMsg]" href="libp2p/protocols/pubsub/gossipsub/behavior.html#peerExchangeList%2CGossipSub%2Cstring">behavior: proc peerExchangeList(g: GossipSub; topic: string): seq[PeerInfoMsg]</a></li>
          </ul></dd>
<dt><a name="PeerId" href="#PeerId"><span>PeerId:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerid: object PeerId" href="libp2p/peerid.html#PeerId">peerid: object PeerId</a></li>
          </ul></dd>
<dt><a name="peerId" href="#peerId"><span>peerId:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: proc peerId(cert: P2pCertificate): PeerId" href="libp2p/transports/tls/certificate.html#peerId%2CP2pCertificate">certificate: proc peerId(cert: P2pCertificate): PeerId</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthAuthenticationResponse" href="#PeerIDAuthAuthenticationResponse"><span>PeerIDAuthAuthenticationResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object PeerIDAuthAuthenticationResponse" href="libp2p/peeridauth/client.html#PeerIDAuthAuthenticationResponse">client: object PeerIDAuthAuthenticationResponse</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthAuthorizationResponse" href="#PeerIDAuthAuthorizationResponse"><span>PeerIDAuthAuthorizationResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object PeerIDAuthAuthorizationResponse" href="libp2p/peeridauth/client.html#PeerIDAuthAuthorizationResponse">client: object PeerIDAuthAuthorizationResponse</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthChallenge" href="#PeerIDAuthChallenge"><span>PeerIDAuthChallenge:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type PeerIDAuthChallenge" href="libp2p/peeridauth/client.html#PeerIDAuthChallenge">client: type PeerIDAuthChallenge</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthClient" href="#PeerIDAuthClient"><span>PeerIDAuthClient:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type PeerIDAuthClient" href="libp2p/peeridauth/client.html#PeerIDAuthClient">client: type PeerIDAuthClient</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthError" href="#PeerIDAuthError"><span>PeerIDAuthError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object PeerIDAuthError" href="libp2p/peeridauth/client.html#PeerIDAuthError">client: object PeerIDAuthError</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthOpaque" href="#PeerIDAuthOpaque"><span>PeerIDAuthOpaque:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type PeerIDAuthOpaque" href="libp2p/peeridauth/client.html#PeerIDAuthOpaque">client: type PeerIDAuthOpaque</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthPrefix" href="#PeerIDAuthPrefix"><span>PeerIDAuthPrefix:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: const PeerIDAuthPrefix" href="libp2p/peeridauth/client.html#PeerIDAuthPrefix">client: const PeerIDAuthPrefix</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthResponse" href="#PeerIDAuthResponse"><span>PeerIDAuthResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object PeerIDAuthResponse" href="libp2p/peeridauth/client.html#PeerIDAuthResponse">client: object PeerIDAuthResponse</a></li>
          </ul></dd>
<dt><a name="PeerIDAuthSignature" href="#PeerIDAuthSignature"><span>PeerIDAuthSignature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type PeerIDAuthSignature" href="libp2p/peeridauth/client.html#PeerIDAuthSignature">client: type PeerIDAuthSignature</a></li>
          </ul></dd>
<dt><a name="PeerInfo" href="#PeerInfo"><span>PeerInfo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: type PeerInfo" href="libp2p/peerinfo.html#PeerInfo">peerinfo: type PeerInfo</a></li>
          </ul></dd>
<dt><a name="PeerInfoError" href="#PeerInfoError"><span>PeerInfoError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: object PeerInfoError" href="libp2p/peerinfo.html#PeerInfoError">peerinfo: object PeerInfoError</a></li>
          </ul></dd>
<dt><a name="PeerInfoMsg" href="#PeerInfoMsg"><span>PeerInfoMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object PeerInfoMsg" href="libp2p/protocols/pubsub/rpc/messages.html#PeerInfoMsg">messages: object PeerInfoMsg</a></li>
          </ul></dd>
<dt><a name="PeerMessageDecodeError" href="#PeerMessageDecodeError"><span>PeerMessageDecodeError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: object PeerMessageDecodeError" href="libp2p/protocols/pubsub/pubsub.html#PeerMessageDecodeError">pubsub: object PeerMessageDecodeError</a></li>
          </ul></dd>
<dt><a name="PeerRateLimitError" href="#PeerRateLimitError"><span>PeerRateLimitError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: object PeerRateLimitError" href="libp2p/protocols/pubsub/pubsubpeer.html#PeerRateLimitError">pubsubpeer: object PeerRateLimitError</a></li>
          </ul></dd>
<dt><a name="PeerRecord" href="#PeerRecord"><span>PeerRecord:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routing_record: object PeerRecord" href="libp2p/routing_record.html#PeerRecord">routing_record: object PeerRecord</a></li>
          </ul></dd>
<dt><a name="PeerRecordValidator" href="#PeerRecordValidator"><span>PeerRecordValidator:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: type PeerRecordValidator" href="libp2p/protocols/rendezvous/rendezvous.html#PeerRecordValidator">rendezvous: type PeerRecordValidator</a></li>
          </ul></dd>
<dt><a name="peers" href="#peers"><span>peers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peertable: proc peers(table: PeerTable; topic: string): int" href="libp2p/protocols/pubsub/peertable.html#peers%2CPeerTable%2Cstring">peertable: proc peers(table: PeerTable; topic: string): int</a></li>
          </ul></dd>
<dt><a name="PeerSet" href="#PeerSet"><span>PeerSet:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object PeerSet" href="libp2p/protocols/pubsub/gossipsub/types.html#PeerSet">types: object PeerSet</a></li>
          </ul></dd>
<dt><a name="PeerStats" href="#PeerStats"><span>PeerStats:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object PeerStats" href="libp2p/protocols/pubsub/gossipsub/types.html#PeerStats">types: object PeerStats</a></li>
          </ul></dd>
<dt><a name="PeerStore" href="#PeerStore"><span>PeerStore:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type PeerStore" href="libp2p/peerstore.html#PeerStore">peerstore: type PeerStore</a></li>
          </ul></dd>
<dt><a name="PeerTable" href="#PeerTable"><span>PeerTable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peertable: type PeerTable" href="libp2p/protocols/pubsub/peertable.html#PeerTable">peertable: type PeerTable</a></li>
          </ul></dd>
<dt><a name="PEM" href="#PEM"><span>PEM:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: EncodingFormat.PEM" href="libp2p/transports/tls/certificate.html#PEM">certificate: EncodingFormat.PEM</a></li>
          </ul></dd>
<dt><a name="PermissionDenied" href="#PermissionDenied"><span>PermissionDenied:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.PermissionDenied" href="libp2p/protocols/connectivity/relay/messages.html#PermissionDenied">messages: StatusV2.PermissionDenied</a></li>
          </ul></dd>
<dt><a name="ping" href="#ping"><span>ping:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: proc ping(kad: KadDHT; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    bool, (CancelledError, DialFailedError, ValueError, LPStreamError)]" href="libp2p/protocols/kademlia/ping.html#ping%2CKadDHT%2CPeerId%2Cseq%5BMultiAddress%5D">ping: proc ping(kad: KadDHT; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    bool, (CancelledError, DialFailedError, ValueError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: MessageType.ping" href="libp2p/protocols/kademlia/protobuf.html#ping">protobuf: MessageType.ping</a></li>
          </ul></dd>
<dt><a name="Ping" href="#Ping"><span>Ping:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: type Ping" href="libp2p/protocols/ping.html#Ping">ping: type Ping</a></li>
          </ul></dd>
<dt><a name="ping" href="#ping"><span>ping:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: proc ping(p: Ping; conn: Connection): InternalRaisesFuture[Duration,
    (CancelledError, LPStreamError, WrongPingAckError)]" href="libp2p/protocols/ping.html#ping%2CPing%2CConnection">ping: proc ping(p: Ping; conn: Connection): InternalRaisesFuture[Duration,
    (CancelledError, LPStreamError, WrongPingAckError)]</a></li>
          </ul></dd>
<dt><a name="PingCodec" href="#PingCodec"><span>PingCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: const PingCodec" href="libp2p/protocols/ping.html#PingCodec">ping: const PingCodec</a></li>
          </ul></dd>
<dt><a name="PingError" href="#PingError"><span>PingError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: object PingError" href="libp2p/protocols/ping.html#PingError">ping: object PingError</a></li>
          </ul></dd>
<dt><a name="PingHandler" href="#PingHandler"><span>PingHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: type PingHandler" href="libp2p/protocols/ping.html#PingHandler">ping: type PingHandler</a></li>
          </ul></dd>
<dt><a name="PingsPeerBudget" href="#PingsPeerBudget"><span>PingsPeerBudget:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const PingsPeerBudget" href="libp2p/protocols/pubsub/gossipsub/types.html#PingsPeerBudget">types: const PingsPeerBudget</a></li>
          </ul></dd>
<dt><a name="PKScheme" href="#PKScheme"><span>PKScheme:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: enum PKScheme" href="libp2p/crypto/crypto.html#PKScheme">crypto: enum PKScheme</a></li>
          </ul></dd>
<dt><a name="pop" href="#pop"><span>pop:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc pop(pr: ProviderRecords): ProviderRecord" href="libp2p/protocols/kademlia/provider.html#pop%2CProviderRecords">provider: proc pop(pr: ProviderRecords): ProviderRecord</a></li>
          </ul></dd>
<dt><a name="popChunkSeq" href="#popChunkSeq"><span>popChunkSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="zeroqueue: proc popChunkSeq(q: var ZeroQueue; count: int): seq[byte]" href="libp2p/utils/zeroqueue.html#popChunkSeq%2CZeroQueue%2Cint">zeroqueue: proc popChunkSeq(q: var ZeroQueue; count: int): seq[byte]</a></li>
          </ul></dd>
<dt><a name="popExpired" href="#popExpired"><span>popExpired:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="preamblestore: proc popExpired(ps: var PreambleStore; now: Moment): Option[PreambleInfo]" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#popExpired%2CPreambleStore%2CMoment">preamblestore: proc popExpired(ps: var PreambleStore; now: Moment): Option[PreambleInfo]</a></li>
          </ul></dd>
<dt><a name="possiblePeersToQuery" href="#possiblePeersToQuery"><span>possiblePeersToQuery:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="preamblestore: proc possiblePeersToQuery(preamble: PreambleInfo): seq[PeerId]" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#possiblePeersToQuery%2CPreambleInfo">preamblestore: proc possiblePeersToQuery(preamble: PreambleInfo): seq[PeerId]</a></li>
          </ul></dd>
<dt><a name="post" href="#post"><span>post:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: method post(self: PeerIDAuthClient; uri: Uri; payload: string; authHeader: string): InternalRaisesFuture[
    PeerIDAuthResponse, (HttpError, CancelledError)]" href="libp2p/peeridauth/client.html#post.e%2CPeerIDAuthClient%2CUri%2Cstring%2Cstring">client: method post(self: PeerIDAuthClient; uri: Uri; payload: string; authHeader: string): InternalRaisesFuture[
    PeerIDAuthResponse, (HttpError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="PreambleInfo" href="#PreambleInfo"><span>PreambleInfo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type PreambleInfo" href="libp2p/protocols/pubsub/gossipsub/types.html#PreambleInfo">types: type PreambleInfo</a></li>
          </ul></dd>
<dt><a name="PreamblePeerBudget" href="#PreamblePeerBudget"><span>PreamblePeerBudget:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const PreamblePeerBudget" href="libp2p/protocols/pubsub/gossipsub/types.html#PreamblePeerBudget">types: const PreamblePeerBudget</a></li>
          </ul></dd>
<dt><a name="PreambleStore" href="#PreambleStore"><span>PreambleStore:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object PreambleStore" href="libp2p/protocols/pubsub/gossipsub/types.html#PreambleStore">types: object PreambleStore</a></li>
          </ul></dd>
<dt><a name="PrivateKey" href="#PrivateKey"><span>PrivateKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: object PrivateKey" href="libp2p/crypto/crypto.html#PrivateKey">crypto: object PrivateKey</a></li>
          </ul></dd>
<dt><a name="protoAddress" href="#protoAddress"><span>protoAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc protoAddress(ma: MultiAddress): MaResult[seq[byte]]" href="libp2p/multiaddress.html#protoAddress%2CMultiAddress">multiaddress: proc protoAddress(ma: MultiAddress): MaResult[seq[byte]]</a></li>
          </ul></dd>
<dt><a name="protoArgument" href="#protoArgument"><span>protoArgument:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc protoArgument(ma: MultiAddress): MaResult[seq[byte]]" href="libp2p/multiaddress.html#protoArgument%2CMultiAddress">multiaddress: proc protoArgument(ma: MultiAddress): MaResult[seq[byte]]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc protoArgument(ma: MultiAddress; value: var openArray[byte]): MaResult[int]" href="libp2p/multiaddress.html#protoArgument%2CMultiAddress%2CopenArray%5Bbyte%5D">multiaddress: proc protoArgument(ma: MultiAddress; value: var openArray[byte]): MaResult[int]</a></li>
          </ul></dd>
<dt><a name="ProtoBook" href="#ProtoBook"><span>ProtoBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type ProtoBook" href="libp2p/peerstore.html#ProtoBook">peerstore: type ProtoBook</a></li>
          </ul></dd>
<dt><a name="ProtoBuffer" href="#ProtoBuffer"><span>ProtoBuffer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: object ProtoBuffer" href="libp2p/protobuf/minprotobuf.html#ProtoBuffer">minprotobuf: object ProtoBuffer</a></li>
          </ul></dd>
<dt><a name="protoCode" href="#protoCode"><span>protoCode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc protoCode(ma: MultiAddress): MaResult[MultiCodec]" href="libp2p/multiaddress.html#protoCode%2CMultiAddress">multiaddress: proc protoCode(ma: MultiAddress): MaResult[MultiCodec]</a></li>
          </ul></dd>
<dt><a name="protocols" href="#protocols"><span>protocols:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc protocols(value: MultiAddress): MaResult[seq[MultiCodec]]" href="libp2p/multiaddress.html#protocols%2CMultiAddress">multiaddress: proc protocols(value: MultiAddress): MaResult[seq[MultiCodec]]</a></li>
          </ul></dd>
<dt><a name="ProtoError" href="#ProtoError"><span>ProtoError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: enum ProtoError" href="libp2p/protobuf/minprotobuf.html#ProtoError">minprotobuf: enum ProtoError</a></li>
          </ul></dd>
<dt><a name="ProtoField" href="#ProtoField"><span>ProtoField:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: object ProtoField" href="libp2p/protobuf/minprotobuf.html#ProtoField">minprotobuf: object ProtoField</a></li>
          </ul></dd>
<dt><a name="ProtoFieldKind" href="#ProtoFieldKind"><span>ProtoFieldKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: enum ProtoFieldKind" href="libp2p/protobuf/minprotobuf.html#ProtoFieldKind">minprotobuf: enum ProtoFieldKind</a></li>
          </ul></dd>
<dt><a name="ProtoFlags" href="#ProtoFlags"><span>ProtoFlags:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: enum ProtoFlags" href="libp2p/protobuf/minprotobuf.html#ProtoFlags">minprotobuf: enum ProtoFlags</a></li>
          </ul></dd>
<dt><a name="ProtoHeader" href="#ProtoHeader"><span>ProtoHeader:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: object ProtoHeader" href="libp2p/protobuf/minprotobuf.html#ProtoHeader">minprotobuf: object ProtoHeader</a></li>
          </ul></dd>
<dt><a name="protoName" href="#protoName"><span>protoName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc protoName(ma: MultiAddress): MaResult[string]" href="libp2p/multiaddress.html#protoName%2CMultiAddress">multiaddress: proc protoName(ma: MultiAddress): MaResult[string]</a></li>
          </ul></dd>
<dt><a name="ProtoResult" href="#ProtoResult"><span>ProtoResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: type ProtoResult" href="libp2p/protobuf/minprotobuf.html#ProtoResult">minprotobuf: type ProtoResult</a></li>
          </ul></dd>
<dt><a name="ProtoScalar" href="#ProtoScalar"><span>ProtoScalar:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: type ProtoScalar" href="libp2p/protobuf/minprotobuf.html#ProtoScalar">minprotobuf: type ProtoScalar</a></li>
          </ul></dd>
<dt><a name="ProtoVersion" href="#ProtoVersion"><span>ProtoVersion:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: const ProtoVersion" href="libp2p/protocols/identify.html#ProtoVersion">identify: const ProtoVersion</a></li>
          </ul></dd>
<dt><a name="ProtoVersionBook" href="#ProtoVersionBook"><span>ProtoVersionBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type ProtoVersionBook" href="libp2p/peerstore.html#ProtoVersionBook">peerstore: type ProtoVersionBook</a></li>
          </ul></dd>
<dt><a name="ProvidedKeys" href="#ProvidedKeys"><span>ProvidedKeys:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type ProvidedKeys" href="libp2p/protocols/kademlia/types.html#ProvidedKeys">types: type ProvidedKeys</a></li>
          </ul></dd>
<dt><a name="Provider" href="#Provider"><span>Provider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type Provider" href="libp2p/protocols/kademlia/types.html#Provider">types: type Provider</a></li>
          </ul></dd>
<dt><a name="ProviderManager" href="#ProviderManager"><span>ProviderManager:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type ProviderManager" href="libp2p/protocols/kademlia/types.html#ProviderManager">types: type ProviderManager</a></li>
          </ul></dd>
<dt><a name="ProviderRecord" href="#ProviderRecord"><span>ProviderRecord:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object ProviderRecord" href="libp2p/protocols/kademlia/types.html#ProviderRecord">types: object ProviderRecord</a></li>
          </ul></dd>
<dt><a name="ProviderRecords" href="#ProviderRecords"><span>ProviderRecords:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type ProviderRecords" href="libp2p/protocols/kademlia/types.html#ProviderRecords">types: type ProviderRecords</a></li>
          </ul></dd>
<dt><a name="pruned" href="#pruned"><span>pruned:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc pruned(g: GossipSub; p: PubSubPeer; topic: string; setBackoff: bool = true;
       backoff = none(Duration))" href="libp2p/protocols/pubsub/gossipsub/behavior.html#pruned%2CGossipSub%2CPubSubPeer%2Cstring%2Cbool">behavior: proc pruned(g: GossipSub; p: PubSubPeer; topic: string; setBackoff: bool = true;
       backoff = none(Duration))</a></li>
          </ul></dd>
<dt><a name="pubkey" href="#pubkey"><span>pubkey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: proc pubkey(pair: RsaKeyPair): RsaPublicKey" href="libp2p/crypto/rsa.html#pubkey%2CRsaKeyPair">rsa: proc pubkey(pair: RsaKeyPair): RsaPublicKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: template pubkey(v: SkKeyPair): SkPublicKey" href="libp2p/crypto/secp.html#pubkey.t%2CSkKeyPair">secp: template pubkey(v: SkKeyPair): SkPublicKey</a></li>
          </ul></dd>
<dt><a name="PubKey256Length" href="#PubKey256Length"><span>PubKey256Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const PubKey256Length" href="libp2p/crypto/ecnist.html#PubKey256Length">ecnist: const PubKey256Length</a></li>
          </ul></dd>
<dt><a name="PubKey384Length" href="#PubKey384Length"><span>PubKey384Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const PubKey384Length" href="libp2p/crypto/ecnist.html#PubKey384Length">ecnist: const PubKey384Length</a></li>
          </ul></dd>
<dt><a name="PubKey521Length" href="#PubKey521Length"><span>PubKey521Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const PubKey521Length" href="libp2p/crypto/ecnist.html#PubKey521Length">ecnist: const PubKey521Length</a></li>
          </ul></dd>
<dt><a name="pubkeyBytes" href="#pubkeyBytes"><span>pubkeyBytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc pubkeyBytes(pubkey: PublicKey): seq[byte]" href="libp2p/peeridauth/client.html#pubkeyBytes%2CPublicKey">client: proc pubkeyBytes(pubkey: PublicKey): seq[byte]</a></li>
          </ul></dd>
<dt><a name="public" href="#public"><span>public:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="curve25519: proc public(private: Curve25519Key): Curve25519Key" href="libp2p/crypto/curve25519.html#public%2CCurve25519Key">curve25519: proc public(private: Curve25519Key): Curve25519Key</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utility: template public()" href="libp2p/utility.html#public.t">utility: template public()</a></li>
          </ul></dd>
<dt><a name="PublicKey" href="#PublicKey"><span>PublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: object PublicKey" href="libp2p/crypto/crypto.html#PublicKey">crypto: object PublicKey</a></li>
          </ul></dd>
<dt><a name="publicKey" href="#publicKey"><span>publicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: proc publicKey(cert: P2pCertificate): PublicKey" href="libp2p/transports/tls/certificate.html#publicKey%2CP2pCertificate">certificate: proc publicKey(cert: P2pCertificate): PublicKey</a></li>
          </ul></dd>
<dt><a name="publish" href="#publish"><span>publish:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: method publish(f: FloodSub; topic: string; data: seq[byte];
        publishParams: Option[PublishParams] = none(PublishParams)): InternalRaisesFuture[
    int, void]" href="libp2p/protocols/pubsub/floodsub.html#publish.e%2CFloodSub%2Cstring%2Cseq%5Bbyte%5D%2COption%5BPublishParams%5D">floodsub: method publish(f: FloodSub; topic: string; data: seq[byte];
        publishParams: Option[PublishParams] = none(PublishParams)): InternalRaisesFuture[
    int, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: method publish(g: GossipSub; topic: string; data: seq[byte];
        publishParams: Option[PublishParams] = none(PublishParams)): InternalRaisesFuture[
    int, void]" href="libp2p/protocols/pubsub/gossipsub.html#publish.e%2CGossipSub%2Cstring%2Cseq%5Bbyte%5D%2COption%5BPublishParams%5D">gossipsub: method publish(g: GossipSub; topic: string; data: seq[byte];
        publishParams: Option[PublishParams] = none(PublishParams)): InternalRaisesFuture[
    int, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method publish(p: PubSub; topic: string; data: seq[byte];
        publishParams: Option[PublishParams] = none(PublishParams)): InternalRaisesFuture[
    int, void]" href="libp2p/protocols/pubsub/pubsub.html#publish.e%2CPubSub%2Cstring%2Cseq%5Bbyte%5D%2COption%5BPublishParams%5D">pubsub: method publish(p: PubSub; topic: string; data: seq[byte];
        publishParams: Option[PublishParams] = none(PublishParams)): InternalRaisesFuture[
    int, void]</a></li>
          </ul></dd>
<dt><a name="PublishParams" href="#PublishParams"><span>PublishParams:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: object PublishParams" href="libp2p/protocols/pubsub/pubsub.html#PublishParams">pubsub: object PublishParams</a></li>
          </ul></dd>
<dt><a name="PubSub" href="#PubSub"><span>PubSub:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type PubSub" href="libp2p/protocols/pubsub/pubsub.html#PubSub">pubsub: type PubSub</a></li>
          </ul></dd>
<dt><a name="PubSubObserver" href="#PubSubObserver"><span>PubSubObserver:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type PubSubObserver" href="libp2p/protocols/pubsub/pubsubpeer.html#PubSubObserver">pubsubpeer: type PubSubObserver</a></li>
          </ul></dd>
<dt><a name="PubSubPeer" href="#PubSubPeer"><span>PubSubPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type PubSubPeer" href="libp2p/protocols/pubsub/pubsubpeer.html#PubSubPeer">pubsubpeer: type PubSubPeer</a></li>
          </ul></dd>
<dt><a name="PubSubPeerEvent" href="#PubSubPeerEvent"><span>PubSubPeerEvent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: object PubSubPeerEvent" href="libp2p/protocols/pubsub/pubsubpeer.html#PubSubPeerEvent">pubsubpeer: object PubSubPeerEvent</a></li>
          </ul></dd>
<dt><a name="PubSubPeerEventKind" href="#PubSubPeerEventKind"><span>PubSubPeerEventKind:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: enum PubSubPeerEventKind" href="libp2p/protocols/pubsub/pubsubpeer.html#PubSubPeerEventKind">pubsubpeer: enum PubSubPeerEventKind</a></li>
          </ul></dd>
<dt><a name="PullOperation" href="#PullOperation"><span>PullOperation:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: const PullOperation" href="libp2p/protocols/pubsub/gossipsub/types.html#PullOperation">types: const PullOperation</a></li>
          </ul></dd>
<dt><a name="punishInvalidMessage" href="#punishInvalidMessage"><span>punishInvalidMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc punishInvalidMessage(g: GossipSub; peer: PubSubPeer; msg: Message): InternalRaisesFuture[
    void, (PeerRateLimitError,)]" href="libp2p/protocols/pubsub/gossipsub/scoring.html#punishInvalidMessage%2CGossipSub%2CPubSubPeer%2CMessage">scoring: proc punishInvalidMessage(g: GossipSub; peer: PubSubPeer; msg: Message): InternalRaisesFuture[
    void, (PeerRateLimitError,)]</a></li>
          </ul></dd>
<dt><a name="push" href="#push"><span>push:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="identify: proc push(p: IdentifyPush; peerInfo: PeerInfo; conn: Connection): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]" href="libp2p/protocols/identify.html#push%2CIdentifyPush%2CPeerInfo%2CConnection">identify: proc push(p: IdentifyPush; peerInfo: PeerInfo; conn: Connection): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="provider: proc push(pr: ProviderRecords; record: ProviderRecord)" href="libp2p/protocols/kademlia/provider.html#push%2CProviderRecords%2CProviderRecord">provider: proc push(pr: ProviderRecords; record: ProviderRecord)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="zeroqueue: proc push(q: var ZeroQueue; b: sink seq[byte])" href="libp2p/utils/zeroqueue.html#push%2CZeroQueue%2Csinkseq%5Bbyte%5D">zeroqueue: proc push(q: var ZeroQueue; b: sink seq[byte])</a></li>
          </ul></dd>
<dt><a name="pushData" href="#pushData"><span>pushData:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bufferstream: method pushData(s: BufferStream; data: sink seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/bufferstream.html#pushData.e%2CBufferStream%2Csinkseq%5Bbyte%5D">bufferstream: method pushData(s: BufferStream; data: sink seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="pushEof" href="#pushEof"><span>pushEof:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bufferstream: method pushEof(s: BufferStream): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/bufferstream.html#pushEof.e%2CBufferStream">bufferstream: method pushEof(s: BufferStream): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="put" href="#put"><span>put:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mcache: proc put(c: var MCache; msgId: MessageId; msg: Message)" href="libp2p/protocols/pubsub/mcache.html#put%2CMCache%2CMessageId%2CMessage">mcache: proc put(c: var MCache; msgId: MessageId; msg: Message)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="timedcache: proc put[K](t: var TimedCache[K]; k: K; now = Moment.now()): bool" href="libp2p/protocols/pubsub/timedcache.html#put%2CTimedCache%5BK%5D%2CK">timedcache: proc put[K](t: var TimedCache[K]; k: K; now = Moment.now()): bool</a></li>
          </ul></dd>
<dt><a name="putSVarint" href="#putSVarint"><span>putSVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: proc putSVarint(pbytes: var openArray[byte]; outsize: var int;
           outval: (PBZigVarint | PBSomeSVarint)): VarintResult[void]" href="libp2p/varint.html#putSVarint%2CopenArray%5Bbyte%5D%2Cint%2C">varint: proc putSVarint(pbytes: var openArray[byte]; outsize: var int;
           outval: (PBZigVarint | PBSomeSVarint)): VarintResult[void]</a></li>
          </ul></dd>
<dt><a name="putUVarint" href="#putUVarint"><span>putUVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: proc putUVarint[T: PB | LP](vtype: typedesc[T]; pbytes: var openArray[byte];
                       outlen: var int; outval: SomeUVarint): VarintResult[void]" href="libp2p/varint.html#putUVarint%2Ctypedesc%5BT%5D%2CopenArray%5Bbyte%5D%2Cint%2CSomeUVarint">varint: proc putUVarint[T: PB | LP](vtype: typedesc[T]; pbytes: var openArray[byte];
                       outlen: var int; outval: SomeUVarint): VarintResult[void]</a></li>
          </ul></dd>
<dt><a name="putValue" href="#putValue"><span>putValue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: MessageType.putValue" href="libp2p/protocols/kademlia/protobuf.html#putValue">protobuf: MessageType.putValue</a></li>
          <li><a class="reference external"
          data-doc-search-tag="put: proc putValue(kad: KadDHT; key: Key; value: seq[byte]): InternalRaisesFuture[
    Result[void, string], (CancelledError,)]" href="libp2p/protocols/kademlia/put.html#putValue%2CKadDHT%2CKey%2Cseq%5Bbyte%5D">put: proc putValue(kad: KadDHT; key: Key; value: seq[byte]): InternalRaisesFuture[
    Result[void, string], (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="putVarint" href="#putVarint"><span>putVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: proc putVarint[T: PB | LP](vtype: typedesc[T]; pbytes: var openArray[byte];
                      nbytes: var int; value: SomeVarint): VarintResult[void]" href="libp2p/varint.html#putVarint%2Ctypedesc%5BT%5D%2CopenArray%5Bbyte%5D%2Cint%2CSomeVarint">varint: proc putVarint[T: PB | LP](vtype: typedesc[T]; pbytes: var openArray[byte];
                      nbytes: var int; value: SomeVarint): VarintResult[void]</a></li>
          </ul></dd>
<dt><a name="QUIC" href="#QUIC"><span>QUIC:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const QUIC" href="libp2p/multiaddress.html#QUIC">multiaddress: const QUIC</a></li>
          </ul></dd>
<dt><a name="QUIC_DNS" href="#QUIC_DNS"><span>QUIC_DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const QUIC_DNS" href="libp2p/multiaddress.html#QUIC_DNS">multiaddress: const QUIC_DNS</a></li>
          </ul></dd>
<dt><a name="QUIC_IP" href="#QUIC_IP"><span>QUIC_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const QUIC_IP" href="libp2p/multiaddress.html#QUIC_IP">multiaddress: const QUIC_IP</a></li>
          </ul></dd>
<dt><a name="QuicMuxer" href="#QuicMuxer"><span>QuicMuxer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: type QuicMuxer" href="libp2p/transports/quictransport.html#QuicMuxer">quictransport: type QuicMuxer</a></li>
          </ul></dd>
<dt><a name="QuicSession" href="#QuicSession"><span>QuicSession:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: type QuicSession" href="libp2p/transports/quictransport.html#QuicSession">quictransport: type QuicSession</a></li>
          </ul></dd>
<dt><a name="QuicStream" href="#QuicStream"><span>QuicStream:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: type QuicStream" href="libp2p/transports/quictransport.html#QuicStream">quictransport: type QuicStream</a></li>
          </ul></dd>
<dt><a name="QuicTransport" href="#QuicTransport"><span>QuicTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: type QuicTransport" href="libp2p/transports/quictransport.html#QuicTransport">quictransport: type QuicTransport</a></li>
          </ul></dd>
<dt><a name="QuicTransportAcceptStopped" href="#QuicTransportAcceptStopped"><span>QuicTransportAcceptStopped:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: object QuicTransportAcceptStopped" href="libp2p/transports/quictransport.html#QuicTransportAcceptStopped">quictransport: object QuicTransportAcceptStopped</a></li>
          </ul></dd>
<dt><a name="QuicTransportDialError" href="#QuicTransportDialError"><span>QuicTransportDialError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: object QuicTransportDialError" href="libp2p/transports/quictransport.html#QuicTransportDialError">quictransport: object QuicTransportDialError</a></li>
          </ul></dd>
<dt><a name="QuicTransportError" href="#QuicTransportError"><span>QuicTransportError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: object QuicTransportError" href="libp2p/transports/quictransport.html#QuicTransportError">quictransport: object QuicTransportError</a></li>
          </ul></dd>
<dt><a name="QUIC_V1" href="#QUIC_V1"><span>QUIC_V1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const QUIC_V1" href="libp2p/multiaddress.html#QUIC_V1">multiaddress: const QUIC_V1</a></li>
          </ul></dd>
<dt><a name="QUIC_V1_DNS" href="#QUIC_V1_DNS"><span>QUIC_V1_DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const QUIC_V1_DNS" href="libp2p/multiaddress.html#QUIC_V1_DNS">multiaddress: const QUIC_V1_DNS</a></li>
          </ul></dd>
<dt><a name="QUIC_V1_IP" href="#QUIC_V1_IP"><span>QUIC_V1_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const QUIC_V1_IP" href="libp2p/multiaddress.html#QUIC_V1_IP">multiaddress: const QUIC_V1_IP</a></li>
          </ul></dd>
<dt><a name="random" href="#random"><span>random:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc random(T: typedesc[KeyPair]; rng: var HmacDrbgContext; bits = RsaDefaultKeySize): CryptoResult[
    KeyPair]" href="libp2p/crypto/crypto.html#random%2Ctypedesc%5BKeyPair%5D%2CHmacDrbgContext">crypto: proc random(T: typedesc[KeyPair]; rng: var HmacDrbgContext; bits = RsaDefaultKeySize): CryptoResult[
    KeyPair]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc random(T: typedesc[KeyPair]; scheme: PKScheme; rng: var HmacDrbgContext;
       bits = RsaDefaultKeySize): CryptoResult[KeyPair]" href="libp2p/crypto/crypto.html#random%2Ctypedesc%5BKeyPair%5D%2CPKScheme%2CHmacDrbgContext">crypto: proc random(T: typedesc[KeyPair]; scheme: PKScheme; rng: var HmacDrbgContext;
       bits = RsaDefaultKeySize): CryptoResult[KeyPair]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc random(T: typedesc[PrivateKey]; rng: var HmacDrbgContext;
       bits = RsaDefaultKeySize): CryptoResult[PrivateKey]" href="libp2p/crypto/crypto.html#random%2Ctypedesc%5BPrivateKey%5D%2CHmacDrbgContext">crypto: proc random(T: typedesc[PrivateKey]; rng: var HmacDrbgContext;
       bits = RsaDefaultKeySize): CryptoResult[PrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc random(T: typedesc[PrivateKey]; scheme: PKScheme; rng: var HmacDrbgContext;
       bits = RsaDefaultKeySize): CryptoResult[PrivateKey]" href="libp2p/crypto/crypto.html#random%2Ctypedesc%5BPrivateKey%5D%2CPKScheme%2CHmacDrbgContext">crypto: proc random(T: typedesc[PrivateKey]; scheme: PKScheme; rng: var HmacDrbgContext;
       bits = RsaDefaultKeySize): CryptoResult[PrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="curve25519: proc random(_: type[Curve25519Key]; rng: var HmacDrbgContext): Curve25519Key" href="libp2p/crypto/curve25519.html#random%2Ctype%5BCurve25519Key%5D%2CHmacDrbgContext">curve25519: proc random(_: type[Curve25519Key]; rng: var HmacDrbgContext): Curve25519Key</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc random(T: typedesc[EcKeyPair]; kind: EcCurveKind; rng: var HmacDrbgContext): EcResult[
    T]" href="libp2p/crypto/ecnist.html#random%2Ctypedesc%5BEcKeyPair%5D%2CEcCurveKind%2CHmacDrbgContext">ecnist: proc random(T: typedesc[EcKeyPair]; kind: EcCurveKind; rng: var HmacDrbgContext): EcResult[
    T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc random(T: typedesc[EcPrivateKey]; kind: EcCurveKind; rng: var HmacDrbgContext): EcResult[
    EcPrivateKey]" href="libp2p/crypto/ecnist.html#random%2Ctypedesc%5BEcPrivateKey%5D%2CEcCurveKind%2CHmacDrbgContext">ecnist: proc random(T: typedesc[EcPrivateKey]; kind: EcCurveKind; rng: var HmacDrbgContext): EcResult[
    EcPrivateKey]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc random(t: typedesc[EdKeyPair]; rng: var HmacDrbgContext): EdKeyPair" href="libp2p/crypto/ed25519/ed25519.html#random%2Ctypedesc%5BEdKeyPair%5D%2CHmacDrbgContext">ed25519: proc random(t: typedesc[EdKeyPair]; rng: var HmacDrbgContext): EdKeyPair</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc random(t: typedesc[EdPrivateKey]; rng: var HmacDrbgContext): EdPrivateKey" href="libp2p/crypto/ed25519/ed25519.html#random%2Ctypedesc%5BEdPrivateKey%5D%2CHmacDrbgContext">ed25519: proc random(t: typedesc[EdPrivateKey]; rng: var HmacDrbgContext): EdPrivateKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc random[T: RsaKP](t: typedesc[T]; rng: var HmacDrbgContext;
                 bits = DefaultKeySize; pubexp = DefaultPublicExponent): RsaResult[
    T]" href="libp2p/crypto/rsa.html#random%2Ctypedesc%5BT%5D%2CHmacDrbgContext">rsa: proc random[T: RsaKP](t: typedesc[T]; rng: var HmacDrbgContext;
                 bits = DefaultKeySize; pubexp = DefaultPublicExponent): RsaResult[
    T]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc random(t: typedesc[SkKeyPair]; rng: var HmacDrbgContext): SkKeyPair" href="libp2p/crypto/secp.html#random%2Ctypedesc%5BSkKeyPair%5D%2CHmacDrbgContext">secp: proc random(t: typedesc[SkKeyPair]; rng: var HmacDrbgContext): SkKeyPair</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc random(t: typedesc[SkPrivateKey]; rng: var HmacDrbgContext): SkPrivateKey" href="libp2p/crypto/secp.html#random%2Ctypedesc%5BSkPrivateKey%5D%2CHmacDrbgContext">secp: proc random(t: typedesc[SkPrivateKey]; rng: var HmacDrbgContext): SkPrivateKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc random(t: typedesc[PeerId]; rng = newRng()): Result[PeerId, cstring]" href="libp2p/peerid.html#random%2Ctypedesc%5BPeerId%5D">peerid: proc random(t: typedesc[PeerId]; rng = newRng()): Result[PeerId, cstring]</a></li>
          </ul></dd>
<dt><a name="randomKeyInBucketRange" href="#randomKeyInBucketRange"><span>randomKeyInBucketRange:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routingtable: proc randomKeyInBucketRange(selfId: Key; bucketIndex: int; rng: ref HmacDrbgContext): Key" href="libp2p/protocols/kademlia/routingtable.html#randomKeyInBucketRange%2CKey%2Cint%2Cref.HmacDrbgContext">routingtable: proc randomKeyInBucketRange(selfId: Key; bucketIndex: int; rng: ref HmacDrbgContext): Key</a></li>
          </ul></dd>
<dt><a name="rateLimit" href="#rateLimit"><span>rateLimit:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: proc rateLimit(g: GossipSub; peer: PubSubPeer; overhead: int): InternalRaisesFuture[
    void, (PeerRateLimitError,)]" href="libp2p/protocols/pubsub/gossipsub.html#rateLimit%2CGossipSub%2CPubSubPeer%2Cint">gossipsub: proc rateLimit(g: GossipSub; peer: PubSubPeer; overhead: int): InternalRaisesFuture[
    void, (PeerRateLimitError,)]</a></li>
          </ul></dd>
<dt><a name="read" href="#read"><span>read:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: proc read(ab: var Asn1Buffer): Asn1Result[Asn1Field]" href="libp2p/crypto/minasn1.html#read%2CAsn1Buffer">minasn1: proc read(ab: var Asn1Buffer): Asn1Result[Asn1Field]</a></li>
          </ul></dd>
<dt><a name="readArray" href="#readArray"><span>readArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc readArray[T: char | byte](vb: var VBuffer; value: var openArray[T]): int" href="libp2p/vbuffer.html#readArray%2CVBuffer%2CopenArray%5BT%5D">vbuffer: proc readArray[T: char | byte](vb: var VBuffer; value: var openArray[T]): int</a></li>
          </ul></dd>
<dt><a name="readExactly" href="#readExactly"><span>readExactly:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: method readExactly(s: LPStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#readExactly.e%2CLPStream%2Cpointer%2Cint">lpstream: method readExactly(s: LPStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="readLine" href="#readLine"><span>readLine:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: method readLine(s: LPStream; limit = 0; sep = &quot;\r
&quot;): InternalRaisesFuture[string,
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#readLine.e%2CLPStream%2Cint%2Cstring">lpstream: method readLine(s: LPStream; limit = 0; sep = &quot;\r
&quot;): InternalRaisesFuture[string,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="readLp" href="#readLp"><span>readLp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: method readLp(s: LPStream; maxSize: int): InternalRaisesFuture[seq[byte],
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#readLp.e%2CLPStream%2Cint">lpstream: method readLp(s: LPStream; maxSize: int): InternalRaisesFuture[seq[byte],
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="readMessage" href="#readMessage"><span>readMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="noise: method readMessage(sconn: NoiseConnection): InternalRaisesFuture[seq[byte],
    (CancelledError, LPStreamError)]" href="libp2p/protocols/secure/noise.html#readMessage.e%2CNoiseConnection">noise: method readMessage(sconn: NoiseConnection): InternalRaisesFuture[seq[byte],
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: method readMessage(c: SecureConn): InternalRaisesFuture[seq[byte],
    (CancelledError, LPStreamError)]" href="libp2p/protocols/secure/secure.html#readMessage.e%2CSecureConn">secure: method readMessage(c: SecureConn): InternalRaisesFuture[seq[byte],
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="readMsg" href="#readMsg"><span>readMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="coder: proc readMsg(conn: Connection): InternalRaisesFuture[Msg,
    (CancelledError, LPStreamError, MuxerError)]" href="libp2p/muxers/mplex/coder.html#readMsg%2CConnection">coder: proc readMsg(conn: Connection): InternalRaisesFuture[Msg,
    (CancelledError, LPStreamError, MuxerError)]</a></li>
          </ul></dd>
<dt><a name="readOnce" href="#readOnce"><span>readOnce:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: method readOnce(s: LPChannel; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]" href="libp2p/muxers/mplex/lpchannel.html#readOnce.e%2CLPChannel%2Cpointer%2Cint">lpchannel: method readOnce(s: LPChannel; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method readOnce(channel: YamuxChannel; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]" href="libp2p/muxers/yamux/yamux.html#readOnce.e%2CYamuxChannel%2Cpointer%2Cint">yamux: method readOnce(channel: YamuxChannel; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rconn: method readOnce(self: RelayConnection; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]" href="libp2p/protocols/connectivity/relay/rconn.html#readOnce.e%2CRelayConnection%2Cpointer%2Cint">rconn: method readOnce(self: RelayConnection; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: method readOnce(s: SecureConn; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/secure/secure.html#readOnce.e%2CSecureConn%2Cpointer%2Cint">secure: method readOnce(s: SecureConn; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bufferstream: method readOnce(s: BufferStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]" href="libp2p/stream/bufferstream.html#readOnce.e%2CBufferStream%2Cpointer%2Cint">bufferstream: method readOnce(s: BufferStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method readOnce(s: ChronosStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]" href="libp2p/stream/chronosstream.html#readOnce.e%2CChronosStream%2Cpointer%2Cint">chronosstream: method readOnce(s: ChronosStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method readOnce(s: LPStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#readOnce.e%2CLPStream%2Cpointer%2Cint">lpstream: method readOnce(s: LPStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method readOnce(stream: QuicStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]" href="libp2p/transports/quictransport.html#readOnce.e%2CQuicStream%2Cpointer%2Cint">quictransport: method readOnce(stream: QuicStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[
    int, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method readOnce(s: WsStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]" href="libp2p/transports/wstransport.html#readOnce.e%2CWsStream%2Cpointer%2Cint">wstransport: method readOnce(s: WsStream; pbytes: pointer; nbytes: int): InternalRaisesFuture[int,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="readSeq" href="#readSeq"><span>readSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc readSeq[T: string | seq[byte]](vb: var VBuffer; value: var T): int" href="libp2p/vbuffer.html#readSeq%2CVBuffer%2CT">vbuffer: proc readSeq[T: string | seq[byte]](vb: var VBuffer; value: var T): int</a></li>
          </ul></dd>
<dt><a name="readVarint" href="#readVarint"><span>readVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: method readVarint(conn: LPStream): InternalRaisesFuture[uint64,
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#readVarint.e%2CLPStream">lpstream: method readVarint(conn: LPStream): InternalRaisesFuture[uint64,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="vbuffer: proc readVarint(vb: var VBuffer; value: var LPSomeUVarint): int" href="libp2p/vbuffer.html#readVarint%2CVBuffer%2CLPSomeUVarint">vbuffer: proc readVarint(vb: var VBuffer; value: var LPSomeUVarint): int</a></li>
          </ul></dd>
<dt><a name="rebalanceMesh" href="#rebalanceMesh"><span>rebalanceMesh:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc rebalanceMesh(g: GossipSub; topic: string; metrics: ptr MeshMetrics = nil)" href="libp2p/protocols/pubsub/gossipsub/behavior.html#rebalanceMesh%2CGossipSub%2Cstring%2Cptr.MeshMetrics">behavior: proc rebalanceMesh(g: GossipSub; topic: string; metrics: ptr MeshMetrics = nil)</a></li>
          </ul></dd>
<dt><a name="ReceivedTable" href="#ReceivedTable"><span>ReceivedTable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type ReceivedTable" href="libp2p/protocols/kademlia/types.html#ReceivedTable">types: type ReceivedTable</a></li>
          </ul></dd>
<dt><a name="Record" href="#Record"><span>Record:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object Record" href="libp2p/protocols/kademlia/protobuf.html#Record">protobuf: object Record</a></li>
          </ul></dd>
<dt><a name="recvObservers" href="#recvObservers"><span>recvObservers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc recvObservers(p: PubSubPeer; msg: var RPCMsg)" href="libp2p/protocols/pubsub/pubsubpeer.html#recvObservers%2CPubSubPeer%2CRPCMsg">pubsubpeer: proc recvObservers(p: PubSubPeer; msg: var RPCMsg)</a></li>
          </ul></dd>
<dt><a name="Register" href="#Register"><span>Register:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object Register" href="libp2p/protocols/rendezvous/protobuf.html#Register">protobuf: object Register</a></li>
          </ul></dd>
<dt><a name="register" href="#register"><span>register:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc register[E](rdv: GenericRendezVous[E]; conn: Connection; r: Register;
            peerRecord: E): Future[void]" href="libp2p/protocols/rendezvous/rendezvous.html#register%2CGenericRendezVous%5BE%5D%2CConnection%2CRegister%2CE">rendezvous: proc register[E](rdv: GenericRendezVous[E]; conn: Connection; r: Register;
            peerRecord: E): Future[void]</a></li>
          </ul></dd>
<dt><a name="RegisteredData" href="#RegisteredData"><span>RegisteredData:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: object RegisteredData" href="libp2p/protocols/rendezvous/rendezvous.html#RegisteredData">rendezvous: object RegisteredData</a></li>
          </ul></dd>
<dt><a name="RegisterResponse" href="#RegisterResponse"><span>RegisterResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object RegisterResponse" href="libp2p/protocols/rendezvous/protobuf.html#RegisterResponse">protobuf: object RegisterResponse</a></li>
          </ul></dd>
<dt><a name="RegistrationLimitPerPeer" href="#RegistrationLimitPerPeer"><span>RegistrationLimitPerPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: const RegistrationLimitPerPeer" href="libp2p/protocols/rendezvous/rendezvous.html#RegistrationLimitPerPeer">rendezvous: const RegistrationLimitPerPeer</a></li>
          </ul></dd>
<dt><a name="Relay" href="#Relay"><span>Relay:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: type Relay" href="libp2p/protocols/connectivity/relay/relay.html#Relay">relay: type Relay</a></li>
          </ul></dd>
<dt><a name="RelayClient" href="#RelayClient"><span>RelayClient:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type RelayClient" href="libp2p/protocols/connectivity/relay/client.html#RelayClient">client: type RelayClient</a></li>
          </ul></dd>
<dt><a name="RelayClientAddConn" href="#RelayClientAddConn"><span>RelayClientAddConn:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: type RelayClientAddConn" href="libp2p/protocols/connectivity/relay/client.html#RelayClientAddConn">client: type RelayClientAddConn</a></li>
          </ul></dd>
<dt><a name="RelayClientError" href="#RelayClientError"><span>RelayClientError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object RelayClientError" href="libp2p/protocols/connectivity/relay/client.html#RelayClientError">client: object RelayClientError</a></li>
          </ul></dd>
<dt><a name="RelayConnection" href="#RelayConnection"><span>RelayConnection:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rconn: type RelayConnection" href="libp2p/protocols/connectivity/relay/rconn.html#RelayConnection">rconn: type RelayConnection</a></li>
          </ul></dd>
<dt><a name="RelayDialError" href="#RelayDialError"><span>RelayDialError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object RelayDialError" href="libp2p/protocols/connectivity/relay/client.html#RelayDialError">client: object RelayDialError</a></li>
          </ul></dd>
<dt><a name="RelayMessage" href="#RelayMessage"><span>RelayMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object RelayMessage" href="libp2p/protocols/connectivity/relay/messages.html#RelayMessage">messages: object RelayMessage</a></li>
          </ul></dd>
<dt><a name="RelayMsgSize" href="#RelayMsgSize"><span>RelayMsgSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: const RelayMsgSize" href="libp2p/protocols/connectivity/relay/relay.html#RelayMsgSize">relay: const RelayMsgSize</a></li>
          </ul></dd>
<dt><a name="RelayPeer" href="#RelayPeer"><span>RelayPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object RelayPeer" href="libp2p/protocols/connectivity/relay/messages.html#RelayPeer">messages: object RelayPeer</a></li>
          </ul></dd>
<dt><a name="RelayTransport" href="#RelayTransport"><span>RelayTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rtransport: type RelayTransport" href="libp2p/protocols/connectivity/relay/rtransport.html#RelayTransport">rtransport: type RelayTransport</a></li>
          </ul></dd>
<dt><a name="RelayType" href="#RelayType"><span>RelayType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: enum RelayType" href="libp2p/protocols/connectivity/relay/messages.html#RelayType">messages: enum RelayType</a></li>
          </ul></dd>
<dt><a name="RelayV1Codec" href="#RelayV1Codec"><span>RelayV1Codec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: const RelayV1Codec" href="libp2p/protocols/connectivity/relay/utils.html#RelayV1Codec">utils: const RelayV1Codec</a></li>
          </ul></dd>
<dt><a name="RelayV1DialError" href="#RelayV1DialError"><span>RelayV1DialError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object RelayV1DialError" href="libp2p/protocols/connectivity/relay/client.html#RelayV1DialError">client: object RelayV1DialError</a></li>
          </ul></dd>
<dt><a name="RelayV2DialError" href="#RelayV2DialError"><span>RelayV2DialError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object RelayV2DialError" href="libp2p/protocols/connectivity/relay/client.html#RelayV2DialError">client: object RelayV2DialError</a></li>
          </ul></dd>
<dt><a name="RelayV2Error" href="#RelayV2Error"><span>RelayV2Error:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="relay: object RelayV2Error" href="libp2p/protocols/connectivity/relay/relay.html#RelayV2Error">relay: object RelayV2Error</a></li>
          </ul></dd>
<dt><a name="RelayV2HopCodec" href="#RelayV2HopCodec"><span>RelayV2HopCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: const RelayV2HopCodec" href="libp2p/protocols/connectivity/relay/utils.html#RelayV2HopCodec">utils: const RelayV2HopCodec</a></li>
          </ul></dd>
<dt><a name="RelayV2StopCodec" href="#RelayV2StopCodec"><span>RelayV2StopCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: const RelayV2StopCodec" href="libp2p/protocols/connectivity/relay/utils.html#RelayV2StopCodec">utils: const RelayV2StopCodec</a></li>
          </ul></dd>
<dt><a name="release" href="#release"><span>release:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc release(cs: ConnectionSlot)" href="libp2p/connmanager.html#release%2CConnectionSlot">connmanager: proc release(cs: ConnectionSlot)</a></li>
          </ul></dd>
<dt><a name="Reliable" href="#Reliable"><span>Reliable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const Reliable" href="libp2p/multiaddress.html#Reliable">multiaddress: const Reliable</a></li>
          </ul></dd>
<dt><a name="removeConnEventHandler" href="#removeConnEventHandler"><span>removeConnEventHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc removeConnEventHandler(c: ConnManager; handler: ConnEventHandler;
                       kind: ConnEventKind)" href="libp2p/connmanager.html#removeConnEventHandler%2CConnManager%2CConnEventHandler%2CConnEventKind">connmanager: proc removeConnEventHandler(c: ConnManager; handler: ConnEventHandler;
                       kind: ConnEventKind)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc removeConnEventHandler(s: Switch; handler: ConnEventHandler; kind: ConnEventKind)" href="libp2p/switch.html#removeConnEventHandler%2CSwitch%2CConnEventHandler%2CConnEventKind">switch: proc removeConnEventHandler(s: Switch; handler: ConnEventHandler; kind: ConnEventKind)</a></li>
          </ul></dd>
<dt><a name="removeObserver" href="#removeObserver"><span>removeObserver:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc removeObserver(p: PubSub; observer: PubSubObserver)" href="libp2p/protocols/pubsub/pubsub.html#removeObserver%2CPubSub%2CPubSubObserver">pubsub: proc removeObserver(p: PubSub; observer: PubSubObserver)</a></li>
          </ul></dd>
<dt><a name="removePeer" href="#removePeer"><span>removePeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peertable: proc removePeer(table: var PeerTable; topic: string; peer: PubSubPeer)" href="libp2p/protocols/pubsub/peertable.html#removePeer%2CPeerTable%2Cstring%2CPubSubPeer">peertable: proc removePeer(table: var PeerTable; topic: string; peer: PubSubPeer)</a></li>
          </ul></dd>
<dt><a name="removePeerEventHandler" href="#removePeerEventHandler"><span>removePeerEventHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc removePeerEventHandler(c: ConnManager; handler: PeerEventHandler;
                       kind: PeerEventKind)" href="libp2p/connmanager.html#removePeerEventHandler%2CConnManager%2CPeerEventHandler%2CPeerEventKind">connmanager: proc removePeerEventHandler(c: ConnManager; handler: PeerEventHandler;
                       kind: PeerEventKind)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc removePeerEventHandler(s: Switch; handler: PeerEventHandler; kind: PeerEventKind)" href="libp2p/switch.html#removePeerEventHandler%2CSwitch%2CPeerEventHandler%2CPeerEventKind">switch: proc removePeerEventHandler(s: Switch; handler: PeerEventHandler; kind: PeerEventKind)</a></li>
          </ul></dd>
<dt><a name="removeValidator" href="#removeValidator"><span>removeValidator:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: method removeValidator(p: PubSub; topic: varargs[string]; hook: ValidatorHandler)" href="libp2p/protocols/pubsub/pubsub.html#removeValidator.e%2CPubSub%2Cvarargs%5Bstring%5D%2CValidatorHandler">pubsub: method removeValidator(p: PubSub; topic: varargs[string]; hook: ValidatorHandler)</a></li>
          </ul></dd>
<dt><a name="RendezVous" href="#RendezVous"><span>RendezVous:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: type RendezVous" href="libp2p/protocols/rendezvous/rendezvous.html#RendezVous">rendezvous: type RendezVous</a></li>
          </ul></dd>
<dt><a name="RendezVousCodec" href="#RendezVousCodec"><span>RendezVousCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: const RendezVousCodec" href="libp2p/protocols/rendezvous/rendezvous.html#RendezVousCodec">rendezvous: const RendezVousCodec</a></li>
          </ul></dd>
<dt><a name="RendezVousError" href="#RendezVousError"><span>RendezVousError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: object RendezVousError" href="libp2p/protocols/rendezvous/rendezvous.html#RendezVousError">rendezvous: object RendezVousError</a></li>
          </ul></dd>
<dt><a name="replenishFanout" href="#replenishFanout"><span>replenishFanout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="behavior: proc replenishFanout(g: GossipSub; topic: string)" href="libp2p/protocols/pubsub/gossipsub/behavior.html#replenishFanout%2CGossipSub%2Cstring">behavior: proc replenishFanout(g: GossipSub; topic: string)</a></li>
          </ul></dd>
<dt><a name="repr" href="#repr"><span>repr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc repr(cid: Cid): string" href="libp2p/cid.html#repr%2CCid">cid: proc repr(cid: Cid): string</a></li>
          </ul></dd>
<dt><a name="request" href="#request"><span>request:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc request[E](rdv: GenericRendezVous[E]; ns: Opt[string]; lt: Opt[int];
           peersOpt: Opt[seq[PeerId]]): InternalRaisesFuture[seq[E],
    (LPError, CancelledError)]" href="libp2p/protocols/rendezvous/rendezvous.html#request%2CGenericRendezVous%5BE%5D%2COpt%5Bstring%5D%2COpt%5Bint%5D%2COpt%5Bseq%5BPeerId%5D%5D">rendezvous: proc request[E](rdv: GenericRendezVous[E]; ns: Opt[string]; lt: Opt[int];
           peersOpt: Opt[seq[PeerId]]): InternalRaisesFuture[seq[E],
    (LPError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="requestAuthentication" href="#requestAuthentication"><span>requestAuthentication:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc requestAuthentication(self: PeerIDAuthClient; uri: Uri): InternalRaisesFuture[
    PeerIDAuthAuthenticationResponse, (PeerIDAuthError, CancelledError)]" href="libp2p/peeridauth/client.html#requestAuthentication%2CPeerIDAuthClient%2CUri">client: proc requestAuthentication(self: PeerIDAuthClient; uri: Uri): InternalRaisesFuture[
    PeerIDAuthAuthenticationResponse, (PeerIDAuthError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="requestAuthorization" href="#requestAuthorization"><span>requestAuthorization:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc requestAuthorization(self: PeerIDAuthClient; peerInfo: PeerInfo; uri: Uri;
                     challengeClient: PeerIDAuthChallenge;
                     challengeServer: PeerIDAuthChallenge;
                     serverPubkey: PublicKey; opaque: PeerIDAuthOpaque;
                     payload: auto): InternalRaisesFuture[
    PeerIDAuthAuthorizationResponse, (PeerIDAuthError, CancelledError)]" href="libp2p/peeridauth/client.html#requestAuthorization%2CPeerIDAuthClient%2CPeerInfo%2CUri%2CPeerIDAuthChallenge%2CPeerIDAuthChallenge%2CPublicKey%2CPeerIDAuthOpaque%2Cauto">client: proc requestAuthorization(self: PeerIDAuthClient; peerInfo: PeerInfo; uri: Uri;
                     challengeClient: PeerIDAuthChallenge;
                     challengeServer: PeerIDAuthChallenge;
                     serverPubkey: PublicKey; opaque: PeerIDAuthOpaque;
                     payload: auto): InternalRaisesFuture[
    PeerIDAuthAuthorizationResponse, (PeerIDAuthError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="requestLocally" href="#requestLocally"><span>requestLocally:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc requestLocally[E](rdv: GenericRendezVous[E]; ns: string): seq[E]" href="libp2p/protocols/rendezvous/rendezvous.html#requestLocally%2CGenericRendezVous%5BE%5D%2Cstring">rendezvous: proc requestLocally[E](rdv: GenericRendezVous[E]; ns: string): seq[E]</a></li>
          </ul></dd>
<dt><a name="Reservation" href="#Reservation"><span>Reservation:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object Reservation" href="libp2p/protocols/connectivity/relay/messages.html#Reservation">messages: object Reservation</a></li>
          </ul></dd>
<dt><a name="ReservationError" href="#ReservationError"><span>ReservationError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object ReservationError" href="libp2p/protocols/connectivity/relay/client.html#ReservationError">client: object ReservationError</a></li>
          </ul></dd>
<dt><a name="ReservationRefused" href="#ReservationRefused"><span>ReservationRefused:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.ReservationRefused" href="libp2p/protocols/connectivity/relay/messages.html#ReservationRefused">messages: StatusV2.ReservationRefused</a></li>
          </ul></dd>
<dt><a name="reserve" href="#reserve"><span>reserve:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc reserve(cl: RelayClient; peerId: PeerId; addrs: seq[MultiAddress] = @[]): InternalRaisesFuture[
    Rsvp, (ReservationError, DialFailedError, CancelledError)]" href="libp2p/protocols/connectivity/relay/client.html#reserve%2CRelayClient%2CPeerId%2Cseq%5BMultiAddress%5D">client: proc reserve(cl: RelayClient; peerId: PeerId; addrs: seq[MultiAddress] = @[]): InternalRaisesFuture[
    Rsvp, (ReservationError, DialFailedError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="reset" href="#reset"><span>reset:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpchannel: proc reset(s: LPChannel): InternalRaisesFuture[void, void]" href="libp2p/muxers/mplex/lpchannel.html#reset%2CLPChannel">lpchannel: proc reset(s: LPChannel): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="resolveDnsAddr" href="#resolveDnsAddr"><span>resolveDnsAddr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="nameresolver: proc resolveDnsAddr(self: NameResolver; ma: MultiAddress; depth: int = 0): InternalRaisesFuture[
    seq[MultiAddress], (CancelledError, MaError, TransportAddressError)]" href="libp2p/nameresolving/nameresolver.html#resolveDnsAddr%2CNameResolver%2CMultiAddress%2Cint">nameresolver: proc resolveDnsAddr(self: NameResolver; ma: MultiAddress; depth: int = 0): InternalRaisesFuture[
    seq[MultiAddress], (CancelledError, MaError, TransportAddressError)]</a></li>
          </ul></dd>
<dt><a name="resolveIp" href="#resolveIp"><span>resolveIp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="nameresolver: method resolveIp(self: NameResolver; address: string; port: Port;
          domain: Domain = Domain.AF_UNSPEC): InternalRaisesFuture[
    seq[TransportAddress], (CancelledError, TransportAddressError)]" href="libp2p/nameresolving/nameresolver.html#resolveIp.e%2CNameResolver%2Cstring%2CPort%2CDomain">nameresolver: method resolveIp(self: NameResolver; address: string; port: Port;
          domain: Domain = Domain.AF_UNSPEC): InternalRaisesFuture[
    seq[TransportAddress], (CancelledError, TransportAddressError)]</a></li>
          </ul></dd>
<dt><a name="resolveMAddress" href="#resolveMAddress"><span>resolveMAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="nameresolver: proc resolveMAddress(self: NameResolver; address: MultiAddress): InternalRaisesFuture[
    seq[MultiAddress], (CancelledError, MaError, TransportAddressError)]" href="libp2p/nameresolving/nameresolver.html#resolveMAddress%2CNameResolver%2CMultiAddress">nameresolver: proc resolveMAddress(self: NameResolver; address: MultiAddress): InternalRaisesFuture[
    seq[MultiAddress], (CancelledError, MaError, TransportAddressError)]</a></li>
          </ul></dd>
<dt><a name="resolveTxt" href="#resolveTxt"><span>resolveTxt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="nameresolver: method resolveTxt(self: NameResolver; address: string): InternalRaisesFuture[
    seq[string], (CancelledError,)]" href="libp2p/nameresolving/nameresolver.html#resolveTxt.e%2CNameResolver%2Cstring">nameresolver: method resolveTxt(self: NameResolver; address: string): InternalRaisesFuture[
    seq[string], (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="ResourceLimitExceeded" href="#ResourceLimitExceeded"><span>ResourceLimitExceeded:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.ResourceLimitExceeded" href="libp2p/protocols/connectivity/relay/messages.html#ResourceLimitExceeded">messages: StatusV2.ResourceLimitExceeded</a></li>
          </ul></dd>
<dt><a name="ResponseStatus" href="#ResponseStatus"><span>ResponseStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: enum ResponseStatus" href="libp2p/protocols/connectivity/autonat/types.html#ResponseStatus">types: enum ResponseStatus</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: enum ResponseStatus" href="libp2p/protocols/connectivity/autonatv2/types.html#ResponseStatus">types: enum ResponseStatus</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: enum ResponseStatus" href="libp2p/protocols/rendezvous/protobuf.html#ResponseStatus">protobuf: enum ResponseStatus</a></li>
          </ul></dd>
<dt><a name="rewardDelivered" href="#rewardDelivered"><span>rewardDelivered:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc rewardDelivered(g: GossipSub; peer: PubSubPeer; topic: string; first: bool;
                delay = ZeroDuration)" href="libp2p/protocols/pubsub/gossipsub/scoring.html#rewardDelivered%2CGossipSub%2CPubSubPeer%2Cstring%2Cbool">scoring: proc rewardDelivered(g: GossipSub; peer: PubSubPeer; topic: string; first: bool;
                delay = ZeroDuration)</a></li>
          </ul></dd>
<dt><a name="RoutingRecordsHandler" href="#RoutingRecordsHandler"><span>RoutingRecordsHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type RoutingRecordsHandler" href="libp2p/protocols/pubsub/gossipsub/types.html#RoutingRecordsHandler">types: type RoutingRecordsHandler</a></li>
          </ul></dd>
<dt><a name="RoutingRecordsPair" href="#RoutingRecordsPair"><span>RoutingRecordsPair:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: tuple RoutingRecordsPair" href="libp2p/protocols/pubsub/gossipsub/types.html#RoutingRecordsPair">types: tuple RoutingRecordsPair</a></li>
          </ul></dd>
<dt><a name="RoutingTable" href="#RoutingTable"><span>RoutingTable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type RoutingTable" href="libp2p/protocols/kademlia/types.html#RoutingTable">types: type RoutingTable</a></li>
          </ul></dd>
<dt><a name="RoutingTableConfig" href="#RoutingTableConfig"><span>RoutingTableConfig:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type RoutingTableConfig" href="libp2p/protocols/kademlia/types.html#RoutingTableConfig">types: type RoutingTableConfig</a></li>
          </ul></dd>
<dt><a name="rpcHandler" href="#rpcHandler"><span>rpcHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: method rpcHandler(f: FloodSub; peer: PubSubPeer; data: sink seq[byte]): InternalRaisesFuture[
    void, (CancelledError, PeerMessageDecodeError, PeerRateLimitError)]" href="libp2p/protocols/pubsub/floodsub.html#rpcHandler.e%2CFloodSub%2CPubSubPeer%2Csinkseq%5Bbyte%5D">floodsub: method rpcHandler(f: FloodSub; peer: PubSubPeer; data: sink seq[byte]): InternalRaisesFuture[
    void, (CancelledError, PeerMessageDecodeError, PeerRateLimitError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: method rpcHandler(g: GossipSub; peer: PubSubPeer; data: sink seq[byte]): InternalRaisesFuture[
    void, (CancelledError, PeerMessageDecodeError, PeerRateLimitError)]" href="libp2p/protocols/pubsub/gossipsub.html#rpcHandler.e%2CGossipSub%2CPubSubPeer%2Csinkseq%5Bbyte%5D">gossipsub: method rpcHandler(g: GossipSub; peer: PubSubPeer; data: sink seq[byte]): InternalRaisesFuture[
    void, (CancelledError, PeerMessageDecodeError, PeerRateLimitError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method rpcHandler(p: PubSub; peer: PubSubPeer; data: sink seq[byte]): InternalRaisesFuture[
    void, (CancelledError, PeerMessageDecodeError, PeerRateLimitError)]" href="libp2p/protocols/pubsub/pubsub.html#rpcHandler.e%2CPubSub%2CPubSubPeer%2Csinkseq%5Bbyte%5D">pubsub: method rpcHandler(p: PubSub; peer: PubSubPeer; data: sink seq[byte]): InternalRaisesFuture[
    void, (CancelledError, PeerMessageDecodeError, PeerRateLimitError)]</a></li>
          </ul></dd>
<dt><a name="RPCHandler" href="#RPCHandler"><span>RPCHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type RPCHandler" href="libp2p/protocols/pubsub/pubsubpeer.html#RPCHandler">pubsubpeer: type RPCHandler</a></li>
          </ul></dd>
<dt><a name="RpcMessageQueue" href="#RpcMessageQueue"><span>RpcMessageQueue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: type RpcMessageQueue" href="libp2p/protocols/pubsub/pubsubpeer.html#RpcMessageQueue">pubsubpeer: type RpcMessageQueue</a></li>
          </ul></dd>
<dt><a name="RPCMsg" href="#RPCMsg"><span>RPCMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object RPCMsg" href="libp2p/protocols/pubsub/rpc/messages.html#RPCMsg">messages: object RPCMsg</a></li>
          </ul></dd>
<dt><a name="RSA" href="#RSA"><span>RSA:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: PKScheme.RSA" href="libp2p/crypto/crypto.html#RSA">crypto: PKScheme.RSA</a></li>
          </ul></dd>
<dt><a name="RsaDefaultKeySize" href="#RsaDefaultKeySize"><span>RsaDefaultKeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: const RsaDefaultKeySize" href="libp2p/crypto/crypto.html#RsaDefaultKeySize">crypto: const RsaDefaultKeySize</a></li>
          </ul></dd>
<dt><a name="RsaError" href="#RsaError"><span>RsaError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: enum RsaError" href="libp2p/crypto/rsa.html#RsaError">rsa: enum RsaError</a></li>
          </ul></dd>
<dt><a name="RsaGenError" href="#RsaGenError"><span>RsaGenError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: RsaError.RsaGenError" href="libp2p/crypto/rsa.html#RsaGenError">rsa: RsaError.RsaGenError</a></li>
          </ul></dd>
<dt><a name="RsaKeyIncorrectError" href="#RsaKeyIncorrectError"><span>RsaKeyIncorrectError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: RsaError.RsaKeyIncorrectError" href="libp2p/crypto/rsa.html#RsaKeyIncorrectError">rsa: RsaError.RsaKeyIncorrectError</a></li>
          </ul></dd>
<dt><a name="RsaKeyPair" href="#RsaKeyPair"><span>RsaKeyPair:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: type RsaKeyPair" href="libp2p/crypto/rsa.html#RsaKeyPair">rsa: type RsaKeyPair</a></li>
          </ul></dd>
<dt><a name="RsaKP" href="#RsaKP"><span>RsaKP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: type RsaKP" href="libp2p/crypto/rsa.html#RsaKP">rsa: type RsaKP</a></li>
          </ul></dd>
<dt><a name="RsaLowSecurityError" href="#RsaLowSecurityError"><span>RsaLowSecurityError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: RsaError.RsaLowSecurityError" href="libp2p/crypto/rsa.html#RsaLowSecurityError">rsa: RsaError.RsaLowSecurityError</a></li>
          </ul></dd>
<dt><a name="RsaOidSha1" href="#RsaOidSha1"><span>RsaOidSha1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const RsaOidSha1" href="libp2p/crypto/rsa.html#RsaOidSha1">rsa: const RsaOidSha1</a></li>
          </ul></dd>
<dt><a name="RsaOidSha224" href="#RsaOidSha224"><span>RsaOidSha224:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const RsaOidSha224" href="libp2p/crypto/rsa.html#RsaOidSha224">rsa: const RsaOidSha224</a></li>
          </ul></dd>
<dt><a name="RsaOidSha256" href="#RsaOidSha256"><span>RsaOidSha256:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const RsaOidSha256" href="libp2p/crypto/rsa.html#RsaOidSha256">rsa: const RsaOidSha256</a></li>
          </ul></dd>
<dt><a name="RsaOidSha384" href="#RsaOidSha384"><span>RsaOidSha384:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const RsaOidSha384" href="libp2p/crypto/rsa.html#RsaOidSha384">rsa: const RsaOidSha384</a></li>
          </ul></dd>
<dt><a name="RsaOidSha512" href="#RsaOidSha512"><span>RsaOidSha512:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: const RsaOidSha512" href="libp2p/crypto/rsa.html#RsaOidSha512">rsa: const RsaOidSha512</a></li>
          </ul></dd>
<dt><a name="RsaPKI" href="#RsaPKI"><span>RsaPKI:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: type RsaPKI" href="libp2p/crypto/rsa.html#RsaPKI">rsa: type RsaPKI</a></li>
          </ul></dd>
<dt><a name="RsaPrivateKey" href="#RsaPrivateKey"><span>RsaPrivateKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: type RsaPrivateKey" href="libp2p/crypto/rsa.html#RsaPrivateKey">rsa: type RsaPrivateKey</a></li>
          </ul></dd>
<dt><a name="RsaPublicKey" href="#RsaPublicKey"><span>RsaPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: type RsaPublicKey" href="libp2p/crypto/rsa.html#RsaPublicKey">rsa: type RsaPublicKey</a></li>
          </ul></dd>
<dt><a name="RsaResult" href="#RsaResult"><span>RsaResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: type RsaResult" href="libp2p/crypto/rsa.html#RsaResult">rsa: type RsaResult</a></li>
          </ul></dd>
<dt><a name="RsaSignature" href="#RsaSignature"><span>RsaSignature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: type RsaSignature" href="libp2p/crypto/rsa.html#RsaSignature">rsa: type RsaSignature</a></li>
          </ul></dd>
<dt><a name="RsaSignatureError" href="#RsaSignatureError"><span>RsaSignatureError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: RsaError.RsaSignatureError" href="libp2p/crypto/rsa.html#RsaSignatureError">rsa: RsaError.RsaSignatureError</a></li>
          </ul></dd>
<dt><a name="Rsvp" href="#Rsvp"><span>Rsvp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: object Rsvp" href="libp2p/protocols/connectivity/relay/client.html#Rsvp">client: object Rsvp</a></li>
          </ul></dd>
<dt><a name="RTRANSPMA" href="#RTRANSPMA"><span>RTRANSPMA:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wire: const RTRANSPMA" href="libp2p/wire.html#RTRANSPMA">wire: const RTRANSPMA</a></li>
          </ul></dd>
<dt><a name="run" href="#run"><span>run:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: method run(self: AutonatV2Service; switch: Switch): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/connectivity/autonatv2/service.html#run.e%2CAutonatV2Service%2CSwitch">service: method run(self: AutonatV2Service; switch: Switch): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wildcardresolverservice: method run(self: WildcardAddressResolverService; switch: Switch): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/services/wildcardresolverservice.html#run.e%2CWildcardAddressResolverService%2CSwitch">wildcardresolverservice: method run(self: WildcardAddressResolverService; switch: Switch): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method run(self: Service; switch: Switch): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/switch.html#run.e%2CService%2CSwitch">switch: method run(self: Service; switch: Switch): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="runHandleLoop" href="#runHandleLoop"><span>runHandleLoop:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc runHandleLoop(p: PubSubPeer; conn: Connection): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/pubsub/pubsubpeer.html#runHandleLoop%2CPubSubPeer%2CConnection">pubsubpeer: proc runHandleLoop(p: PubSubPeer; conn: Connection): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="safeClose" href="#safeClose"><span>safeClose:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: template safeClose(stream: untyped)" href="libp2p/transports/transport.html#safeClose.t%2Cuntyped">transport: template safeClose(stream: untyped)</a></li>
          </ul></dd>
<dt><a name="safeCloseWait" href="#safeCloseWait"><span>safeCloseWait:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: template safeCloseWait(stream: untyped)" href="libp2p/transports/transport.html#safeCloseWait.t%2Cuntyped">transport: template safeCloseWait(stream: untyped)</a></li>
          </ul></dd>
<dt><a name="safeConvert" href="#safeConvert"><span>safeConvert:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: proc safeConvert[T: SomeInteger](value: SomeOrdinal): T" href="libp2p/utility.html#safeConvert%2CSomeOrdinal">utility: proc safeConvert[T: SomeInteger](value: SomeOrdinal): T</a></li>
          </ul></dd>
<dt><a name="salt" href="#salt"><span>salt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: proc salt(f: FloodSub; msgId: MessageId): SaltedId" href="libp2p/protocols/pubsub/floodsub.html#salt%2CFloodSub%2CMessageId">floodsub: proc salt(f: FloodSub; msgId: MessageId): SaltedId</a></li>
          </ul></dd>
<dt><a name="SaltedId" href="#SaltedId"><span>SaltedId:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object SaltedId" href="libp2p/protocols/pubsub/rpc/messages.html#SaltedId">messages: object SaltedId</a></li>
          </ul></dd>
<dt><a name="save" href="#save"><span>save:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc save[E](rdv: GenericRendezVous[E]; ns: string; peerId: PeerId; r: Register;
        update: bool = true)" href="libp2p/protocols/rendezvous/rendezvous.html#save%2CGenericRendezVous%5BE%5D%2Cstring%2CPeerId%2CRegister%2Cbool">rendezvous: proc save[E](rdv: GenericRendezVous[E]; ns: string; peerId: PeerId; r: Register;
        update: bool = true)</a></li>
          </ul></dd>
<dt><a name="scalarMul" href="#scalarMul"><span>scalarMul:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: proc scalarMul(pub: EcPublicKey; sec: EcPrivateKey): EcPublicKey" href="libp2p/crypto/ecnist.html#scalarMul%2CEcPublicKey%2CEcPrivateKey">ecnist: proc scalarMul(pub: EcPublicKey; sec: EcPrivateKey): EcPublicKey</a></li>
          </ul></dd>
<dt><a name="SchemeError" href="#SchemeError"><span>SchemeError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: CryptoError.SchemeError" href="libp2p/crypto/crypto.html#SchemeError">crypto: CryptoError.SchemeError</a></li>
          </ul></dd>
<dt><a name="scoringHeartbeat" href="#scoringHeartbeat"><span>scoringHeartbeat:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc scoringHeartbeat(g: GossipSub): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/pubsub/gossipsub/scoring.html#scoringHeartbeat%2CGossipSub">scoring: proc scoringHeartbeat(g: GossipSub): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="seckey" href="#seckey"><span>seckey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rsa: proc seckey(pair: RsaKeyPair): RsaPrivateKey" href="libp2p/crypto/rsa.html#seckey%2CRsaKeyPair">rsa: proc seckey(pair: RsaKeyPair): RsaPrivateKey</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: template seckey(v: SkKeyPair): SkPrivateKey" href="libp2p/crypto/secp.html#seckey.t%2CSkKeyPair">secp: template seckey(v: SkKeyPair): SkPrivateKey</a></li>
          </ul></dd>
<dt><a name="SecKey256Length" href="#SecKey256Length"><span>SecKey256Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const SecKey256Length" href="libp2p/crypto/ecnist.html#SecKey256Length">ecnist: const SecKey256Length</a></li>
          </ul></dd>
<dt><a name="SecKey384Length" href="#SecKey384Length"><span>SecKey384Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const SecKey384Length" href="libp2p/crypto/ecnist.html#SecKey384Length">ecnist: const SecKey384Length</a></li>
          </ul></dd>
<dt><a name="SecKey521Length" href="#SecKey521Length"><span>SecKey521Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const SecKey521Length" href="libp2p/crypto/ecnist.html#SecKey521Length">ecnist: const SecKey521Length</a></li>
          </ul></dd>
<dt><a name="Secp256k1" href="#Secp256k1"><span>Secp256k1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: PKScheme.Secp256k1" href="libp2p/crypto/crypto.html#Secp256k1">crypto: PKScheme.Secp256k1</a></li>
          </ul></dd>
<dt><a name="Secp256r1" href="#Secp256r1"><span>Secp256r1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcCurveKind.Secp256r1" href="libp2p/crypto/ecnist.html#Secp256r1">ecnist: EcCurveKind.Secp256r1</a></li>
          </ul></dd>
<dt><a name="Secp384r1" href="#Secp384r1"><span>Secp384r1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcCurveKind.Secp384r1" href="libp2p/crypto/ecnist.html#Secp384r1">ecnist: EcCurveKind.Secp384r1</a></li>
          </ul></dd>
<dt><a name="Secp521r1" href="#Secp521r1"><span>Secp521r1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: EcCurveKind.Secp521r1" href="libp2p/crypto/ecnist.html#Secp521r1">ecnist: EcCurveKind.Secp521r1</a></li>
          </ul></dd>
<dt><a name="Secret" href="#Secret"><span>Secret:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: object Secret" href="libp2p/crypto/crypto.html#Secret">crypto: object Secret</a></li>
          </ul></dd>
<dt><a name="Secret256Length" href="#Secret256Length"><span>Secret256Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const Secret256Length" href="libp2p/crypto/ecnist.html#Secret256Length">ecnist: const Secret256Length</a></li>
          </ul></dd>
<dt><a name="Secret384Length" href="#Secret384Length"><span>Secret384Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const Secret384Length" href="libp2p/crypto/ecnist.html#Secret384Length">ecnist: const Secret384Length</a></li>
          </ul></dd>
<dt><a name="Secret521Length" href="#Secret521Length"><span>Secret521Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const Secret521Length" href="libp2p/crypto/ecnist.html#Secret521Length">ecnist: const Secret521Length</a></li>
          </ul></dd>
<dt><a name="Secure" href="#Secure"><span>Secure:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secure: type Secure" href="libp2p/protocols/secure/secure.html#Secure">secure: type Secure</a></li>
          </ul></dd>
<dt><a name="secure" href="#secure"><span>secure:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secure: method secure(s: Secure; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError)]" href="libp2p/protocols/secure/secure.html#secure.e%2CSecure%2CConnection%2COpt%5BPeerId%5D">secure: method secure(s: Secure; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Connection, (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: proc secure(self: WsTransport): bool" href="libp2p/transports/wstransport.html#secure%2CWsTransport">wstransport: proc secure(self: WsTransport): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="upgrade: proc secure(self: Upgrade; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Connection, (CancelledError, LPError)]" href="libp2p/upgrademngrs/upgrade.html#secure%2CUpgrade%2CConnection%2COpt%5BPeerId%5D">upgrade: proc secure(self: Upgrade; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Connection, (CancelledError, LPError)]</a></li>
          </ul></dd>
<dt><a name="SecureConn" href="#SecureConn"><span>SecureConn:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secure: type SecureConn" href="libp2p/protocols/secure/secure.html#SecureConn">secure: type SecureConn</a></li>
          </ul></dd>
<dt><a name="SecureConnTrackerName" href="#SecureConnTrackerName"><span>SecureConnTrackerName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secure: const SecureConnTrackerName" href="libp2p/protocols/secure/secure.html#SecureConnTrackerName">secure: const SecureConnTrackerName</a></li>
          </ul></dd>
<dt><a name="SecureProtocol" href="#SecureProtocol"><span>SecureProtocol:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: enum SecureProtocol" href="libp2p/builders.html#SecureProtocol">builders: enum SecureProtocol</a></li>
          </ul></dd>
<dt><a name="select" href="#select"><span>select:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: proc select(_: MultistreamSelect | type MultistreamSelect; conn: Connection;
       proto: seq[string]): InternalRaisesFuture[string,
    (CancelledError, LPStreamError, MultiStreamError)]" href="libp2p/multistream.html#select%2C%2CConnection%2Cseq%5Bstring%5D">multistream: proc select(_: MultistreamSelect | type MultistreamSelect; conn: Connection;
       proto: seq[string]): InternalRaisesFuture[string,
    (CancelledError, LPStreamError, MultiStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multistream: proc select(_: MultistreamSelect | type MultistreamSelect; conn: Connection;
       proto: string): InternalRaisesFuture[bool,
    (CancelledError, LPStreamError, MultiStreamError)]" href="libp2p/multistream.html#select%2C%2CConnection%2Cstring">multistream: proc select(_: MultistreamSelect | type MultistreamSelect; conn: Connection;
       proto: string): InternalRaisesFuture[bool,
    (CancelledError, LPStreamError, MultiStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multistream: proc select(m: MultistreamSelect; conn: Connection): InternalRaisesFuture[bool,
    (CancelledError, LPStreamError, MultiStreamError)]" href="libp2p/multistream.html#select%2CMultistreamSelect%2CConnection">multistream: proc select(m: MultistreamSelect; conn: Connection): InternalRaisesFuture[bool,
    (CancelledError, LPStreamError, MultiStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: method select(self: DefaultEntrySelector; key: Key; records: seq[EntryRecord]): Result[
    int, string]" href="libp2p/protocols/kademlia/types.html#select.e%2CDefaultEntrySelector%2CKey%2Cseq%5BEntryRecord%5D">types: method select(self: DefaultEntrySelector; key: Key; records: seq[EntryRecord]): Result[
    int, string]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: method select(self: EntrySelector; key: Key; records: seq[EntryRecord]): Result[int,
    string]" href="libp2p/protocols/kademlia/types.html#select.e%2CEntrySelector%2CKey%2Cseq%5BEntryRecord%5D">types: method select(self: EntrySelector; key: Key; records: seq[EntryRecord]): Result[int,
    string]</a></li>
          </ul></dd>
<dt><a name="selectAlphaPeers" href="#selectAlphaPeers"><span>selectAlphaPeers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lookupstate: proc selectAlphaPeers(state: LookupState): seq[PeerId]" href="libp2p/protocols/kademlia/lookupstate.html#selectAlphaPeers%2CLookupState">lookupstate: proc selectAlphaPeers(state: LookupState): seq[PeerId]</a></li>
          </ul></dd>
<dt><a name="selectBest" href="#selectBest"><span>selectBest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc selectBest(order: int; p1, p2: string): string" href="libp2p/crypto/crypto.html#selectBest%2Cint%2Cstring%2Cstring">crypto: proc selectBest(order: int; p1, p2: string): string</a></li>
          </ul></dd>
<dt><a name="selectClosestK" href="#selectClosestK"><span>selectClosestK:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lookupstate: proc selectClosestK(state: LookupState): seq[PeerId]" href="libp2p/protocols/kademlia/lookupstate.html#selectClosestK%2CLookupState">lookupstate: proc selectClosestK(state: LookupState): seq[PeerId]</a></li>
          </ul></dd>
<dt><a name="selectMuxer" href="#selectMuxer"><span>selectMuxer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc selectMuxer(c: ConnManager; peerId: PeerId): Muxer" href="libp2p/connmanager.html#selectMuxer%2CConnManager%2CPeerId">connmanager: proc selectMuxer(c: ConnManager; peerId: PeerId): Muxer</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connmanager: proc selectMuxer(c: ConnManager; peerId: PeerId; dir: Direction): Muxer" href="libp2p/connmanager.html#selectMuxer%2CConnManager%2CPeerId%2CDirection">connmanager: proc selectMuxer(c: ConnManager; peerId: PeerId; dir: Direction): Muxer</a></li>
          </ul></dd>
<dt><a name="SemaphoreDefaultSize" href="#SemaphoreDefaultSize"><span>SemaphoreDefaultSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: const SemaphoreDefaultSize" href="libp2p/protocols/rendezvous/rendezvous.html#SemaphoreDefaultSize">rendezvous: const SemaphoreDefaultSize</a></li>
          </ul></dd>
<dt><a name="send" href="#send"><span>send:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc send(self: PeerIDAuthClient; uri: Uri; peerInfo: PeerInfo; payload: auto;
     bearer: Opt[BearerToken] = Opt.none(BearerToken)): InternalRaisesFuture[
    (BearerToken, PeerIDAuthResponse), (PeerIDAuthError, CancelledError)]" href="libp2p/peeridauth/client.html#send%2CPeerIDAuthClient%2CUri%2CPeerInfo%2Cauto%2COpt%5BBearerToken%5D">client: proc send(self: PeerIDAuthClient; uri: Uri; peerInfo: PeerInfo; payload: auto;
     bearer: Opt[BearerToken] = Opt.none(BearerToken)): InternalRaisesFuture[
    (BearerToken, PeerIDAuthResponse), (PeerIDAuthError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: proc send(p: PubSub; peer: PubSubPeer; msg: RPCMsg; isHighPriority: bool;
     useCustomConn: bool = false)" href="libp2p/protocols/pubsub/pubsub.html#send%2CPubSub%2CPubSubPeer%2CRPCMsg%2Cbool%2Cbool">pubsub: proc send(p: PubSub; peer: PubSubPeer; msg: RPCMsg; isHighPriority: bool;
     useCustomConn: bool = false)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc send(p: PubSubPeer; msg: RPCMsg; anonymize: bool; isHighPriority: bool;
     useCustomConn: bool = false)" href="libp2p/protocols/pubsub/pubsubpeer.html#send%2CPubSubPeer%2CRPCMsg%2Cbool%2Cbool%2Cbool">pubsubpeer: proc send(p: PubSubPeer; msg: RPCMsg; anonymize: bool; isHighPriority: bool;
     useCustomConn: bool = false)</a></li>
          </ul></dd>
<dt><a name="sendDialRequest" href="#sendDialRequest"><span>sendDialRequest:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: method sendDialRequest(self: AutonatV2Client; pid: PeerId; testAddrs: seq[MultiAddress]): InternalRaisesFuture[
    AutonatV2Response,
    (AutonatV2Error, CancelledError, DialFailedError, LPStreamError)]" href="libp2p/protocols/connectivity/autonatv2/client.html#sendDialRequest.e%2CAutonatV2Client%2CPeerId%2Cseq%5BMultiAddress%5D">client: method sendDialRequest(self: AutonatV2Client; pid: PeerId; testAddrs: seq[MultiAddress]): InternalRaisesFuture[
    AutonatV2Response,
    (AutonatV2Error, CancelledError, DialFailedError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendDiscoverResponse" href="#sendDiscoverResponse"><span>sendDiscoverResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc sendDiscoverResponse(conn: Connection; s: seq[Register]; cookie: Cookie): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]" href="libp2p/protocols/rendezvous/rendezvous.html#sendDiscoverResponse%2CConnection%2Cseq%5BRegister%5D%2CCookie">rendezvous: proc sendDiscoverResponse(conn: Connection; s: seq[Register]; cookie: Cookie): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendDiscoverResponseError" href="#sendDiscoverResponseError"><span>sendDiscoverResponseError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc sendDiscoverResponseError(conn: Connection; status: ResponseStatus;
                          text: string = &quot;&quot;): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/rendezvous/rendezvous.html#sendDiscoverResponseError%2CConnection%2CResponseStatus%2Cstring">rendezvous: proc sendDiscoverResponseError(conn: Connection; status: ResponseStatus;
                          text: string = &quot;&quot;): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendEncoded" href="#sendEncoded"><span>sendEncoded:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc sendEncoded(p: PubSubPeer; msg: seq[byte]; isHighPriority: bool;
            useCustomConn: bool = false): Future[void]" href="libp2p/protocols/pubsub/pubsubpeer.html#sendEncoded%2CPubSubPeer%2Cseq%5Bbyte%5D%2Cbool%2Cbool">pubsubpeer: proc sendEncoded(p: PubSubPeer; msg: seq[byte]; isHighPriority: bool;
            useCustomConn: bool = false): Future[void]</a></li>
          </ul></dd>
<dt><a name="sendFindNode" href="#sendFindNode"><span>sendFindNode:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="find: proc sendFindNode(kad: KadDHT; peerId: PeerId; addrs: seq[MultiAddress];
             targetId: Key): InternalRaisesFuture[Message,
    (CancelledError, DialFailedError, ValueError, LPStreamError)]" href="libp2p/protocols/kademlia/find.html#sendFindNode%2CKadDHT%2CPeerId%2Cseq%5BMultiAddress%5D%2CKey">find: proc sendFindNode(kad: KadDHT; peerId: PeerId; addrs: seq[MultiAddress];
             targetId: Key): InternalRaisesFuture[Message,
    (CancelledError, DialFailedError, ValueError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendHopStatus" href="#sendHopStatus"><span>sendHopStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc sendHopStatus(conn: Connection; code: StatusV2): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/connectivity/relay/utils.html#sendHopStatus%2CConnection%2CStatusV2">utils: proc sendHopStatus(conn: Connection; code: StatusV2): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendRegisterResponse" href="#sendRegisterResponse"><span>sendRegisterResponse:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc sendRegisterResponse(conn: Connection; ttl: uint64): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/rendezvous/rendezvous.html#sendRegisterResponse%2CConnection%2Cuint64">rendezvous: proc sendRegisterResponse(conn: Connection; ttl: uint64): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendRegisterResponseError" href="#sendRegisterResponseError"><span>sendRegisterResponseError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc sendRegisterResponseError(conn: Connection; status: ResponseStatus;
                          text: string = &quot;&quot;): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/rendezvous/rendezvous.html#sendRegisterResponseError%2CConnection%2CResponseStatus%2Cstring">rendezvous: proc sendRegisterResponseError(conn: Connection; status: ResponseStatus;
                          text: string = &quot;&quot;): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendStatus" href="#sendStatus"><span>sendStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc sendStatus(conn: Connection; code: StatusV1): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/connectivity/relay/utils.html#sendStatus%2CConnection%2CStatusV1">utils: proc sendStatus(conn: Connection; code: StatusV1): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="sendStopStatus" href="#sendStopStatus"><span>sendStopStatus:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utils: proc sendStopStatus(conn: Connection; code: StatusV2): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/connectivity/relay/utils.html#sendStopStatus%2CConnection%2CStatusV2">utils: proc sendStopStatus(conn: Connection; code: StatusV2): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="sendSubs" href="#sendSubs"><span>sendSubs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc sendSubs(p: PubSub; peer: PubSubPeer; topics: openArray[string]; subscribe: bool)" href="libp2p/protocols/pubsub/pubsub.html#sendSubs%2CPubSub%2CPubSubPeer%2CopenArray%5Bstring%5D%2Cbool">pubsub: proc sendSubs(p: PubSub; peer: PubSubPeer; topics: openArray[string]; subscribe: bool)</a></li>
          </ul></dd>
<dt><a name="SeqPeerBook" href="#SeqPeerBook"><span>SeqPeerBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type SeqPeerBook" href="libp2p/peerstore.html#SeqPeerBook">peerstore: type SeqPeerBook</a></li>
          </ul></dd>
<dt><a name="Service" href="#Service"><span>Service:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: type Service" href="libp2p/switch.html#Service">switch: type Service</a></li>
          </ul></dd>
<dt><a name="setMaxRecvWindow" href="#setMaxRecvWindow"><span>setMaxRecvWindow:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: proc setMaxRecvWindow(channel: YamuxChannel; maxRecvWindow: int)" href="libp2p/muxers/yamux/yamux.html#setMaxRecvWindow%2CYamuxChannel%2Cint">yamux: proc setMaxRecvWindow(channel: YamuxChannel; maxRecvWindow: int)</a></li>
          </ul></dd>
<dt><a name="setStatusAndConfidenceHandler" href="#setStatusAndConfidenceHandler"><span>setStatusAndConfidenceHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: proc setStatusAndConfidenceHandler(self: AutonatV2Service; statusAndConfidenceHandler: StatusAndConfidenceHandler)" href="libp2p/protocols/connectivity/autonatv2/service.html#setStatusAndConfidenceHandler%2CAutonatV2Service%2CStatusAndConfidenceHandler">service: proc setStatusAndConfidenceHandler(self: AutonatV2Service; statusAndConfidenceHandler: StatusAndConfidenceHandler)</a></li>
          </ul></dd>
<dt><a name="setup" href="#setup"><span>setup:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="client: proc setup(self: AutonatV2Client; switch: Switch)" href="libp2p/protocols/connectivity/autonatv2/client.html#setup%2CAutonatV2Client%2CSwitch">client: proc setup(self: AutonatV2Client; switch: Switch)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="service: method setup(self: AutonatV2Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]" href="libp2p/protocols/connectivity/autonatv2/service.html#setup.e%2CAutonatV2Service%2CSwitch">service: method setup(self: AutonatV2Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="relay: proc setup(r: Relay; switch: Switch)" href="libp2p/protocols/connectivity/relay/relay.html#setup%2CRelay%2CSwitch">relay: proc setup(r: Relay; switch: Switch)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: proc setup[E](rdv: GenericRendezVous[E]; switch: Switch)" href="libp2p/protocols/rendezvous/rendezvous.html#setup%2CGenericRendezVous%5BE%5D%2CSwitch">rendezvous: proc setup[E](rdv: GenericRendezVous[E]; switch: Switch)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wildcardresolverservice: method setup(self: WildcardAddressResolverService; switch: Switch): InternalRaisesFuture[
    bool, (CancelledError,)]" href="libp2p/services/wildcardresolverservice.html#setup.e%2CWildcardAddressResolverService%2CSwitch">wildcardresolverservice: method setup(self: WildcardAddressResolverService; switch: Switch): InternalRaisesFuture[
    bool, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method setup(self: Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]" href="libp2p/switch.html#setup.e%2CService%2CSwitch">switch: method setup(self: Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="Sha256" href="#Sha256"><span>Sha256:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: DigestSheme.Sha256" href="libp2p/crypto/crypto.html#Sha256">crypto: DigestSheme.Sha256</a></li>
          </ul></dd>
<dt><a name="Sha512" href="#Sha512"><span>Sha512:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: DigestSheme.Sha512" href="libp2p/crypto/crypto.html#Sha512">crypto: DigestSheme.Sha512</a></li>
          </ul></dd>
<dt><a name="shift" href="#shift"><span>shift:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mcache: proc shift(c: var MCache)" href="libp2p/protocols/pubsub/mcache.html#shift%2CMCache">mcache: proc shift(c: var MCache)</a></li>
          </ul></dd>
<dt><a name="shortLog" href="#shortLog"><span>shortLog:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc shortLog(key: PrivateKey | PublicKey): string" href="libp2p/crypto/crypto.html#shortLog">crypto: proc shortLog(key: PrivateKey | PublicKey): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpchannel: proc shortLog(s: LPChannel): auto" href="libp2p/muxers/mplex/lpchannel.html#shortLog%2CLPChannel">lpchannel: proc shortLog(s: LPChannel): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="mplex: proc shortLog(m: Mplex): auto" href="libp2p/muxers/mplex/mplex.html#shortLog%2CMplex">mplex: proc shortLog(m: Mplex): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxer: proc shortLog(m: Muxer): auto" href="libp2p/muxers/muxer.html#shortLog%2CMuxer">muxer: proc shortLog(m: Muxer): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc shortLog(pid: Opt[PeerId]): string" href="libp2p/peerid.html#shortLog%2COpt%5BPeerId%5D">peerid: proc shortLog(pid: Opt[PeerId]): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc shortLog(pid: PeerId): string" href="libp2p/peerid.html#shortLog%2CPeerId">peerid: proc shortLog(pid: PeerId): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerinfo: proc shortLog(p: PeerInfo): auto" href="libp2p/peerinfo.html#shortLog%2CPeerInfo">peerinfo: proc shortLog(p: PeerInfo): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc shortLog(k: Key): string" href="libp2p/protocols/kademlia/types.html#shortLog%2CKey">types: proc shortLog(k: Key): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc shortLog(p: PubSubPeer): string" href="libp2p/protocols/pubsub/pubsubpeer.html#shortLog%2CPubSubPeer">pubsubpeer: proc shortLog(p: PubSubPeer): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(s: ControlGraft): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CControlGraft">messages: proc shortLog(s: ControlGraft): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(s: ControlIHave): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CControlIHave">messages: proc shortLog(s: ControlIHave): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(s: ControlIMReceiving): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CControlIMReceiving">messages: proc shortLog(s: ControlIMReceiving): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(s: ControlIWant): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CControlIWant">messages: proc shortLog(s: ControlIWant): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(c: ControlMessage): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CControlMessage">messages: proc shortLog(c: ControlMessage): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(s: ControlPreamble): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CControlPreamble">messages: proc shortLog(s: ControlPreamble): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(s: ControlPrune): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CControlPrune">messages: proc shortLog(s: ControlPrune): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(msg: Message): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CMessage">messages: proc shortLog(msg: Message): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="messages: proc shortLog(m: RPCMsg): auto" href="libp2p/protocols/pubsub/rpc/messages.html#shortLog%2CRPCMsg">messages: proc shortLog(m: RPCMsg): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="noise: proc shortLog(conn: NoiseConnection): auto" href="libp2p/protocols/secure/noise.html#shortLog%2CNoiseConnection">noise: proc shortLog(conn: NoiseConnection): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secure: proc shortLog(conn: SecureConn): auto" href="libp2p/protocols/secure/secure.html#shortLog%2CSecureConn">secure: proc shortLog(conn: SecureConn): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bufferstream: proc shortLog(s: BufferStream): auto" href="libp2p/stream/bufferstream.html#shortLog%2CBufferStream">bufferstream: proc shortLog(s: BufferStream): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: proc shortLog(conn: ChronosStream): auto" href="libp2p/stream/chronosstream.html#shortLog%2CChronosStream">chronosstream: proc shortLog(conn: ChronosStream): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="connection: proc shortLog(conn: Connection): string" href="libp2p/stream/connection.html#shortLog%2CConnection">connection: proc shortLog(conn: Connection): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: proc shortLog(s: LPStream): auto" href="libp2p/stream/lpstream.html#shortLog%2CLPStream">lpstream: proc shortLog(s: LPStream): auto</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utility: proc shortLog(item: openArray[byte]): string" href="libp2p/utility.html#shortLog%2CopenArray%5Bbyte%5D">utility: proc shortLog(item: openArray[byte]): string</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utility: proc shortLog(item: string): string" href="libp2p/utility.html#shortLog%2Cstring">utility: proc shortLog(item: string): string</a></li>
          </ul></dd>
<dt><a name="shuffle" href="#shuffle"><span>shuffle:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc shuffle[T](rng: ref HmacDrbgContext; x: var openArray[T])" href="libp2p/crypto/crypto.html#shuffle%2Cref.HmacDrbgContext%2CopenArray%5BT%5D">crypto: proc shuffle[T](rng: ref HmacDrbgContext; x: var openArray[T])</a></li>
          </ul></dd>
<dt><a name="Sig256Length" href="#Sig256Length"><span>Sig256Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const Sig256Length" href="libp2p/crypto/ecnist.html#Sig256Length">ecnist: const Sig256Length</a></li>
          </ul></dd>
<dt><a name="Sig384Length" href="#Sig384Length"><span>Sig384Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const Sig384Length" href="libp2p/crypto/ecnist.html#Sig384Length">ecnist: const Sig384Length</a></li>
          </ul></dd>
<dt><a name="Sig521Length" href="#Sig521Length"><span>Sig521Length:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: const Sig521Length" href="libp2p/crypto/ecnist.html#Sig521Length">ecnist: const Sig521Length</a></li>
          </ul></dd>
<dt><a name="SigError" href="#SigError"><span>SigError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: CryptoError.SigError" href="libp2p/crypto/crypto.html#SigError">crypto: CryptoError.SigError</a></li>
          </ul></dd>
<dt><a name="sign" href="#sign"><span>sign:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc sign(key: PrivateKey; data: openArray[byte]): CryptoResult[Signature]" href="libp2p/crypto/crypto.html#sign%2CPrivateKey%2CopenArray%5Bbyte%5D">crypto: proc sign(key: PrivateKey; data: openArray[byte]): CryptoResult[Signature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc sign[T: byte | char](seckey: EcPrivateKey; message: openArray[T]): EcResult[
    EcSignature]" href="libp2p/crypto/ecnist.html#sign%2CEcPrivateKey%2CopenArray%5BT%5D">ecnist: proc sign[T: byte | char](seckey: EcPrivateKey; message: openArray[T]): EcResult[
    EcSignature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc sign[T: byte | char](key: EdPrivateKey; message: openArray[T]): EdSignature" href="libp2p/crypto/ed25519/ed25519.html#sign%2CEdPrivateKey%2CopenArray%5BT%5D">ed25519: proc sign[T: byte | char](key: EdPrivateKey; message: openArray[T]): EdSignature</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc sign[T: byte | char](key: RsaPrivateKey; message: openArray[T]): RsaResult[
    RsaSignature]" href="libp2p/crypto/rsa.html#sign%2CRsaPrivateKey%2CopenArray%5BT%5D">rsa: proc sign[T: byte | char](key: RsaPrivateKey; message: openArray[T]): RsaResult[
    RsaSignature]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc sign[T: byte | char](key: SkPrivateKey; msg: openArray[T]): SkSignature" href="libp2p/crypto/secp.html#sign%2CSkPrivateKey%2CopenArray%5BT%5D">secp: proc sign[T: byte | char](key: SkPrivateKey; msg: openArray[T]): SkSignature</a></li>
          <li><a class="reference external"
          data-doc-search-tag="message: proc sign(msg: Message; privateKey: PrivateKey): CryptoResult[seq[byte]]" href="libp2p/protocols/pubsub/rpc/message.html#sign%2CMessage%2CPrivateKey">message: proc sign(msg: Message; privateKey: PrivateKey): CryptoResult[seq[byte]]</a></li>
          </ul></dd>
<dt><a name="Signature" href="#Signature"><span>Signature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: object Signature" href="libp2p/crypto/crypto.html#Signature">crypto: object Signature</a></li>
          </ul></dd>
<dt><a name="SignedPayload" href="#SignedPayload"><span>SignedPayload:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="signed_envelope: object SignedPayload" href="libp2p/signed_envelope.html#SignedPayload">signed_envelope: object SignedPayload</a></li>
          </ul></dd>
<dt><a name="SignedPeerRecord" href="#SignedPeerRecord"><span>SignedPeerRecord:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="routing_record: type SignedPeerRecord" href="libp2p/routing_record.html#SignedPeerRecord">routing_record: type SignedPeerRecord</a></li>
          </ul></dd>
<dt><a name="SignedVoucher" href="#SignedVoucher"><span>SignedVoucher:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: type SignedVoucher" href="libp2p/protocols/connectivity/relay/messages.html#SignedVoucher">messages: type SignedVoucher</a></li>
          </ul></dd>
<dt><a name="SkKeyPair" href="#SkKeyPair"><span>SkKeyPair:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secp: type SkKeyPair" href="libp2p/crypto/secp.html#SkKeyPair">secp: type SkKeyPair</a></li>
          </ul></dd>
<dt><a name="SkPrivateKey" href="#SkPrivateKey"><span>SkPrivateKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secp: type SkPrivateKey" href="libp2p/crypto/secp.html#SkPrivateKey">secp: type SkPrivateKey</a></li>
          </ul></dd>
<dt><a name="SkPublicKey" href="#SkPublicKey"><span>SkPublicKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secp: type SkPublicKey" href="libp2p/crypto/secp.html#SkPublicKey">secp: type SkPublicKey</a></li>
          </ul></dd>
<dt><a name="SkRawPrivateKeySize" href="#SkRawPrivateKeySize"><span>SkRawPrivateKeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secp: const SkRawPrivateKeySize" href="libp2p/crypto/secp.html#SkRawPrivateKeySize">secp: const SkRawPrivateKeySize</a></li>
          </ul></dd>
<dt><a name="SkRawPublicKeySize" href="#SkRawPublicKeySize"><span>SkRawPublicKeySize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secp: const SkRawPublicKeySize" href="libp2p/crypto/secp.html#SkRawPublicKeySize">secp: const SkRawPublicKeySize</a></li>
          </ul></dd>
<dt><a name="SkRawSignatureSize" href="#SkRawSignatureSize"><span>SkRawSignatureSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secp: const SkRawSignatureSize" href="libp2p/crypto/secp.html#SkRawSignatureSize">secp: const SkRawSignatureSize</a></li>
          </ul></dd>
<dt><a name="SkSignature" href="#SkSignature"><span>SkSignature:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="secp: type SkSignature" href="libp2p/crypto/secp.html#SkSignature">secp: type SkSignature</a></li>
          </ul></dd>
<dt><a name="slotsAvailable" href="#slotsAvailable"><span>slotsAvailable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc slotsAvailable(c: ConnManager; dir: Direction): int" href="libp2p/connmanager.html#slotsAvailable%2CConnManager%2CDirection">connmanager: proc slotsAvailable(c: ConnManager; dir: Direction): int</a></li>
          </ul></dd>
<dt><a name="SomeUVarint" href="#SomeUVarint"><span>SomeUVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type SomeUVarint" href="libp2p/varint.html#SomeUVarint">varint: type SomeUVarint</a></li>
          </ul></dd>
<dt><a name="SomeVarint" href="#SomeVarint"><span>SomeVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type SomeVarint" href="libp2p/varint.html#SomeVarint">varint: type SomeVarint</a></li>
          </ul></dd>
<dt><a name="SPRBook" href="#SPRBook"><span>SPRBook:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: type SPRBook" href="libp2p/peerstore.html#SPRBook">peerstore: type SPRBook</a></li>
          </ul></dd>
<dt><a name="SqrTm1" href="#SqrTm1"><span>SqrTm1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: const SqrTm1" href="libp2p/crypto/ed25519/constants.html#SqrTm1">constants: const SqrTm1</a></li>
          </ul></dd>
<dt><a name="start" href="#start"><span>start:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: proc start(m: MultistreamSelect): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/multistream.html#start%2CMultistreamSelect">multistream: proc start(m: MultistreamSelect): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="relay: method start(r: Relay): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/connectivity/relay/relay.html#start.e%2CRelay">relay: method start(r: Relay): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rtransport: method start(self: RelayTransport; ma: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]" href="libp2p/protocols/connectivity/relay/rtransport.html#start.e%2CRelayTransport%2Cseq%5BMultiAddress%5D">rtransport: method start(self: RelayTransport; ma: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="kademlia: method start(kad: KadDHT): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/kademlia.html#start.e%2CKadDHT">kademlia: method start(kad: KadDHT): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protocol: method start(p: LPProtocol): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/protocol.html#start.e%2CLPProtocol">protocol: method start(p: LPProtocol): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: method start(g: GossipSub): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/protocols/pubsub/gossipsub.html#start.e%2CGossipSub">gossipsub: method start(g: GossipSub): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: method start[E](rdv: GenericRendezVous[E]): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/rendezvous/rendezvous.html#start.e%2CGenericRendezVous%5BE%5D">rendezvous: method start[E](rdv: GenericRendezVous[E]): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc start(s: Switch): InternalRaisesFuture[void, (CancelledError, LPError)]" href="libp2p/switch.html#start%2CSwitch">switch: proc start(s: Switch): InternalRaisesFuture[void, (CancelledError, LPError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: method start(self: MemoryTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[
    void, (LPError, TransportError, CancelledError)]" href="libp2p/transports/memorytransport.html#start.e%2CMemoryTransport%2Cseq%5BMultiAddress%5D">memorytransport: method start(self: MemoryTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[
    void, (LPError, TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method start(self: QuicTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]" href="libp2p/transports/quictransport.html#start.e%2CQuicTransport%2Cseq%5BMultiAddress%5D">quictransport: method start(self: QuicTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="tcptransport: method start(self: TcpTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]" href="libp2p/transports/tcptransport.html#start.e%2CTcpTransport%2Cseq%5BMultiAddress%5D">tcptransport: method start(self: TcpTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="transport: method start(self: Transport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]" href="libp2p/transports/transport.html#start.e%2CTransport%2Cseq%5BMultiAddress%5D">transport: method start(self: Transport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method start(self: WsTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]" href="libp2p/transports/wstransport.html#start.e%2CWsTransport%2Cseq%5BMultiAddress%5D">wstransport: method start(self: WsTransport; addrs: seq[MultiAddress]): InternalRaisesFuture[void,
    (LPError, TransportError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="StartGroup" href="#StartGroup"><span>StartGroup:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFieldKind.StartGroup" href="libp2p/protobuf/minprotobuf.html#StartGroup">minprotobuf: ProtoFieldKind.StartGroup</a></li>
          </ul></dd>
<dt><a name="startProviding" href="#startProviding"><span>startProviding:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc startProviding(kad: KadDHT; c: Cid): InternalRaisesFuture[void,
    (CancelledError,)]" href="libp2p/protocols/kademlia/provider.html#startProviding%2CKadDHT%2CCid">provider: proc startProviding(kad: KadDHT; c: Cid): InternalRaisesFuture[void,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="StatusAndConfidenceHandler" href="#StatusAndConfidenceHandler"><span>StatusAndConfidenceHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="service: type StatusAndConfidenceHandler" href="libp2p/protocols/connectivity/autonatv2/service.html#StatusAndConfidenceHandler">service: type StatusAndConfidenceHandler</a></li>
          </ul></dd>
<dt><a name="StatusV1" href="#StatusV1"><span>StatusV1:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: enum StatusV1" href="libp2p/protocols/connectivity/relay/messages.html#StatusV1">messages: enum StatusV1</a></li>
          </ul></dd>
<dt><a name="StatusV2" href="#StatusV2"><span>StatusV2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: enum StatusV2" href="libp2p/protocols/connectivity/relay/messages.html#StatusV2">messages: enum StatusV2</a></li>
          </ul></dd>
<dt><a name="stop" href="#stop"><span>stop:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multistream: proc stop(m: MultistreamSelect): InternalRaisesFuture[void, void]" href="libp2p/multistream.html#stop%2CMultistreamSelect">multistream: proc stop(m: MultistreamSelect): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="service: method stop(self: AutonatV2Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]" href="libp2p/protocols/connectivity/autonatv2/service.html#stop.e%2CAutonatV2Service%2CSwitch">service: method stop(self: AutonatV2Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="relay: method stop(r: Relay): InternalRaisesFuture[void, void]" href="libp2p/protocols/connectivity/relay/relay.html#stop.e%2CRelay">relay: method stop(r: Relay): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rtransport: method stop(self: RelayTransport): InternalRaisesFuture[void, void]" href="libp2p/protocols/connectivity/relay/rtransport.html#stop.e%2CRelayTransport">rtransport: method stop(self: RelayTransport): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="kademlia: method stop(kad: KadDHT): InternalRaisesFuture[void, void]" href="libp2p/protocols/kademlia.html#stop.e%2CKadDHT">kademlia: method stop(kad: KadDHT): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protocol: method stop(p: LPProtocol): InternalRaisesFuture[void, void]" href="libp2p/protocols/protocol.html#stop.e%2CLPProtocol">protocol: method stop(p: LPProtocol): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: method stop(g: GossipSub): InternalRaisesFuture[void, void]" href="libp2p/protocols/pubsub/gossipsub.html#stop.e%2CGossipSub">gossipsub: method stop(g: GossipSub): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: method stop[E](rdv: GenericRendezVous[E]): InternalRaisesFuture[void, void]" href="libp2p/protocols/rendezvous/rendezvous.html#stop.e%2CGenericRendezVous%5BE%5D">rendezvous: method stop[E](rdv: GenericRendezVous[E]): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wildcardresolverservice: method stop(self: WildcardAddressResolverService; switch: Switch): InternalRaisesFuture[
    bool, (CancelledError,)]" href="libp2p/services/wildcardresolverservice.html#stop.e%2CWildcardAddressResolverService%2CSwitch">wildcardresolverservice: method stop(self: WildcardAddressResolverService; switch: Switch): InternalRaisesFuture[
    bool, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: proc stop(s: Switch): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/switch.html#stop%2CSwitch">switch: proc stop(s: Switch): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="switch: method stop(self: Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]" href="libp2p/switch.html#stop.e%2CService%2CSwitch">switch: method stop(self: Service; switch: Switch): InternalRaisesFuture[bool,
    (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="memorytransport: method stop(self: MemoryTransport): InternalRaisesFuture[void, void]" href="libp2p/transports/memorytransport.html#stop.e%2CMemoryTransport">memorytransport: method stop(self: MemoryTransport): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method stop(transport: QuicTransport): InternalRaisesFuture[void, void]" href="libp2p/transports/quictransport.html#stop.e%2CQuicTransport">quictransport: method stop(transport: QuicTransport): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="tcptransport: method stop(self: TcpTransport): InternalRaisesFuture[void, void]" href="libp2p/transports/tcptransport.html#stop.e%2CTcpTransport">tcptransport: method stop(self: TcpTransport): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="transport: method stop(self: Transport): InternalRaisesFuture[void, void]" href="libp2p/transports/transport.html#stop.e%2CTransport">transport: method stop(self: Transport): InternalRaisesFuture[void, void]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method stop(self: WsTransport): InternalRaisesFuture[void, void]" href="libp2p/transports/wstransport.html#stop.e%2CWsTransport">wstransport: method stop(self: WsTransport): InternalRaisesFuture[void, void]</a></li>
          </ul></dd>
<dt><a name="StopMessage" href="#StopMessage"><span>StopMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object StopMessage" href="libp2p/protocols/connectivity/relay/messages.html#StopMessage">messages: object StopMessage</a></li>
          </ul></dd>
<dt><a name="StopMessageType" href="#StopMessageType"><span>StopMessageType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: enum StopMessageType" href="libp2p/protocols/connectivity/relay/messages.html#StopMessageType">messages: enum StopMessageType</a></li>
          </ul></dd>
<dt><a name="stopProviding" href="#stopProviding"><span>stopProviding:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="provider: proc stopProviding(kad: KadDHT; c: Cid)" href="libp2p/protocols/kademlia/provider.html#stopProviding%2CKadDHT%2CCid">provider: proc stopProviding(kad: KadDHT; c: Cid)</a></li>
          </ul></dd>
<dt><a name="stopSendNonPriorityTask" href="#stopSendNonPriorityTask"><span>stopSendNonPriorityTask:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc stopSendNonPriorityTask(p: PubSubPeer)" href="libp2p/protocols/pubsub/pubsubpeer.html#stopSendNonPriorityTask%2CPubSubPeer">pubsubpeer: proc stopSendNonPriorityTask(p: PubSubPeer)</a></li>
          </ul></dd>
<dt><a name="storeMuxer" href="#storeMuxer"><span>storeMuxer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc storeMuxer(c: ConnManager; muxer: Muxer)" href="libp2p/connmanager.html#storeMuxer%2CConnManager%2CMuxer">connmanager: proc storeMuxer(c: ConnManager; muxer: Muxer)</a></li>
          </ul></dd>
<dt><a name="StreamHandler" href="#StreamHandler"><span>StreamHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: type StreamHandler" href="libp2p/muxers/muxer.html#StreamHandler">muxer: type StreamHandler</a></li>
          </ul></dd>
<dt><a name="StreamTracker" href="#StreamTracker"><span>StreamTracker:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: type StreamTracker" href="libp2p/stream/lpstream.html#StreamTracker">lpstream: type StreamTracker</a></li>
          </ul></dd>
<dt><a name="stretchKeys" href="#stretchKeys"><span>stretchKeys:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc stretchKeys(cipherType: string; hashType: string; sharedSecret: seq[byte]): Secret" href="libp2p/crypto/crypto.html#stretchKeys%2Cstring%2Cstring%2Cseq%5Bbyte%5D">crypto: proc stretchKeys(cipherType: string; hashType: string; sharedSecret: seq[byte]): Secret</a></li>
          </ul></dd>
<dt><a name="SubOpts" href="#SubOpts"><span>SubOpts:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object SubOpts" href="libp2p/protocols/pubsub/rpc/messages.html#SubOpts">messages: object SubOpts</a></li>
          </ul></dd>
<dt><a name="subscribe" href="#subscribe"><span>subscribe:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc subscribe(p: PubSub; topic: string; handler: TopicHandler)" href="libp2p/protocols/pubsub/pubsub.html#subscribe%2CPubSub%2Cstring%2CTopicHandler">pubsub: proc subscribe(p: PubSub; topic: string; handler: TopicHandler)</a></li>
          </ul></dd>
<dt><a name="subscribePeer" href="#subscribePeer"><span>subscribePeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: method subscribePeer(p: PubSub; peer: PeerId)" href="libp2p/protocols/pubsub/pubsub.html#subscribePeer.e%2CPubSub%2CPeerId">pubsub: method subscribePeer(p: PubSub; peer: PeerId)</a></li>
          </ul></dd>
<dt><a name="SubscriptionValidator" href="#SubscriptionValidator"><span>SubscriptionValidator:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type SubscriptionValidator" href="libp2p/protocols/pubsub/pubsub.html#SubscriptionValidator">pubsub: type SubscriptionValidator</a></li>
          </ul></dd>
<dt><a name="supported" href="#supported"><span>supported:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: template supported(scheme: PKScheme): bool" href="libp2p/crypto/crypto.html#supported.t%2CPKScheme">crypto: template supported(scheme: PKScheme): bool</a></li>
          </ul></dd>
<dt><a name="SupportedSchemes" href="#SupportedSchemes"><span>SupportedSchemes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: const SupportedSchemes" href="libp2p/crypto/crypto.html#SupportedSchemes">crypto: const SupportedSchemes</a></li>
          </ul></dd>
<dt><a name="SupportedSchemesInt" href="#SupportedSchemesInt"><span>SupportedSchemesInt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: const SupportedSchemesInt" href="libp2p/crypto/crypto.html#SupportedSchemesInt">crypto: const SupportedSchemesInt</a></li>
          </ul></dd>
<dt><a name="SupportedWireTypes" href="#SupportedWireTypes"><span>SupportedWireTypes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: const SupportedWireTypes" href="libp2p/protobuf/minprotobuf.html#SupportedWireTypes">minprotobuf: const SupportedWireTypes</a></li>
          </ul></dd>
<dt><a name="Switch" href="#Switch"><span>Switch:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: type Switch" href="libp2p/switch.html#Switch">switch: type Switch</a></li>
          </ul></dd>
<dt><a name="SwitchBuilder" href="#SwitchBuilder"><span>SwitchBuilder:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: type SwitchBuilder" href="libp2p/builders.html#SwitchBuilder">builders: type SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="TCP" href="#TCP"><span>TCP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TCP" href="libp2p/multiaddress.html#TCP">multiaddress: const TCP</a></li>
          </ul></dd>
<dt><a name="TCP_DNS" href="#TCP_DNS"><span>TCP_DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TCP_DNS" href="libp2p/multiaddress.html#TCP_DNS">multiaddress: const TCP_DNS</a></li>
          </ul></dd>
<dt><a name="TCP_IP" href="#TCP_IP"><span>TCP_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TCP_IP" href="libp2p/multiaddress.html#TCP_IP">multiaddress: const TCP_IP</a></li>
          </ul></dd>
<dt><a name="TcpOnion3" href="#TcpOnion3"><span>TcpOnion3:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TcpOnion3" href="libp2p/multiaddress.html#TcpOnion3">multiaddress: const TcpOnion3</a></li>
          </ul></dd>
<dt><a name="tcpProtocol" href="#tcpProtocol"><span>tcpProtocol:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: IpTransportProtocol.tcpProtocol" href="libp2p/multiaddress.html#tcpProtocol">multiaddress: IpTransportProtocol.tcpProtocol</a></li>
          </ul></dd>
<dt><a name="TcpTransport" href="#TcpTransport"><span>TcpTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="tcptransport: type TcpTransport" href="libp2p/transports/tcptransport.html#TcpTransport">tcptransport: type TcpTransport</a></li>
          </ul></dd>
<dt><a name="TcpTransportError" href="#TcpTransportError"><span>TcpTransportError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="tcptransport: object TcpTransportError" href="libp2p/transports/tcptransport.html#TcpTransportError">tcptransport: object TcpTransportError</a></li>
          </ul></dd>
<dt><a name="TcpTransportTrackerName" href="#TcpTransportTrackerName"><span>TcpTransportTrackerName:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="tcptransport: const TcpTransportTrackerName" href="libp2p/transports/tcptransport.html#TcpTransportTrackerName">tcptransport: const TcpTransportTrackerName</a></li>
          </ul></dd>
<dt><a name="TimedCache" href="#TimedCache"><span>TimedCache:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="timedcache: object TimedCache" href="libp2p/protocols/pubsub/timedcache.html#TimedCache">timedcache: object TimedCache</a></li>
          </ul></dd>
<dt><a name="TimedEntry" href="#TimedEntry"><span>TimedEntry:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="timedcache: type TimedEntry" href="libp2p/protocols/pubsub/timedcache.html#TimedEntry">timedcache: type TimedEntry</a></li>
          </ul></dd>
<dt><a name="Timeout" href="#Timeout"><span>Timeout:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="timedcache: const Timeout" href="libp2p/protocols/pubsub/timedcache.html#Timeout">timedcache: const Timeout</a></li>
          </ul></dd>
<dt><a name="TimeoutHandler" href="#TimeoutHandler"><span>TimeoutHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connection: type TimeoutHandler" href="libp2p/stream/connection.html#TimeoutHandler">connection: type TimeoutHandler</a></li>
          </ul></dd>
<dt><a name="TimeStamp" href="#TimeStamp"><span>TimeStamp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type TimeStamp" href="libp2p/protocols/kademlia/types.html#TimeStamp">types: type TimeStamp</a></li>
          </ul></dd>
<dt><a name="TLSCertificateError" href="#TLSCertificateError"><span>TLSCertificateError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="certificate: object TLSCertificateError" href="libp2p/transports/tls/certificate.html#TLSCertificateError">certificate: object TLSCertificateError</a></li>
          </ul></dd>
<dt><a name="TLS_WS" href="#TLS_WS"><span>TLS_WS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TLS_WS" href="libp2p/multiaddress.html#TLS_WS">multiaddress: const TLS_WS</a></li>
          </ul></dd>
<dt><a name="toBytes" href="#toBytes"><span>toBytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc toBytes(key: PrivateKey; data: var openArray[byte]): CryptoResult[int]" href="libp2p/crypto/crypto.html#toBytes%2CPrivateKey%2CopenArray%5Bbyte%5D">crypto: proc toBytes(key: PrivateKey; data: var openArray[byte]): CryptoResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc toBytes(key: PublicKey; data: var openArray[byte]): CryptoResult[int]" href="libp2p/crypto/crypto.html#toBytes%2CPublicKey%2CopenArray%5Bbyte%5D">crypto: proc toBytes(key: PublicKey; data: var openArray[byte]): CryptoResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc toBytes(sig: Signature; data: var openArray[byte]): int" href="libp2p/crypto/crypto.html#toBytes%2CSignature%2CopenArray%5Bbyte%5D">crypto: proc toBytes(sig: Signature; data: var openArray[byte]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc toBytes(seckey: EcPrivateKey; data: var openArray[byte]): EcResult[int]" href="libp2p/crypto/ecnist.html#toBytes%2CEcPrivateKey%2CopenArray%5Bbyte%5D">ecnist: proc toBytes(seckey: EcPrivateKey; data: var openArray[byte]): EcResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc toBytes(pubkey: EcPublicKey; data: var openArray[byte]): EcResult[int]" href="libp2p/crypto/ecnist.html#toBytes%2CEcPublicKey%2CopenArray%5Bbyte%5D">ecnist: proc toBytes(pubkey: EcPublicKey; data: var openArray[byte]): EcResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc toBytes(sig: EcSignature; data: var openArray[byte]): EcResult[int]" href="libp2p/crypto/ecnist.html#toBytes%2CEcSignature%2CopenArray%5Bbyte%5D">ecnist: proc toBytes(sig: EcSignature; data: var openArray[byte]): EcResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc toBytes(key: EdPrivateKey; data: var openArray[byte]): int" href="libp2p/crypto/ed25519/ed25519.html#toBytes%2CEdPrivateKey%2CopenArray%5Bbyte%5D">ed25519: proc toBytes(key: EdPrivateKey; data: var openArray[byte]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc toBytes(key: EdPublicKey; data: var openArray[byte]): int" href="libp2p/crypto/ed25519/ed25519.html#toBytes%2CEdPublicKey%2CopenArray%5Bbyte%5D">ed25519: proc toBytes(key: EdPublicKey; data: var openArray[byte]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc toBytes(sig: EdSignature; data: var openArray[byte]): int" href="libp2p/crypto/ed25519/ed25519.html#toBytes%2CEdSignature%2CopenArray%5Bbyte%5D">ed25519: proc toBytes(sig: EdSignature; data: var openArray[byte]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc toBytes(key: RsaPrivateKey; data: var openArray[byte]): RsaResult[int]" href="libp2p/crypto/rsa.html#toBytes%2CRsaPrivateKey%2CopenArray%5Bbyte%5D">rsa: proc toBytes(key: RsaPrivateKey; data: var openArray[byte]): RsaResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc toBytes(key: RsaPublicKey; data: var openArray[byte]): RsaResult[int]" href="libp2p/crypto/rsa.html#toBytes%2CRsaPublicKey%2CopenArray%5Bbyte%5D">rsa: proc toBytes(key: RsaPublicKey; data: var openArray[byte]): RsaResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc toBytes(sig: RsaSignature; data: var openArray[byte]): RsaResult[int]" href="libp2p/crypto/rsa.html#toBytes%2CRsaSignature%2CopenArray%5Bbyte%5D">rsa: proc toBytes(sig: RsaSignature; data: var openArray[byte]): RsaResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc toBytes(key: SkPrivateKey; data: var openArray[byte]): SkResult[int]" href="libp2p/crypto/secp.html#toBytes%2CSkPrivateKey%2CopenArray%5Bbyte%5D">secp: proc toBytes(key: SkPrivateKey; data: var openArray[byte]): SkResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc toBytes(key: SkPublicKey; data: var openArray[byte]): SkResult[int]" href="libp2p/crypto/secp.html#toBytes%2CSkPublicKey%2CopenArray%5Bbyte%5D">secp: proc toBytes(key: SkPublicKey; data: var openArray[byte]): SkResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc toBytes(sig: SkSignature; data: var openArray[byte]): int" href="libp2p/crypto/secp.html#toBytes%2CSkSignature%2CopenArray%5Bbyte%5D">secp: proc toBytes(sig: SkSignature; data: var openArray[byte]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc toBytes(pid: PeerId; data: var openArray[byte]): int" href="libp2p/peerid.html#toBytes%2CPeerId%2CopenArray%5Bbyte%5D">peerid: proc toBytes(pid: PeerId; data: var openArray[byte]): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="varint: template toBytes(vtype: typedesc[PB]; value: PBSomeVarint): auto" href="libp2p/varint.html#toBytes.t%2Ctypedesc%5BPB%5D%2CPBSomeVarint">varint: template toBytes(vtype: typedesc[PB]; value: PBSomeVarint): auto</a></li>
          </ul></dd>
<dt><a name="toChunks" href="#toChunks"><span>toChunks:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: proc toChunks[T](data: seq[T]; size: int): seq[seq[T]]" href="libp2p/utility.html#toChunks%2Cseq%5BT%5D%2Cint">utility: proc toChunks[T](data: seq[T]; size: int): seq[seq[T]]</a></li>
          </ul></dd>
<dt><a name="toCid" href="#toCid"><span>toCid:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc toCid(k: Key): Cid" href="libp2p/protocols/kademlia/types.html#toCid%2CKey">types: proc toCid(k: Key): Cid</a></li>
          </ul></dd>
<dt><a name="toException" href="#toException"><span>toException:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="errors: proc toException(e: cstring): ref LPError" href="libp2p/errors.html#toException%2Ccstring">errors: proc toException(e: cstring): ref LPError</a></li>
          <li><a class="reference external"
          data-doc-search-tag="errors: proc toException(e: string): ref LPError" href="libp2p/errors.html#toException%2Cstring">errors: proc toException(e: string): ref LPError</a></li>
          </ul></dd>
<dt><a name="toFullAddress" href="#toFullAddress"><span>toFullAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: proc toFullAddress(peerId: PeerId; ma: MultiAddress): MaResult[MultiAddress]" href="libp2p/peerinfo.html#toFullAddress%2CPeerId%2CMultiAddress">peerinfo: proc toFullAddress(peerId: PeerId; ma: MultiAddress): MaResult[MultiAddress]</a></li>
          </ul></dd>
<dt><a name="toKey" href="#toKey"><span>toKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc toKey(c: Cid): Key" href="libp2p/protocols/kademlia/types.html#toKey%2CCid">types: proc toKey(c: Cid): Key</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc toKey(mh: MultiHash): Key" href="libp2p/protocols/kademlia/types.html#toKey%2CMultiHash">types: proc toKey(mh: MultiHash): Key</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc toKey(p: PeerId): Key" href="libp2p/protocols/kademlia/types.html#toKey%2CPeerId">types: proc toKey(p: PeerId): Key</a></li>
          </ul></dd>
<dt><a name="TooManyChannels" href="#TooManyChannels"><span>TooManyChannels:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="muxer: object TooManyChannels" href="libp2p/muxers/muxer.html#TooManyChannels">muxer: object TooManyChannels</a></li>
          </ul></dd>
<dt><a name="TooManyConnectionsError" href="#TooManyConnectionsError"><span>TooManyConnectionsError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: object TooManyConnectionsError" href="libp2p/connmanager.html#TooManyConnectionsError">connmanager: object TooManyConnectionsError</a></li>
          </ul></dd>
<dt><a name="toOpenArray" href="#toOpenArray"><span>toOpenArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minasn1: template toOpenArray(ab: Asn1Buffer): untyped" href="libp2p/crypto/minasn1.html#toOpenArray.t%2CAsn1Buffer">minasn1: template toOpenArray(ab: Asn1Buffer): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: template toOpenArray(ac: Asn1Composite): untyped" href="libp2p/crypto/minasn1.html#toOpenArray.t%2CAsn1Composite">minasn1: template toOpenArray(ac: Asn1Composite): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: template toOpenArray(af: Asn1Field): untyped" href="libp2p/crypto/minasn1.html#toOpenArray.t%2CAsn1Field">minasn1: template toOpenArray(af: Asn1Field): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: template toOpenArray(pb: ProtoBuffer): untyped" href="libp2p/protobuf/minprotobuf.html#toOpenArray.t%2CProtoBuffer">minprotobuf: template toOpenArray(pb: ProtoBuffer): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bytesview: template toOpenArray(v: BytesView; b, e: int): openArray[byte]" href="libp2p/utils/bytesview.html#toOpenArray.t%2CBytesView%2Cint%2Cint">bytesview: template toOpenArray(v: BytesView; b, e: int): openArray[byte]</a></li>
          </ul></dd>
<dt><a name="toOpt" href="#toOpt"><span>toOpt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: template toOpt[T, E](self: Result[T, E]): Opt[T]" href="libp2p/utility.html#toOpt.t%2CResult%5BT%2CE%5D">utility: template toOpt[T, E](self: Result[T, E]): Opt[T]</a></li>
          </ul></dd>
<dt><a name="toPeer" href="#toPeer"><span>toPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc toPeer(k: Key; switch: Switch): Result[Peer, string]" href="libp2p/protocols/kademlia/types.html#toPeer%2CKey%2CSwitch">types: proc toPeer(k: Key; switch: Switch): Result[Peer, string]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc toPeer(peerInfo: PeerInfo): Peer" href="libp2p/protocols/kademlia/types.html#toPeer%2CPeerInfo">types: proc toPeer(peerInfo: PeerInfo): Peer</a></li>
          </ul></dd>
<dt><a name="toPeerId" href="#toPeerId"><span>toPeerId:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc toPeerId(k: Key): Result[PeerId, string]" href="libp2p/protocols/kademlia/types.html#toPeerId%2CKey">types: proc toPeerId(k: Key): Result[PeerId, string]</a></li>
          </ul></dd>
<dt><a name="TopicHandler" href="#TopicHandler"><span>TopicHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type TopicHandler" href="libp2p/protocols/pubsub/pubsub.html#TopicHandler">pubsub: type TopicHandler</a></li>
          </ul></dd>
<dt><a name="TopicInfo" href="#TopicInfo"><span>TopicInfo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object TopicInfo" href="libp2p/protocols/pubsub/gossipsub/types.html#TopicInfo">types: object TopicInfo</a></li>
          </ul></dd>
<dt><a name="TopicPair" href="#TopicPair"><span>TopicPair:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: tuple TopicPair" href="libp2p/protocols/pubsub/pubsub.html#TopicPair">pubsub: tuple TopicPair</a></li>
          </ul></dd>
<dt><a name="TopicParams" href="#TopicParams"><span>TopicParams:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: object TopicParams" href="libp2p/protocols/pubsub/gossipsub/types.html#TopicParams">types: object TopicParams</a></li>
          </ul></dd>
<dt><a name="toRawBytes" href="#toRawBytes"><span>toRawBytes:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc toRawBytes(key: PrivateKey | PublicKey; data: var openArray[byte]): CryptoResult[
    int]" href="libp2p/crypto/crypto.html#toRawBytes%2C%2CopenArray%5Bbyte%5D">crypto: proc toRawBytes(key: PrivateKey | PublicKey; data: var openArray[byte]): CryptoResult[
    int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc toRawBytes(seckey: EcPrivateKey; data: var openArray[byte]): EcResult[int]" href="libp2p/crypto/ecnist.html#toRawBytes%2CEcPrivateKey%2CopenArray%5Bbyte%5D">ecnist: proc toRawBytes(seckey: EcPrivateKey; data: var openArray[byte]): EcResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc toRawBytes(pubkey: EcPublicKey; data: var openArray[byte]): EcResult[int]" href="libp2p/crypto/ecnist.html#toRawBytes%2CEcPublicKey%2CopenArray%5Bbyte%5D">ecnist: proc toRawBytes(pubkey: EcPublicKey; data: var openArray[byte]): EcResult[int]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc toRawBytes(sig: EcSignature; data: var openArray[byte]): int" href="libp2p/crypto/ecnist.html#toRawBytes%2CEcSignature%2CopenArray%5Bbyte%5D">ecnist: proc toRawBytes(sig: EcSignature; data: var openArray[byte]): int</a></li>
          </ul></dd>
<dt><a name="toSecret" href="#toSecret"><span>toSecret:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ecnist: proc toSecret(pubkey: EcPublicKey; seckey: EcPrivateKey; data: var openArray[byte]): int" href="libp2p/crypto/ecnist.html#toSecret%2CEcPublicKey%2CEcPrivateKey%2CopenArray%5Bbyte%5D">ecnist: proc toSecret(pubkey: EcPublicKey; seckey: EcPrivateKey; data: var openArray[byte]): int</a></li>
          </ul></dd>
<dt><a name="toString" href="#toString"><span>toString:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: proc toString(value: MultiAddress): MaResult[string]" href="libp2p/multiaddress.html#toString%2CMultiAddress">multiaddress: proc toString(value: MultiAddress): MaResult[string]</a></li>
          </ul></dd>
<dt><a name="trackConnection" href="#trackConnection"><span>trackConnection:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc trackConnection(cs: ConnectionSlot; conn: Connection)" href="libp2p/connmanager.html#trackConnection%2CConnectionSlot%2CConnection">connmanager: proc trackConnection(cs: ConnectionSlot; conn: Connection)</a></li>
          </ul></dd>
<dt><a name="trackMuxer" href="#trackMuxer"><span>trackMuxer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc trackMuxer(cs: ConnectionSlot; mux: Muxer)" href="libp2p/connmanager.html#trackMuxer%2CConnectionSlot%2CMuxer">connmanager: proc trackMuxer(cs: ConnectionSlot; mux: Muxer)</a></li>
          </ul></dd>
<dt><a name="Transcoder" href="#Transcoder"><span>Transcoder:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transcoder: object Transcoder" href="libp2p/transcoder.html#Transcoder">transcoder: object Transcoder</a></li>
          </ul></dd>
<dt><a name="TranscoderDNS" href="#TranscoderDNS"><span>TranscoderDNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderDNS" href="libp2p/multiaddress.html#TranscoderDNS">multiaddress: const TranscoderDNS</a></li>
          </ul></dd>
<dt><a name="TranscoderIP4" href="#TranscoderIP4"><span>TranscoderIP4:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderIP4" href="libp2p/multiaddress.html#TranscoderIP4">multiaddress: const TranscoderIP4</a></li>
          </ul></dd>
<dt><a name="TranscoderIP6" href="#TranscoderIP6"><span>TranscoderIP6:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderIP6" href="libp2p/multiaddress.html#TranscoderIP6">multiaddress: const TranscoderIP6</a></li>
          </ul></dd>
<dt><a name="TranscoderIP6Zone" href="#TranscoderIP6Zone"><span>TranscoderIP6Zone:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderIP6Zone" href="libp2p/multiaddress.html#TranscoderIP6Zone">multiaddress: const TranscoderIP6Zone</a></li>
          </ul></dd>
<dt><a name="TranscoderMemory" href="#TranscoderMemory"><span>TranscoderMemory:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderMemory" href="libp2p/multiaddress.html#TranscoderMemory">multiaddress: const TranscoderMemory</a></li>
          </ul></dd>
<dt><a name="TranscoderOnion" href="#TranscoderOnion"><span>TranscoderOnion:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderOnion" href="libp2p/multiaddress.html#TranscoderOnion">multiaddress: const TranscoderOnion</a></li>
          </ul></dd>
<dt><a name="TranscoderOnion3" href="#TranscoderOnion3"><span>TranscoderOnion3:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderOnion3" href="libp2p/multiaddress.html#TranscoderOnion3">multiaddress: const TranscoderOnion3</a></li>
          </ul></dd>
<dt><a name="TranscoderP2P" href="#TranscoderP2P"><span>TranscoderP2P:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderP2P" href="libp2p/multiaddress.html#TranscoderP2P">multiaddress: const TranscoderP2P</a></li>
          </ul></dd>
<dt><a name="TranscoderPort" href="#TranscoderPort"><span>TranscoderPort:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderPort" href="libp2p/multiaddress.html#TranscoderPort">multiaddress: const TranscoderPort</a></li>
          </ul></dd>
<dt><a name="TranscoderUnix" href="#TranscoderUnix"><span>TranscoderUnix:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const TranscoderUnix" href="libp2p/multiaddress.html#TranscoderUnix">multiaddress: const TranscoderUnix</a></li>
          </ul></dd>
<dt><a name="TRANSPMA" href="#TRANSPMA"><span>TRANSPMA:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wire: const TRANSPMA" href="libp2p/wire.html#TRANSPMA">wire: const TRANSPMA</a></li>
          </ul></dd>
<dt><a name="Transport" href="#Transport"><span>Transport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: type Transport" href="libp2p/transports/transport.html#Transport">transport: type Transport</a></li>
          </ul></dd>
<dt><a name="TransportBuilder" href="#TransportBuilder"><span>TransportBuilder:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: type TransportBuilder" href="libp2p/builders.html#TransportBuilder">builders: type TransportBuilder</a></li>
          </ul></dd>
<dt><a name="TransportClosedError" href="#TransportClosedError"><span>TransportClosedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: object TransportClosedError" href="libp2p/transports/transport.html#TransportClosedError">transport: object TransportClosedError</a></li>
          </ul></dd>
<dt><a name="TransportConfig" href="#TransportConfig"><span>TransportConfig:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: type TransportConfig" href="libp2p/builders.html#TransportConfig">builders: type TransportConfig</a></li>
          </ul></dd>
<dt><a name="TransportDialError" href="#TransportDialError"><span>TransportDialError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: object TransportDialError" href="libp2p/transports/transport.html#TransportDialError">transport: object TransportDialError</a></li>
          </ul></dd>
<dt><a name="TransportError" href="#TransportError"><span>TransportError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: object TransportError" href="libp2p/transports/transport.html#TransportError">transport: object TransportError</a></li>
          </ul></dd>
<dt><a name="TransportInvalidAddrError" href="#TransportInvalidAddrError"><span>TransportInvalidAddrError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="transport: object TransportInvalidAddrError" href="libp2p/transports/transport.html#TransportInvalidAddrError">transport: object TransportInvalidAddrError</a></li>
          </ul></dd>
<dt><a name="TransportProvider" href="#TransportProvider"><span>TransportProvider:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: type TransportProvider" href="libp2p/builders.html#TransportProvider">builders: type TransportProvider</a></li>
          </ul></dd>
<dt><a name="TransportType" href="#TransportType"><span>TransportType:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: enum TransportType" href="libp2p/builders.html#TransportType">builders: enum TransportType</a></li>
          </ul></dd>
<dt><a name="triggerConnEvent" href="#triggerConnEvent"><span>triggerConnEvent:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc triggerConnEvent(c: ConnManager; peerId: PeerId; event: ConnEvent): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/connmanager.html#triggerConnEvent%2CConnManager%2CPeerId%2CConnEvent">connmanager: proc triggerConnEvent(c: ConnManager; peerId: PeerId; event: ConnEvent): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="triggerPeerEvents" href="#triggerPeerEvents"><span>triggerPeerEvents:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="connmanager: proc triggerPeerEvents(c: ConnManager; peerId: PeerId; event: PeerEvent): InternalRaisesFuture[
    void, (CancelledError,)]" href="libp2p/connmanager.html#triggerPeerEvents%2CConnManager%2CPeerId%2CPeerEvent">connmanager: proc triggerPeerEvents(c: ConnManager; peerId: PeerId; event: PeerEvent): InternalRaisesFuture[
    void, (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="tryDial" href="#tryDial"><span>tryDial:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="dial: method tryDial(self: Dial; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    Opt[MultiAddress], (DialFailedError, CancelledError)]" href="libp2p/dial.html#tryDial.e%2CDial%2CPeerId%2Cseq%5BMultiAddress%5D">dial: method tryDial(self: Dial; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    Opt[MultiAddress], (DialFailedError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="dialer: method tryDial(self: Dialer; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    Opt[MultiAddress], (DialFailedError, CancelledError)]" href="libp2p/dialer.html#tryDial.e%2CDialer%2CPeerId%2Cseq%5BMultiAddress%5D">dialer: method tryDial(self: Dialer; peerId: PeerId; addrs: seq[MultiAddress]): InternalRaisesFuture[
    Opt[MultiAddress], (DialFailedError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="UDP" href="#UDP"><span>UDP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const UDP" href="libp2p/multiaddress.html#UDP">multiaddress: const UDP</a></li>
          </ul></dd>
<dt><a name="UDP_DNS" href="#UDP_DNS"><span>UDP_DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const UDP_DNS" href="libp2p/multiaddress.html#UDP_DNS">multiaddress: const UDP_DNS</a></li>
          </ul></dd>
<dt><a name="UDP_IP" href="#UDP_IP"><span>UDP_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const UDP_IP" href="libp2p/multiaddress.html#UDP_IP">multiaddress: const UDP_IP</a></li>
          </ul></dd>
<dt><a name="udpProtocol" href="#udpProtocol"><span>udpProtocol:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: IpTransportProtocol.udpProtocol" href="libp2p/multiaddress.html#udpProtocol">multiaddress: IpTransportProtocol.udpProtocol</a></li>
          </ul></dd>
<dt><a name="Unavailable" href="#Unavailable"><span>Unavailable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: ResponseStatus.Unavailable" href="libp2p/protocols/rendezvous/protobuf.html#Unavailable">protobuf: ResponseStatus.Unavailable</a></li>
          </ul></dd>
<dt><a name="UnexpectedMessage" href="#UnexpectedMessage"><span>UnexpectedMessage:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: StatusV2.UnexpectedMessage" href="libp2p/protocols/connectivity/relay/messages.html#UnexpectedMessage">messages: StatusV2.UnexpectedMessage</a></li>
          </ul></dd>
<dt><a name="UNIX" href="#UNIX"><span>UNIX:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const UNIX" href="libp2p/multiaddress.html#UNIX">multiaddress: const UNIX</a></li>
          </ul></dd>
<dt><a name="Unregister" href="#Unregister"><span>Unregister:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: object Unregister" href="libp2p/protocols/rendezvous/protobuf.html#Unregister">protobuf: object Unregister</a></li>
          </ul></dd>
<dt><a name="unregister" href="#unregister"><span>unregister:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc unregister[E](rdv: GenericRendezVous[E]; conn: Connection; u: Unregister)" href="libp2p/protocols/rendezvous/rendezvous.html#unregister%2CGenericRendezVous%5BE%5D%2CConnection%2CUnregister">rendezvous: proc unregister[E](rdv: GenericRendezVous[E]; conn: Connection; u: Unregister)</a></li>
          </ul></dd>
<dt><a name="Unreliable" href="#Unreliable"><span>Unreliable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const Unreliable" href="libp2p/multiaddress.html#Unreliable">multiaddress: const Unreliable</a></li>
          </ul></dd>
<dt><a name="unsubscribe" href="#unsubscribe"><span>unsubscribe:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc unsubscribe(p: PubSub; topics: openArray[TopicPair])" href="libp2p/protocols/pubsub/pubsub.html#unsubscribe%2CPubSub%2CopenArray%5BTopicPair%5D">pubsub: proc unsubscribe(p: PubSub; topics: openArray[TopicPair])</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: proc unsubscribe(p: PubSub; topic: string; handler: TopicHandler)" href="libp2p/protocols/pubsub/pubsub.html#unsubscribe%2CPubSub%2Cstring%2CTopicHandler">pubsub: proc unsubscribe(p: PubSub; topic: string; handler: TopicHandler)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: proc unsubscribe[E](rdv: GenericRendezVous[E]; ns: string): InternalRaisesFuture[
    void, (RendezVousError, CancelledError)]" href="libp2p/protocols/rendezvous/rendezvous.html#unsubscribe%2CGenericRendezVous%5BE%5D%2Cstring">rendezvous: proc unsubscribe[E](rdv: GenericRendezVous[E]; ns: string): InternalRaisesFuture[
    void, (RendezVousError, CancelledError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rendezvous: proc unsubscribe[E](rdv: GenericRendezVous[E]; ns: string; peerIds: seq[PeerId]): InternalRaisesFuture[
    void, (RendezVousError, CancelledError)]" href="libp2p/protocols/rendezvous/rendezvous.html#unsubscribe%2CGenericRendezVous%5BE%5D%2Cstring%2Cseq%5BPeerId%5D">rendezvous: proc unsubscribe[E](rdv: GenericRendezVous[E]; ns: string; peerIds: seq[PeerId]): InternalRaisesFuture[
    void, (RendezVousError, CancelledError)]</a></li>
          </ul></dd>
<dt><a name="unsubscribeAll" href="#unsubscribeAll"><span>unsubscribeAll:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc unsubscribeAll(p: PubSub; topic: string)" href="libp2p/protocols/pubsub/pubsub.html#unsubscribeAll%2CPubSub%2Cstring">pubsub: proc unsubscribeAll(p: PubSub; topic: string)</a></li>
          </ul></dd>
<dt><a name="unsubscribeLocally" href="#unsubscribeLocally"><span>unsubscribeLocally:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="rendezvous: proc unsubscribeLocally[E](rdv: GenericRendezVous[E]; ns: string)" href="libp2p/protocols/rendezvous/rendezvous.html#unsubscribeLocally%2CGenericRendezVous%5BE%5D%2Cstring">rendezvous: proc unsubscribeLocally[E](rdv: GenericRendezVous[E]; ns: string)</a></li>
          </ul></dd>
<dt><a name="unsubscribePeer" href="#unsubscribePeer"><span>unsubscribePeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="floodsub: method unsubscribePeer(f: FloodSub; peer: PeerId)" href="libp2p/protocols/pubsub/floodsub.html#unsubscribePeer.e%2CFloodSub%2CPeerId">floodsub: method unsubscribePeer(f: FloodSub; peer: PeerId)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: method unsubscribePeer(g: GossipSub; peer: PeerId)" href="libp2p/protocols/pubsub/gossipsub.html#unsubscribePeer.e%2CGossipSub%2CPeerId">gossipsub: method unsubscribePeer(g: GossipSub; peer: PeerId)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method unsubscribePeer(p: PubSub; peerId: PeerId)" href="libp2p/protocols/pubsub/pubsub.html#unsubscribePeer.e%2CPubSub%2CPeerId">pubsub: method unsubscribePeer(p: PubSub; peerId: PeerId)</a></li>
          </ul></dd>
<dt><a name="update" href="#update"><span>update:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerinfo: proc update(p: PeerInfo): InternalRaisesFuture[void, (CancelledError,)]" href="libp2p/peerinfo.html#update%2CPeerInfo">peerinfo: proc update(p: PeerInfo): InternalRaisesFuture[void, (CancelledError,)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bandwidth: proc update(e: var ExponentialMovingAverage; startAt: Moment; bytes: int)" href="libp2p/protocols/pubsub/bandwidth.html#update%2CExponentialMovingAverage%2CMoment%2Cint">bandwidth: proc update(e: var ExponentialMovingAverage; startAt: Moment; bytes: int)</a></li>
          </ul></dd>
<dt><a name="updateMetrics" href="#updateMetrics"><span>updateMetrics:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: proc updateMetrics(p: PubSub; rpcMsg: RPCMsg)" href="libp2p/protocols/pubsub/pubsub.html#updateMetrics%2CPubSub%2CRPCMsg">pubsub: proc updateMetrics(p: PubSub; rpcMsg: RPCMsg)</a></li>
          </ul></dd>
<dt><a name="updatePeerInfo" href="#updatePeerInfo"><span>updatePeerInfo:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="peerstore: proc updatePeerInfo(peerStore: PeerStore; info: IdentifyInfo;
               observedAddr: Opt[MultiAddress] = Opt.none(MultiAddress))" href="libp2p/peerstore.html#updatePeerInfo%2CPeerStore%2CIdentifyInfo%2COpt%5BMultiAddress%5D">peerstore: proc updatePeerInfo(peerStore: PeerStore; info: IdentifyInfo;
               observedAddr: Opt[MultiAddress] = Opt.none(MultiAddress))</a></li>
          </ul></dd>
<dt><a name="updateScores" href="#updateScores"><span>updateScores:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc updateScores(g: GossipSub)" href="libp2p/protocols/pubsub/gossipsub/scoring.html#updateScores%2CGossipSub">scoring: proc updateScores(g: GossipSub)</a></li>
          </ul></dd>
<dt><a name="updateShortlist" href="#updateShortlist"><span>updateShortlist:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lookupstate: proc updateShortlist(state: var LookupState; msg: Message;
                onInsert: proc (p: PeerInfo) {.gcsafe, raises: [].};
                hasher: Opt[XorDHasher])" href="libp2p/protocols/kademlia/lookupstate.html#updateShortlist%2CLookupState%2CMessage%2Cproc%28PeerInfo%29%2COpt%5BXorDHasher%5D">lookupstate: proc updateShortlist(state: var LookupState; msg: Message;
                onInsert: proc (p: PeerInfo) {.gcsafe, raises: [].};
                hasher: Opt[XorDHasher])</a></li>
          </ul></dd>
<dt><a name="upgrade" href="#upgrade"><span>upgrade:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="quictransport: method upgrade(self: QuicTransport; conn: P2PConnection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]" href="libp2p/transports/quictransport.html#upgrade.e%2CQuicTransport%2CP2PConnection%2COpt%5BPeerId%5D">quictransport: method upgrade(self: QuicTransport; conn: P2PConnection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="transport: method upgrade(self: Transport; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]" href="libp2p/transports/transport.html#upgrade.e%2CTransport%2CConnection%2COpt%5BPeerId%5D">transport: method upgrade(self: Transport; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="muxedupgrade: method upgrade(self: MuxedUpgrade; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]" href="libp2p/upgrademngrs/muxedupgrade.html#upgrade.e%2CMuxedUpgrade%2CConnection%2COpt%5BPeerId%5D">muxedupgrade: method upgrade(self: MuxedUpgrade; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]</a></li>
          </ul></dd>
<dt><a name="Upgrade" href="#Upgrade"><span>Upgrade:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="upgrade: type Upgrade" href="libp2p/upgrademngrs/upgrade.html#Upgrade">upgrade: type Upgrade</a></li>
          </ul></dd>
<dt><a name="upgrade" href="#upgrade"><span>upgrade:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="upgrade: method upgrade(self: Upgrade; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]" href="libp2p/upgrademngrs/upgrade.html#upgrade.e%2CUpgrade%2CConnection%2COpt%5BPeerId%5D">upgrade: method upgrade(self: Upgrade; conn: Connection; peerId: Opt[PeerId]): InternalRaisesFuture[
    Muxer, (CancelledError, LPError)]</a></li>
          </ul></dd>
<dt><a name="UpgradeError" href="#UpgradeError"><span>UpgradeError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="switch: object UpgradeError" href="libp2p/switch.html#UpgradeError">switch: object UpgradeError</a></li>
          </ul></dd>
<dt><a name="UpgradeFailedError" href="#UpgradeFailedError"><span>UpgradeFailedError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="upgrade: object UpgradeFailedError" href="libp2p/upgrademngrs/upgrade.html#UpgradeFailedError">upgrade: object UpgradeFailedError</a></li>
          </ul></dd>
<dt><a name="UTP" href="#UTP"><span>UTP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const UTP" href="libp2p/multiaddress.html#UTP">multiaddress: const UTP</a></li>
          </ul></dd>
<dt><a name="validate" href="#validate"><span>validate:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc validate(ctype: typedesc[Cid]; data: openArray[byte]): bool" href="libp2p/cid.html#validate%2Ctypedesc%5BCid%5D%2CopenArray%5Bbyte%5D">cid: proc validate(ctype: typedesc[Cid]; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc validate(ma: MultiAddress): bool" href="libp2p/multiaddress.html#validate%2CMultiAddress">multiaddress: proc validate(ma: MultiAddress): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc validate(mhtype: typedesc[MultiHash]; data: openArray[byte]): bool" href="libp2p/multihash.html#validate%2Ctypedesc%5BMultiHash%5D%2CopenArray%5Bbyte%5D">multihash: proc validate(mhtype: typedesc[MultiHash]; data: openArray[byte]): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc validate(pid: PeerId): bool" href="libp2p/peerid.html#validate%2CPeerId">peerid: proc validate(pid: PeerId): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="pubsub: method validate(p: PubSub; message: Message): InternalRaisesFuture[ValidationResult,
    (CancelledError,)]" href="libp2p/protocols/pubsub/pubsub.html#validate.e%2CPubSub%2CMessage">pubsub: method validate(p: PubSub; message: Message): InternalRaisesFuture[ValidationResult,
    (CancelledError,)]</a></li>
          </ul></dd>
<dt><a name="validatedObservers" href="#validatedObservers"><span>validatedObservers:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsubpeer: proc validatedObservers(p: PubSubPeer; msg: Message; msgId: MessageId)" href="libp2p/protocols/pubsub/pubsubpeer.html#validatedObservers%2CPubSubPeer%2CMessage%2CMessageId">pubsubpeer: proc validatedObservers(p: PubSubPeer; msg: Message; msgId: MessageId)</a></li>
          </ul></dd>
<dt><a name="validateParameters" href="#validateParameters"><span>validateParameters:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="gossipsub: proc validateParameters(parameters: GossipSubParams): Result[void, cstring]" href="libp2p/protocols/pubsub/gossipsub.html#validateParameters%2CGossipSubParams">gossipsub: proc validateParameters(parameters: GossipSubParams): Result[void, cstring]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="gossipsub: proc validateParameters(parameters: TopicParams): Result[void, cstring]" href="libp2p/protocols/pubsub/gossipsub.html#validateParameters%2CTopicParams">gossipsub: proc validateParameters(parameters: TopicParams): Result[void, cstring]</a></li>
          </ul></dd>
<dt><a name="ValidationResult" href="#ValidationResult"><span>ValidationResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="errors: enum ValidationResult" href="libp2p/protocols/pubsub/errors.html#ValidationResult">errors: enum ValidationResult</a></li>
          </ul></dd>
<dt><a name="ValidationSeenTable" href="#ValidationSeenTable"><span>ValidationSeenTable:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type ValidationSeenTable" href="libp2p/protocols/pubsub/gossipsub/types.html#ValidationSeenTable">types: type ValidationSeenTable</a></li>
          </ul></dd>
<dt><a name="ValidatorHandler" href="#ValidatorHandler"><span>ValidatorHandler:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="pubsub: type ValidatorHandler" href="libp2p/protocols/pubsub/pubsub.html#ValidatorHandler">pubsub: type ValidatorHandler</a></li>
          </ul></dd>
<dt><a name="value" href="#value"><span>value:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="bandwidth: proc value(e: var ExponentialMovingAverage): float" href="libp2p/protocols/pubsub/bandwidth.html#value%2CExponentialMovingAverage">bandwidth: proc value(e: var ExponentialMovingAverage): float</a></li>
          </ul></dd>
<dt><a name="valueOr" href="#valueOr"><span>valueOr:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: template valueOr[T](self: Option[T]; body: untyped): untyped" href="libp2p/utility.html#valueOr.t%2COption%5BT%5D%2Cuntyped">utility: template valueOr[T](self: Option[T]; body: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="Varint" href="#Varint"><span>Varint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFieldKind.Varint" href="libp2p/protobuf/minprotobuf.html#Varint">minprotobuf: ProtoFieldKind.Varint</a></li>
          </ul></dd>
<dt><a name="VarintError" href="#VarintError"><span>VarintError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: enum VarintError" href="libp2p/varint.html#VarintError">varint: enum VarintError</a></li>
          </ul></dd>
<dt><a name="VarintResult" href="#VarintResult"><span>VarintResult:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type VarintResult" href="libp2p/varint.html#VarintResult">varint: type VarintResult</a></li>
          </ul></dd>
<dt><a name="VBuffer" href="#VBuffer"><span>VBuffer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: object VBuffer" href="libp2p/vbuffer.html#VBuffer">vbuffer: object VBuffer</a></li>
          </ul></dd>
<dt><a name="verify" href="#verify"><span>verify:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="crypto: proc verify(sig: Signature; message: openArray[byte]; key: PublicKey): bool" href="libp2p/crypto/crypto.html#verify%2CSignature%2CopenArray%5Bbyte%5D%2CPublicKey">crypto: proc verify(sig: Signature; message: openArray[byte]; key: PublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ecnist: proc verify[T: byte | char](sig: EcSignature; message: openArray[T];
                       pubkey: EcPublicKey): bool" href="libp2p/crypto/ecnist.html#verify%2CEcSignature%2CopenArray%5BT%5D%2CEcPublicKey">ecnist: proc verify[T: byte | char](sig: EcSignature; message: openArray[T];
                       pubkey: EcPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="ed25519: proc verify[T: byte | char](sig: EdSignature; message: openArray[T]; key: EdPublicKey): bool" href="libp2p/crypto/ed25519/ed25519.html#verify%2CEdSignature%2CopenArray%5BT%5D%2CEdPublicKey">ed25519: proc verify[T: byte | char](sig: EdSignature; message: openArray[T]; key: EdPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rsa: proc verify[T: byte | char](sig: RsaSignature; message: openArray[T];
                       pubkey: RsaPublicKey): bool" href="libp2p/crypto/rsa.html#verify%2CRsaSignature%2CopenArray%5BT%5D%2CRsaPublicKey">rsa: proc verify[T: byte | char](sig: RsaSignature; message: openArray[T];
                       pubkey: RsaPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="secp: proc verify[T: byte | char](sig: SkSignature; msg: openArray[T]; key: SkPublicKey): bool" href="libp2p/crypto/secp.html#verify%2CSkSignature%2CopenArray%5BT%5D%2CSkPublicKey">secp: proc verify[T: byte | char](sig: SkSignature; msg: openArray[T]; key: SkPublicKey): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="message: proc verify(m: Message): bool" href="libp2p/protocols/pubsub/rpc/message.html#verify%2CMessage">message: proc verify(m: Message): bool</a></li>
          <li><a class="reference external"
          data-doc-search-tag="certificate: proc verify(self: P2pCertificate): bool" href="libp2p/transports/tls/certificate.html#verify%2CP2pCertificate">certificate: proc verify(self: P2pCertificate): bool</a></li>
          </ul></dd>
<dt><a name="version" href="#version"><span>version:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc version(cid: Cid): CidVersion" href="libp2p/cid.html#version%2CCid">cid: proc version(cid: Cid): CidVersion</a></li>
          </ul></dd>
<dt><a name="Voucher" href="#Voucher"><span>Voucher:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: object Voucher" href="libp2p/protocols/connectivity/relay/messages.html#Voucher">messages: object Voucher</a></li>
          </ul></dd>
<dt><a name="vsizeof" href="#vsizeof"><span>vsizeof:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc vsizeof(field: ProtoField): int" href="libp2p/protobuf/minprotobuf.html#vsizeof%2CProtoField">minprotobuf: proc vsizeof(field: ProtoField): int</a></li>
          <li><a class="reference external"
          data-doc-search-tag="varint: proc vsizeof(x: SomeVarint): int" href="libp2p/varint.html#vsizeof%2CSomeVarint">varint: proc vsizeof(x: SomeVarint): int</a></li>
          </ul></dd>
<dt><a name="waitForService" href="#waitForService"><span>waitForService:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="utility: proc waitForService(host: string; port: Port; retries: int = 20;
               delay: chronos.Duration = 500.milliseconds): Future[bool]" href="libp2p/utility.html#waitForService%2Cstring%2CPort%2Cint">utility: proc waitForService(host: string; port: Port; retries: int = 20;
               delay: chronos.Duration = 500.milliseconds): Future[bool]</a></li>
          </ul></dd>
<dt><a name="WebRTCDirect" href="#WebRTCDirect"><span>WebRTCDirect:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WebRTCDirect" href="libp2p/multiaddress.html#WebRTCDirect">multiaddress: const WebRTCDirect</a></li>
          </ul></dd>
<dt><a name="WebSockets" href="#WebSockets"><span>WebSockets:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WebSockets" href="libp2p/multiaddress.html#WebSockets">multiaddress: const WebSockets</a></li>
          </ul></dd>
<dt><a name="WebSockets_DNS" href="#WebSockets_DNS"><span>WebSockets_DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WebSockets_DNS" href="libp2p/multiaddress.html#WebSockets_DNS">multiaddress: const WebSockets_DNS</a></li>
          </ul></dd>
<dt><a name="WebSockets_IP" href="#WebSockets_IP"><span>WebSockets_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WebSockets_IP" href="libp2p/multiaddress.html#WebSockets_IP">multiaddress: const WebSockets_IP</a></li>
          </ul></dd>
<dt><a name="WildcardAddressResolverService" href="#WildcardAddressResolverService"><span>WildcardAddressResolverService:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wildcardresolverservice: type WildcardAddressResolverService" href="libp2p/services/wildcardresolverservice.html#WildcardAddressResolverService">wildcardresolverservice: type WildcardAddressResolverService</a></li>
          </ul></dd>
<dt><a name="window" href="#window"><span>window:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="mcache: proc window(c: MCache; topic: string): HashSet[MessageId]" href="libp2p/protocols/pubsub/mcache.html#window%2CMCache%2Cstring">mcache: proc window(c: MCache; topic: string): HashSet[MessageId]</a></li>
          </ul></dd>
<dt><a name="withAddress" href="#withAddress"><span>withAddress:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withAddress(b: SwitchBuilder; address: MultiAddress;
            enableWildcardResolver: bool = true): SwitchBuilder" href="libp2p/builders.html#withAddress%2CSwitchBuilder%2CMultiAddress%2Cbool">builders: proc withAddress(b: SwitchBuilder; address: MultiAddress;
            enableWildcardResolver: bool = true): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withAddresses" href="#withAddresses"><span>withAddresses:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withAddresses(b: SwitchBuilder; addresses: seq[MultiAddress];
              enableWildcardResolver: bool = true): SwitchBuilder" href="libp2p/builders.html#withAddresses%2CSwitchBuilder%2Cseq%5BMultiAddress%5D%2Cbool">builders: proc withAddresses(b: SwitchBuilder; addresses: seq[MultiAddress];
              enableWildcardResolver: bool = true): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withAgentVersion" href="#withAgentVersion"><span>withAgentVersion:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withAgentVersion(b: SwitchBuilder; agentVersion: string): SwitchBuilder" href="libp2p/builders.html#withAgentVersion%2CSwitchBuilder%2Cstring">builders: proc withAgentVersion(b: SwitchBuilder; agentVersion: string): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withAutonat" href="#withAutonat"><span>withAutonat:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withAutonat(b: SwitchBuilder): SwitchBuilder" href="libp2p/builders.html#withAutonat%2CSwitchBuilder">builders: proc withAutonat(b: SwitchBuilder): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withAutonatV2" href="#withAutonatV2"><span>withAutonatV2:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withAutonatV2(b: SwitchBuilder; serviceConfig = AutonatV2ServiceConfig.new()): SwitchBuilder" href="libp2p/builders.html#withAutonatV2%2CSwitchBuilder">builders: proc withAutonatV2(b: SwitchBuilder; serviceConfig = AutonatV2ServiceConfig.new()): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withAutonatV2Server" href="#withAutonatV2Server"><span>withAutonatV2Server:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withAutonatV2Server(b: SwitchBuilder;
                    config: AutonatV2Config = AutonatV2Config.new()): SwitchBuilder" href="libp2p/builders.html#withAutonatV2Server%2CSwitchBuilder%2CAutonatV2Config">builders: proc withAutonatV2Server(b: SwitchBuilder;
                    config: AutonatV2Config = AutonatV2Config.new()): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withCircuitRelay" href="#withCircuitRelay"><span>withCircuitRelay:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withCircuitRelay(b: SwitchBuilder; r: Relay = Relay.new()): SwitchBuilder" href="libp2p/builders.html#withCircuitRelay%2CSwitchBuilder%2CRelay">builders: proc withCircuitRelay(b: SwitchBuilder; r: Relay = Relay.new()): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withKademlia" href="#withKademlia"><span>withKademlia:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withKademlia(b: SwitchBuilder;
             bootstrapNodes: seq[(PeerId, seq[MultiAddress])] = @[];
             config: KadDHTConfig = KadDHTConfig.new()): SwitchBuilder" href="libp2p/builders.html#withKademlia%2CSwitchBuilder%2Cseq%5B%5D%2CKadDHTConfig">builders: proc withKademlia(b: SwitchBuilder;
             bootstrapNodes: seq[(PeerId, seq[MultiAddress])] = @[];
             config: KadDHTConfig = KadDHTConfig.new()): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withMaxConnections" href="#withMaxConnections"><span>withMaxConnections:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withMaxConnections(b: SwitchBuilder; maxConnections: int): SwitchBuilder" href="libp2p/builders.html#withMaxConnections%2CSwitchBuilder%2Cint">builders: proc withMaxConnections(b: SwitchBuilder; maxConnections: int): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withMaxConnsPerPeer" href="#withMaxConnsPerPeer"><span>withMaxConnsPerPeer:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withMaxConnsPerPeer(b: SwitchBuilder; maxConnsPerPeer: int): SwitchBuilder" href="libp2p/builders.html#withMaxConnsPerPeer%2CSwitchBuilder%2Cint">builders: proc withMaxConnsPerPeer(b: SwitchBuilder; maxConnsPerPeer: int): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withMaxIn" href="#withMaxIn"><span>withMaxIn:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withMaxIn(b: SwitchBuilder; maxIn: int): SwitchBuilder" href="libp2p/builders.html#withMaxIn%2CSwitchBuilder%2Cint">builders: proc withMaxIn(b: SwitchBuilder; maxIn: int): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withMaxOut" href="#withMaxOut"><span>withMaxOut:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withMaxOut(b: SwitchBuilder; maxOut: int): SwitchBuilder" href="libp2p/builders.html#withMaxOut%2CSwitchBuilder%2Cint">builders: proc withMaxOut(b: SwitchBuilder; maxOut: int): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withMemoryTransport" href="#withMemoryTransport"><span>withMemoryTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withMemoryTransport(b: SwitchBuilder): SwitchBuilder" href="libp2p/builders.html#withMemoryTransport%2CSwitchBuilder">builders: proc withMemoryTransport(b: SwitchBuilder): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withMplex" href="#withMplex"><span>withMplex:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withMplex(b: SwitchBuilder; inTimeout = 5.minutes; outTimeout = 5.minutes;
          maxChannCount = 200): SwitchBuilder" href="libp2p/builders.html#withMplex%2CSwitchBuilder%2Cint">builders: proc withMplex(b: SwitchBuilder; inTimeout = 5.minutes; outTimeout = 5.minutes;
          maxChannCount = 200): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withNameResolver" href="#withNameResolver"><span>withNameResolver:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withNameResolver(b: SwitchBuilder; nameResolver: NameResolver): SwitchBuilder" href="libp2p/builders.html#withNameResolver%2CSwitchBuilder%2CNameResolver">builders: proc withNameResolver(b: SwitchBuilder; nameResolver: NameResolver): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withNoise" href="#withNoise"><span>withNoise:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withNoise(b: SwitchBuilder): SwitchBuilder" href="libp2p/builders.html#withNoise%2CSwitchBuilder">builders: proc withNoise(b: SwitchBuilder): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withObservedAddrManager" href="#withObservedAddrManager"><span>withObservedAddrManager:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withObservedAddrManager(b: SwitchBuilder;
                        observedAddrManager: ObservedAddrManager): SwitchBuilder" href="libp2p/builders.html#withObservedAddrManager%2CSwitchBuilder%2CObservedAddrManager">builders: proc withObservedAddrManager(b: SwitchBuilder;
                        observedAddrManager: ObservedAddrManager): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withPeerStats" href="#withPeerStats"><span>withPeerStats:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="scoring: proc withPeerStats(g: GossipSub; peerId: PeerId;
              action: proc (stats: var PeerStats) {.gcsafe, raises: [].})" href="libp2p/protocols/pubsub/gossipsub/scoring.html#withPeerStats%2CGossipSub%2CPeerId%2Cproc%28PeerStats%29">scoring: proc withPeerStats(g: GossipSub; peerId: PeerId;
              action: proc (stats: var PeerStats) {.gcsafe, raises: [].})</a></li>
          </ul></dd>
<dt><a name="withPeerStore" href="#withPeerStore"><span>withPeerStore:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withPeerStore(b: SwitchBuilder; capacity: int): SwitchBuilder" href="libp2p/builders.html#withPeerStore%2CSwitchBuilder%2Cint">builders: proc withPeerStore(b: SwitchBuilder; capacity: int): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withPrivateKey" href="#withPrivateKey"><span>withPrivateKey:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withPrivateKey(b: SwitchBuilder; privateKey: PrivateKey): SwitchBuilder" href="libp2p/builders.html#withPrivateKey%2CSwitchBuilder%2CPrivateKey">builders: proc withPrivateKey(b: SwitchBuilder; privateKey: PrivateKey): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withProtoVersion" href="#withProtoVersion"><span>withProtoVersion:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withProtoVersion(b: SwitchBuilder; protoVersion: string): SwitchBuilder" href="libp2p/builders.html#withProtoVersion%2CSwitchBuilder%2Cstring">builders: proc withProtoVersion(b: SwitchBuilder; protoVersion: string): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withQuicTransport" href="#withQuicTransport"><span>withQuicTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withQuicTransport(b: SwitchBuilder): SwitchBuilder" href="libp2p/builders.html#withQuicTransport%2CSwitchBuilder">builders: proc withQuicTransport(b: SwitchBuilder): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withRendezVous" href="#withRendezVous"><span>withRendezVous:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withRendezVous(b: SwitchBuilder; rdv: RendezVous): SwitchBuilder" href="libp2p/builders.html#withRendezVous%2CSwitchBuilder%2CRendezVous">builders: proc withRendezVous(b: SwitchBuilder; rdv: RendezVous): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withRng" href="#withRng"><span>withRng:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withRng(b: SwitchBuilder; rng: ref HmacDrbgContext): SwitchBuilder" href="libp2p/builders.html#withRng%2CSwitchBuilder%2Cref.HmacDrbgContext">builders: proc withRng(b: SwitchBuilder; rng: ref HmacDrbgContext): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withServices" href="#withServices"><span>withServices:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withServices(b: SwitchBuilder; services: seq[Service]): SwitchBuilder" href="libp2p/builders.html#withServices%2CSwitchBuilder%2Cseq%5BService%5D">builders: proc withServices(b: SwitchBuilder; services: seq[Service]): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withSignedPeerRecord" href="#withSignedPeerRecord"><span>withSignedPeerRecord:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withSignedPeerRecord(b: SwitchBuilder; sendIt = true): SwitchBuilder" href="libp2p/builders.html#withSignedPeerRecord%2CSwitchBuilder">builders: proc withSignedPeerRecord(b: SwitchBuilder; sendIt = true): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withSubs" href="#withSubs"><span>withSubs:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="messages: proc withSubs(T: type RPCMsg; topics: openArray[string]; subscribe: bool): T:type" href="libp2p/protocols/pubsub/rpc/messages.html#withSubs%2CtypeRPCMsg%2CopenArray%5Bstring%5D%2Cbool">messages: proc withSubs(T: type RPCMsg; topics: openArray[string]; subscribe: bool): T:type</a></li>
          </ul></dd>
<dt><a name="withTcpTransport" href="#withTcpTransport"><span>withTcpTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withTcpTransport(b: SwitchBuilder; flags: set[ServerFlags] = {}): SwitchBuilder" href="libp2p/builders.html#withTcpTransport%2CSwitchBuilder%2Cset%5BServerFlags%5D">builders: proc withTcpTransport(b: SwitchBuilder; flags: set[ServerFlags] = {}): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withTransport" href="#withTransport"><span>withTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withTransport(b: SwitchBuilder; prov: TransportBuilder): SwitchBuilder" href="libp2p/builders.html#withTransport%2CSwitchBuilder%2CTransportBuilder">builders: proc withTransport(b: SwitchBuilder; prov: TransportBuilder): SwitchBuilder</a></li>
          <li><a class="reference external"
          data-doc-search-tag="builders: proc withTransport(b: SwitchBuilder; prov: TransportProvider): SwitchBuilder" href="libp2p/builders.html#withTransport%2CSwitchBuilder%2CTransportProvider">builders: proc withTransport(b: SwitchBuilder; prov: TransportProvider): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="WithUint32BeLength" href="#WithUint32BeLength"><span>WithUint32BeLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFlags.WithUint32BeLength" href="libp2p/protobuf/minprotobuf.html#WithUint32BeLength">minprotobuf: ProtoFlags.WithUint32BeLength</a></li>
          </ul></dd>
<dt><a name="WithUint32LeLength" href="#WithUint32LeLength"><span>WithUint32LeLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFlags.WithUint32LeLength" href="libp2p/protobuf/minprotobuf.html#WithUint32LeLength">minprotobuf: ProtoFlags.WithUint32LeLength</a></li>
          </ul></dd>
<dt><a name="withValue" href="#withValue"><span>withValue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="preamblestore: template withValue(ps: var PreambleStore; key: MessageId; value, body: untyped)" href="libp2p/protocols/pubsub/gossipsub/preamblestore.html#withValue.t%2CPreambleStore%2CMessageId%2Cuntyped%2Cuntyped">preamblestore: template withValue(ps: var PreambleStore; key: MessageId; value, body: untyped)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utility: macro withValue[T](self: Opt[T] | Option[T]; value, body, elseStmt: untyped): untyped" href="libp2p/utility.html#withValue.m%2C%2Cuntyped%2Cuntyped%2Cuntyped">utility: macro withValue[T](self: Opt[T] | Option[T]; value, body, elseStmt: untyped): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utility: template withValue[T](self: Opt[T] | Option[T]; value, body: untyped): untyped" href="libp2p/utility.html#withValue.t%2C%2Cuntyped%2Cuntyped">utility: template withValue[T](self: Opt[T] | Option[T]; value, body: untyped): untyped</a></li>
          <li><a class="reference external"
          data-doc-search-tag="utility: template withValue[T, E](self: Result[T, E]; value, body: untyped): untyped" href="libp2p/utility.html#withValue.t%2CResult%5BT%2CE%5D%2Cuntyped%2Cuntyped">utility: template withValue[T, E](self: Result[T, E]; value, body: untyped): untyped</a></li>
          </ul></dd>
<dt><a name="WithVarintLength" href="#WithVarintLength"><span>WithVarintLength:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: ProtoFlags.WithVarintLength" href="libp2p/protobuf/minprotobuf.html#WithVarintLength">minprotobuf: ProtoFlags.WithVarintLength</a></li>
          </ul></dd>
<dt><a name="withWsTransport" href="#withWsTransport"><span>withWsTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withWsTransport(b: SwitchBuilder; tlsPrivateKey: TLSPrivateKey = nil;
                tlsCertificate: TLSCertificate = nil;
                tlsFlags: set[TLSFlags] = {}; flags: set[ServerFlags] = {}): SwitchBuilder" href="libp2p/builders.html#withWsTransport%2CSwitchBuilder%2CTLSPrivateKey%2CTLSCertificate%2Cset%5BTLSFlags%5D%2Cset%5BServerFlags%5D">builders: proc withWsTransport(b: SwitchBuilder; tlsPrivateKey: TLSPrivateKey = nil;
                tlsCertificate: TLSCertificate = nil;
                tlsFlags: set[TLSFlags] = {}; flags: set[ServerFlags] = {}): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="withYamux" href="#withYamux"><span>withYamux:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="builders: proc withYamux(b: SwitchBuilder; maxChannCount: int = MaxChannelCount;
          windowSize: int = YamuxDefaultWindowSize;
          inTimeout: Duration = 5.minutes; outTimeout: Duration = 5.minutes): SwitchBuilder" href="libp2p/builders.html#withYamux%2CSwitchBuilder%2Cint%2Cint%2CDuration%2CDuration">builders: proc withYamux(b: SwitchBuilder; maxChannCount: int = MaxChannelCount;
          windowSize: int = YamuxDefaultWindowSize;
          inTimeout: Duration = 5.minutes; outTimeout: Duration = 5.minutes): SwitchBuilder</a></li>
          </ul></dd>
<dt><a name="write" href="#write"><span>write:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="cid: proc write(vb: var VBuffer; cid: Cid)" href="libp2p/cid.html#write%2CVBuffer%2CCid">cid: proc write(vb: var VBuffer; cid: Cid)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc write(pb: var ProtoBuffer; field: int; sig: Signature)" href="libp2p/crypto/crypto.html#write%2CProtoBuffer%2Cint%2CSignature">crypto: proc write(pb: var ProtoBuffer; field: int; sig: Signature)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc write[T: PublicKey | PrivateKey](pb: var ProtoBuffer; field: int; key: T)" href="libp2p/crypto/crypto.html#write%2CProtoBuffer%2Cint%2CT">crypto: proc write[T: PublicKey | PrivateKey](pb: var ProtoBuffer; field: int; key: T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc write(vb: var VBuffer; seckey: PrivateKey)" href="libp2p/crypto/crypto.html#write%2CVBuffer%2CPrivateKey">crypto: proc write(vb: var VBuffer; seckey: PrivateKey)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc write(vb: var VBuffer; sig: PrivateKey)" href="libp2p/crypto/crypto.html#write%2CVBuffer%2CPrivateKey_2">crypto: proc write(vb: var VBuffer; sig: PrivateKey)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="crypto: proc write(vb: var VBuffer; pubkey: PublicKey)" href="libp2p/crypto/crypto.html#write%2CVBuffer%2CPublicKey">crypto: proc write(vb: var VBuffer; pubkey: PublicKey)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; value: Asn1Composite)" href="libp2p/crypto/minasn1.html#write%2CT%2CAsn1Composite">minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; value: Asn1Composite)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; tag: Asn1Tag)" href="libp2p/crypto/minasn1.html#write%2CT%2CAsn1Tag">minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; tag: Asn1Tag)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; tag: Asn1Tag;
                                     value: openArray[byte]; bits = 0)" href="libp2p/crypto/minasn1.html#write%2CT%2CAsn1Tag%2CopenArray%5Bbyte%5D%2Cint">minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; tag: Asn1Tag;
                                     value: openArray[byte]; bits = 0)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; value: bool)" href="libp2p/crypto/minasn1.html#write%2CT%2Cbool">minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; value: bool)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; value: uint64)" href="libp2p/crypto/minasn1.html#write%2CT%2Cuint64">minasn1: proc write[T: Asn1Buffer | Asn1Composite](abc: var T; value: uint64)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc write(pb: var ProtoBuffer; field: int; value: MultiAddress)" href="libp2p/multiaddress.html#write%2CProtoBuffer%2Cint%2CMultiAddress">multiaddress: proc write(pb: var ProtoBuffer; field: int; value: MultiAddress)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multiaddress: proc write(vb: var VBuffer; ma: MultiAddress)" href="libp2p/multiaddress.html#write%2CVBuffer%2CMultiAddress">multiaddress: proc write(vb: var VBuffer; ma: MultiAddress)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multicodec: proc write(vb: var VBuffer; mc: MultiCodec)" href="libp2p/multicodec.html#write%2CVBuffer%2CMultiCodec">multicodec: proc write(vb: var VBuffer; mc: MultiCodec)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="multihash: proc write(vb: var VBuffer; mh: MultiHash)" href="libp2p/multihash.html#write%2CVBuffer%2CMultiHash">multihash: proc write(vb: var VBuffer; mh: MultiHash)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpchannel: method write(s: LPChannel; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/muxers/mplex/lpchannel.html#write.e%2CLPChannel%2Cseq%5Bbyte%5D">lpchannel: method write(s: LPChannel; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="yamux: method write(channel: YamuxChannel; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/muxers/yamux/yamux.html#write.e%2CYamuxChannel%2Cseq%5Bbyte%5D">yamux: method write(channel: YamuxChannel; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc write(pb: var ProtoBuffer; field: int; pid: PeerId)" href="libp2p/peerid.html#write%2CProtoBuffer%2Cint%2CPeerId">peerid: proc write(pb: var ProtoBuffer; field: int; pid: PeerId)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="peerid: proc write(vb: var VBuffer; pid: PeerId)" href="libp2p/peerid.html#write%2CVBuffer%2CPeerId">peerid: proc write(vb: var VBuffer; pid: PeerId)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc write[T: byte | char](pb: var ProtoBuffer; field: int; value: openArray[T])" href="libp2p/protobuf/minprotobuf.html#write%2CProtoBuffer%2Cint%2CopenArray%5BT%5D">minprotobuf: proc write[T: byte | char](pb: var ProtoBuffer; field: int; value: openArray[T])</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc write(pb: var ProtoBuffer; field: int; value: ProtoBuffer)" href="libp2p/protobuf/minprotobuf.html#write%2CProtoBuffer%2Cint%2CProtoBuffer">minprotobuf: proc write(pb: var ProtoBuffer; field: int; value: ProtoBuffer)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc write[T: ProtoScalar](pb: var ProtoBuffer; field: int; value: T)" href="libp2p/protobuf/minprotobuf.html#write%2CProtoBuffer%2Cint%2CT">minprotobuf: proc write[T: ProtoScalar](pb: var ProtoBuffer; field: int; value: T)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="rconn: method write(self: RelayConnection; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/connectivity/relay/rconn.html#write.e%2CRelayConnection%2Cseq%5Bbyte%5D">rconn: method write(self: RelayConnection; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; value: Record)" href="libp2p/protocols/kademlia/protobuf.html#write%2CProtoBuffer%2Cint%2CRecord">protobuf: proc write(pb: var ProtoBuffer; field: int; value: Record)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; graft: ControlGraft)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CControlGraft">protobuf: proc write(pb: var ProtoBuffer; field: int; graft: ControlGraft)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; ihave: ControlIHave)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CControlIHave">protobuf: proc write(pb: var ProtoBuffer; field: int; ihave: ControlIHave)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; imreceiving: ControlIMReceiving)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CControlIMReceiving">protobuf: proc write(pb: var ProtoBuffer; field: int; imreceiving: ControlIMReceiving)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; iwant: ControlIWant)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CControlIWant">protobuf: proc write(pb: var ProtoBuffer; field: int; iwant: ControlIWant)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; control: ControlMessage)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CControlMessage">protobuf: proc write(pb: var ProtoBuffer; field: int; control: ControlMessage)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; preamble: ControlPreamble)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CControlPreamble">protobuf: proc write(pb: var ProtoBuffer; field: int; preamble: ControlPreamble)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; prune: ControlPrune)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CControlPrune">protobuf: proc write(pb: var ProtoBuffer; field: int; prune: ControlPrune)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; msg: Message; anonymize: bool)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CMessage%2Cbool">protobuf: proc write(pb: var ProtoBuffer; field: int; msg: Message; anonymize: bool)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; infoMsg: PeerInfoMsg)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CPeerInfoMsg">protobuf: proc write(pb: var ProtoBuffer; field: int; infoMsg: PeerInfoMsg)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="protobuf: proc write(pb: var ProtoBuffer; field: int; subs: SubOpts)" href="libp2p/protocols/pubsub/rpc/protobuf.html#write%2CProtoBuffer%2Cint%2CSubOpts">protobuf: proc write(pb: var ProtoBuffer; field: int; subs: SubOpts)</a></li>
          <li><a class="reference external"
          data-doc-search-tag="noise: method write(sconn: NoiseConnection; message: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/protocols/secure/noise.html#write.e%2CNoiseConnection%2Cseq%5Bbyte%5D">noise: method write(sconn: NoiseConnection; message: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="signed_envelope: proc write(pb: var ProtoBuffer; field: int; env: Envelope): Result[void, CryptoError]" href="libp2p/signed_envelope.html#write%2CProtoBuffer%2Cint%2CEnvelope">signed_envelope: proc write(pb: var ProtoBuffer; field: int; env: Envelope): Result[void, CryptoError]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="bridgestream: method write(s: BridgeStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/bridgestream.html#write.e%2CBridgeStream%2Cseq%5Bbyte%5D">bridgestream: method write(s: BridgeStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="chronosstream: method write(s: ChronosStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/chronosstream.html#write.e%2CChronosStream%2Cseq%5Bbyte%5D">chronosstream: method write(s: ChronosStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: proc write(s: LPStream; msg: string): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#write%2CLPStream%2Cstring">lpstream: proc write(s: LPStream; msg: string): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method write(s: LPStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#write.e%2CLPStream%2Cseq%5Bbyte%5D">lpstream: method write(s: LPStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="quictransport: method write(stream: QuicStream; bytes: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/transports/quictransport.html#write.e%2CQuicStream%2Cseq%5Bbyte%5D">quictransport: method write(stream: QuicStream; bytes: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="wstransport: method write(s: WsStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/transports/wstransport.html#write.e%2CWsStream%2Cseq%5Bbyte%5D">wstransport: method write(s: WsStream; msg: seq[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="writeArray" href="#writeArray"><span>writeArray:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc writeArray[T: byte | char](vb: var VBuffer; value: openArray[T])" href="libp2p/vbuffer.html#writeArray%2CVBuffer%2CopenArray%5BT%5D">vbuffer: proc writeArray[T: byte | char](vb: var VBuffer; value: openArray[T])</a></li>
          </ul></dd>
<dt><a name="writeLp" href="#writeLp"><span>writeLp:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="lpstream: method writeLp(s: LPStream; msg: openArray[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#writeLp.e%2CLPStream%2CopenArray%5Bbyte%5D">lpstream: method writeLp(s: LPStream; msg: openArray[byte]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="lpstream: method writeLp(s: LPStream; msg: string): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/stream/lpstream.html#writeLp.e%2CLPStream%2Cstring">lpstream: method writeLp(s: LPStream; msg: string): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="writeLPVarint" href="#writeLPVarint"><span>writeLPVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc writeLPVarint(vb: var VBuffer; value: LPSomeUVarint)" href="libp2p/vbuffer.html#writeLPVarint%2CVBuffer%2CLPSomeUVarint">vbuffer: proc writeLPVarint(vb: var VBuffer; value: LPSomeUVarint)</a></li>
          </ul></dd>
<dt><a name="writeMsg" href="#writeMsg"><span>writeMsg:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="coder: proc writeMsg(conn: Connection; id: uint64; msgType: MessageType;
         data: seq[byte] = @[]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]" href="libp2p/muxers/mplex/coder.html#writeMsg%2CConnection%2Cuint64%2CMessageType%2Cseq%5Bbyte%5D">coder: proc writeMsg(conn: Connection; id: uint64; msgType: MessageType;
         data: seq[byte] = @[]): InternalRaisesFuture[void,
    (CancelledError, LPStreamError)]</a></li>
          <li><a class="reference external"
          data-doc-search-tag="coder: proc writeMsg(conn: Connection; id: uint64; msgType: MessageType; data: string): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]" href="libp2p/muxers/mplex/coder.html#writeMsg%2CConnection%2Cuint64%2CMessageType%2Cstring">coder: proc writeMsg(conn: Connection; id: uint64; msgType: MessageType; data: string): InternalRaisesFuture[
    void, (CancelledError, LPStreamError)]</a></li>
          </ul></dd>
<dt><a name="writeOpt" href="#writeOpt"><span>writeOpt:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="protobuf: proc writeOpt[T](pb: var ProtoBuffer; field: int; opt: Opt[T])" href="libp2p/protocols/kademlia/protobuf.html#writeOpt%2CProtoBuffer%2Cint%2COpt%5BT%5D">protobuf: proc writeOpt[T](pb: var ProtoBuffer; field: int; opt: Opt[T])</a></li>
          </ul></dd>
<dt><a name="writePacked" href="#writePacked"><span>writePacked:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="minprotobuf: proc writePacked[T: ProtoScalar](pb: var ProtoBuffer; field: int; value: openArray[T])" href="libp2p/protobuf/minprotobuf.html#writePacked%2CProtoBuffer%2Cint%2CopenArray%5BT%5D">minprotobuf: proc writePacked[T: ProtoScalar](pb: var ProtoBuffer; field: int; value: openArray[T])</a></li>
          </ul></dd>
<dt><a name="writePBVarint" href="#writePBVarint"><span>writePBVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc writePBVarint(vb: var VBuffer; value: PBSomeUVarint)" href="libp2p/vbuffer.html#writePBVarint%2CVBuffer%2CPBSomeUVarint">vbuffer: proc writePBVarint(vb: var VBuffer; value: PBSomeUVarint)</a></li>
          </ul></dd>
<dt><a name="writeSeq" href="#writeSeq"><span>writeSeq:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc writeSeq[T: byte | char](vb: var VBuffer; value: openArray[T])" href="libp2p/vbuffer.html#writeSeq%2CVBuffer%2CopenArray%5BT%5D">vbuffer: proc writeSeq[T: byte | char](vb: var VBuffer; value: openArray[T])</a></li>
          </ul></dd>
<dt><a name="writeVarint" href="#writeVarint"><span>writeVarint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="vbuffer: proc writeVarint(vb: var VBuffer; value: LPSomeUVarint)" href="libp2p/vbuffer.html#writeVarint%2CVBuffer%2CLPSomeUVarint">vbuffer: proc writeVarint(vb: var VBuffer; value: LPSomeUVarint)</a></li>
          </ul></dd>
<dt><a name="WrongPingAckError" href="#WrongPingAckError"><span>WrongPingAckError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="ping: object WrongPingAckError" href="libp2p/protocols/ping.html#WrongPingAckError">ping: object WrongPingAckError</a></li>
          </ul></dd>
<dt><a name="WS" href="#WS"><span>WS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WS" href="libp2p/multiaddress.html#WS">multiaddress: const WS</a></li>
          </ul></dd>
<dt><a name="WS_DNS" href="#WS_DNS"><span>WS_DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WS_DNS" href="libp2p/multiaddress.html#WS_DNS">multiaddress: const WS_DNS</a></li>
          </ul></dd>
<dt><a name="WS_IP" href="#WS_IP"><span>WS_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WS_IP" href="libp2p/multiaddress.html#WS_IP">multiaddress: const WS_IP</a></li>
          </ul></dd>
<dt><a name="WSS" href="#WSS"><span>WSS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WSS" href="libp2p/multiaddress.html#WSS">multiaddress: const WSS</a></li>
          </ul></dd>
<dt><a name="WSS_DNS" href="#WSS_DNS"><span>WSS_DNS:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WSS_DNS" href="libp2p/multiaddress.html#WSS_DNS">multiaddress: const WSS_DNS</a></li>
          </ul></dd>
<dt><a name="WSS_IP" href="#WSS_IP"><span>WSS_IP:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="multiaddress: const WSS_IP" href="libp2p/multiaddress.html#WSS_IP">multiaddress: const WSS_IP</a></li>
          </ul></dd>
<dt><a name="WsTransport" href="#WsTransport"><span>WsTransport:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wstransport: type WsTransport" href="libp2p/transports/wstransport.html#WsTransport">wstransport: type WsTransport</a></li>
          </ul></dd>
<dt><a name="WsTransportError" href="#WsTransportError"><span>WsTransportError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="wstransport: object WsTransportError" href="libp2p/transports/wstransport.html#WsTransportError">wstransport: object WsTransportError</a></li>
          </ul></dd>
<dt><a name="XorDHasher" href="#XorDHasher"><span>XorDHasher:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type XorDHasher" href="libp2p/protocols/kademlia/types.html#XorDHasher">types: type XorDHasher</a></li>
          </ul></dd>
<dt><a name="XorDistance" href="#XorDistance"><span>XorDistance:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: type XorDistance" href="libp2p/protocols/kademlia/types.html#XorDistance">types: type XorDistance</a></li>
          </ul></dd>
<dt><a name="xorDistance" href="#xorDistance"><span>xorDistance:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="types: proc xorDistance(a, b: Key; hasher: Opt[XorDHasher]): XorDistance" href="libp2p/protocols/kademlia/types.html#xorDistance%2CKey%2CKey%2COpt%5BXorDHasher%5D">types: proc xorDistance(a, b: Key; hasher: Opt[XorDHasher]): XorDistance</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc xorDistance(a: Key; b: PeerId; hasher: Opt[XorDHasher]): XorDistance" href="libp2p/protocols/kademlia/types.html#xorDistance%2CKey%2CPeerId%2COpt%5BXorDHasher%5D">types: proc xorDistance(a: Key; b: PeerId; hasher: Opt[XorDHasher]): XorDistance</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc xorDistance(a: PeerId; b: Key; hasher: Opt[XorDHasher]): XorDistance" href="libp2p/protocols/kademlia/types.html#xorDistance%2CPeerId%2CKey%2COpt%5BXorDHasher%5D">types: proc xorDistance(a: PeerId; b: Key; hasher: Opt[XorDHasher]): XorDistance</a></li>
          <li><a class="reference external"
          data-doc-search-tag="types: proc xorDistance(a, b: PeerId; hasher: Opt[XorDHasher]): XorDistance" href="libp2p/protocols/kademlia/types.html#xorDistance%2CPeerId%2CPeerId%2COpt%5BXorDHasher%5D">types: proc xorDistance(a, b: PeerId; hasher: Opt[XorDHasher]): XorDistance</a></li>
          </ul></dd>
<dt><a name="Yamux" href="#Yamux"><span>Yamux:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: type Yamux" href="libp2p/muxers/yamux/yamux.html#Yamux">yamux: type Yamux</a></li>
          </ul></dd>
<dt><a name="YamuxChannel" href="#YamuxChannel"><span>YamuxChannel:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: type YamuxChannel" href="libp2p/muxers/yamux/yamux.html#YamuxChannel">yamux: type YamuxChannel</a></li>
          </ul></dd>
<dt><a name="YamuxCodec" href="#YamuxCodec"><span>YamuxCodec:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: const YamuxCodec" href="libp2p/muxers/yamux/yamux.html#YamuxCodec">yamux: const YamuxCodec</a></li>
          </ul></dd>
<dt><a name="YamuxDefaultWindowSize" href="#YamuxDefaultWindowSize"><span>YamuxDefaultWindowSize:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: const YamuxDefaultWindowSize" href="libp2p/muxers/yamux/yamux.html#YamuxDefaultWindowSize">yamux: const YamuxDefaultWindowSize</a></li>
          </ul></dd>
<dt><a name="YamuxError" href="#YamuxError"><span>YamuxError:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="yamux: object YamuxError" href="libp2p/muxers/yamux/yamux.html#YamuxError">yamux: object YamuxError</a></li>
          </ul></dd>
<dt><a name="ZeroFe" href="#ZeroFe"><span>ZeroFe:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="constants: const ZeroFe" href="libp2p/crypto/ed25519/constants.html#ZeroFe">constants: const ZeroFe</a></li>
          </ul></dd>
<dt><a name="ZeroQueue" href="#ZeroQueue"><span>ZeroQueue:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="zeroqueue: object ZeroQueue" href="libp2p/utils/zeroqueue.html#ZeroQueue">zeroqueue: object ZeroQueue</a></li>
          </ul></dd>
<dt><a name="zint" href="#zint"><span>zint:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type zint" href="libp2p/varint.html#zint">varint: type zint</a></li>
          </ul></dd>
<dt><a name="zint32" href="#zint32"><span>zint32:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type zint32" href="libp2p/varint.html#zint32">varint: type zint32</a></li>
          </ul></dd>
<dt><a name="zint64" href="#zint64"><span>zint64:</span></a></dt><dd><ul class="simple">
<li><a class="reference external"
          data-doc-search-tag="varint: type zint64" href="libp2p/varint.html#zint64">varint: type zint64</a></li>
          </ul></dd>
</dl>
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2025-12-15 21:14:53 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
